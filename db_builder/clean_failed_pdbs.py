#!/usr/bin/env python
# Copyright 2025 Tobias Olenyi.
# SPDX-License-Identifier: Apache-2.0

"""
Utility script to clean up failed PDB downloads for Snakemake retry.

This script checks the status files generated by the pdb_download.py rule
in the Snakemake pipeline. If a download was marked as unsuccessful,
it deletes the corresponding (likely empty or incomplete) .struct file.
This allows Snakemake to automatically retry downloading these files
on the next run.
"""

import json
import logging
import os
from pathlib import Path
import sys
import yaml  # To read Snakemake config

# Basic logging configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)


def load_config(config_path: Path = Path("db_builder/config.yaml")) -> dict:
    """Load the Snakemake configuration file."""
    if not config_path.exists():
        logger.error(f"Configuration file not found: {config_path}")
        sys.exit(1)
    try:
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
        return config
    except yaml.YAMLError as e:
        logger.error(f"Error parsing configuration file {config_path}: {e}")
        sys.exit(1)
    except IOError as e:
        logger.error(f"Error reading configuration file {config_path}: {e}")
        sys.exit(1)


def clean_failed_downloads(pdb_dir: Path) -> None:
    """
    Identifies failed downloads and removes their corresponding .struct files.

    Args:
        pdb_dir: The directory containing the .struct and .status files.
    """
    if not pdb_dir.is_dir():
        logger.error(f"PDB directory not found or is not a directory: {pdb_dir}")
        return

    cleaned_count = 0
    status_files_found = 0

    logger.info(f"Scanning for failed downloads in: {pdb_dir}")
    for status_file in pdb_dir.glob("*.status"):
        status_files_found += 1
        pdb_id = status_file.stem.split(".")[
            0
        ]  # Get PDB ID from filename like '1abc.status'
        struct_file = pdb_dir / f"{pdb_id}.struct"

        try:
            with open(status_file, "r") as f:
                status_data = json.load(f)

            if not status_data.get("success", False):
                logger.info(f"Found failed download for PDB ID: {pdb_id}")
                if struct_file.exists():
                    try:
                        os.remove(struct_file)
                        logger.info(
                            f"--> Deleted potentially incomplete file: {struct_file}"
                        )
                        cleaned_count += 1
                    except OSError as e:
                        logger.error(f"--> Failed to delete {struct_file}: {e}")
                else:
                    logger.warning(
                        f"--> Struct file not found, nothing to delete: {struct_file}"
                    )

        except json.JSONDecodeError:
            logger.warning(
                f"Could not parse status file (may be corrupted): {status_file}"
            )
        except IOError as e:
            logger.error(f"Could not read status file {status_file}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error processing {status_file}: {e}")

    if status_files_found == 0:
        logger.warning(
            f"No .status files found in {pdb_dir}. Has the download step run?"
        )
    elif cleaned_count == 0:
        logger.info("No failed downloads found requiring cleanup.")
    else:
        logger.info(
            f"Cleanup finished. Deleted {cleaned_count} file(s) corresponding to failed downloads."
        )
        logger.info("You can now re-run Snakemake to retry the downloads.")


def main() -> None:
    """Main execution function."""
    config = load_config()
    work_dir = Path(
        config.get("work_dir", "tmp/alignment_pipeline")
    )  # Default from snakefile
    pdb_dir = work_dir / "pdbs"
    clean_failed_downloads(pdb_dir)


if __name__ == "__main__":
    main()
