{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About FlatProt is a Python package for protein structure and sequence analysis. It provides standardized 2D visualizations for enhanced protein comparability, combining efficient processing of proteins with user-friendly visualizations. Standard Workflow on the command line FlatProt provides four main commands for protein structure analysis. Note The following examples assume you've installed FlatProt with uv tool add FlatProt . If you're using the no-install option, replace flatprot with uvx flatprot in all commands. Single Structure Projection Generate 2D projections of individual protein structures in three simple steps: Obtain the protein structure file (CIF or PDB format) From databases like PDB, AlphaFold, or your own modeling tools CIF format is recommended for better handling of complex structures Calculate secondary structure using DSSP Run: mkdssp -i structure.cif -o structure.cif This identifies \u03b1-helices, \u03b2-sheets, and other structural elements Generate the 2D projection with FlatProt Basic usage: flatprot project structure.cif -o projection.svg With pdb file: flatprot project structure.pdb --dssp structure.dssp -o projection.svg Customize with options like --canvas-width 500 --canvas-height 400 for sizing Multi-Structure Comparison Create overlay visualizations to compare multiple related structures: Collect related structure files (same family or similar proteins) Generate family-aligned overlay: flatprot overlay \"structures/*.cif\" -o comparison.png For consistent size comparison: flatprot overlay \"structures/*.cif\" --disable-scaling -o overlay.png Structure Alignment Align structures to known protein families: Find best matching family: flatprot align structure.cif -i alignment_info.json Use alignment in projections: flatprot project structure.cif --matrix alignment_matrix.npy -o aligned.svg Region-Based Analysis Extract and visualize specific structural regions with comparative alignment: Define regions of interest: flatprot split protein.cif --regions \"A:1-100,A:150-250\" -o regions.svg With database alignment: flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_regions.svg Progressive gap positioning: flatprot split protein.cif --regions \"A:1-100,A:150-250\" --gap-x 150 --gap-y 100 -o positioned.svg Common Command Chaining Workflows Family Comparison with Optimal Conservation For optimal conservation across multiple structures, align all to the same family reference: # 1. Find optimal alignment for family flatprot align reference_protein.cif -i family_info.json # 2. Extract family ID from results family_id=$(jq -r '.best_hit.target_id' family_info.json) # 3. Create conserved overlay using fixed family ID flatprot overlay \"family_proteins/*.cif\" --family \"$family_id\" -o family_overlay.png Aligned Structure Visualization Create family-aligned 2D projections of individual structures: # 1. Find optimal family alignment flatprot align protein.cif -m alignment_matrix.npy # 2. Create aligned 2D projection flatprot project protein.cif --matrix alignment_matrix.npy -o aligned_protein.svg Comprehensive Domain Analysis Combine full structure and domain-specific views: # 1. Create full structure view flatprot project protein.cif -o full_structure.svg # 2. Extract and align specific domains flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o domains.svg The resulting files contain clean, publication-ready 2D representations that can be viewed in any web browser or vector graphics editor. Key Features Single Structure Visualization : Standardized 2D projections of individual protein structures Multi-Structure Overlays : Compare multiple structures with automatic clustering and alignment Region-Based Analysis : Extract and visualize specific domains, motifs, or binding sites with comparative alignment Family-Based Alignment : Integration with Foldseek alignments for protein family mapping with rotation-only transformations Database Annotations : Automatic SCOP family identification and alignment probability display Batch Processing : Efficient processing of proteins across varying sizes High Performance : Fast response times even for large, complex structures Scalable : Support for proteins up to 3,000 residues and datasets with 50+ structures Publication Ready : Clear and consistent visualizations for structure analysis Visualization Options FlatProt offers multiple visualization types to suit different analysis needs: Normal : Standard visualization with detailed secondary structure representation Simple-coil : Simplified coil representation while maintaining detailed secondary structure elements Only-path : Minimalist path representation of the protein structure Special : Enhanced visualization with customizable features for specific analysis needs Secondary Structure Representation Helices : Visualized in red (#F05039), with options for simple or detailed representation Sheets : Shown in blue (#1F449C) with arrow representations Coils : Displayed in black with adjustable simplification levels Advanced Features Multi-chain Support : Automatic handling and visualization of multiple protein chains Region-Specific Extraction : Precise extraction of structural domains, motifs, and binding sites Database-Driven Alignment : Integration with FoldSeek for family-specific structural alignment Rotation-Only Transformations : Align region orientations while preserving spatial relationships SCOP Family Annotations : Automatic identification and display of structural classification annotations Alignment Quality Metrics : Display of alignment probabilities and confidence scores Progressive Gap Positioning : Flexible domain spacing with configurable horizontal and vertical gaps for comparative visualization LDDT Score Visualization : Color-coded representation of local distance difference test scores Residue Annotations : Optional display of amino acid annotations and chain positions Custom Highlighting : Support for manual residue and bond highlighting through JSON configuration Citation & Data If you use FlatProt in your research, please cite our preprint: FlatProt: 2D visualization eases protein structure comparison Tobias Olenyi, Constantin Carl, Tobias Senoner, Ivan Koludarov, Burkhard Rost bioRxiv 2025.04.22.650077; doi: https://doi.org/10.1101/2025.04.22.650077 Datasets and supplementary data are available on Zenodo:","title":"Home"},{"location":"#about","text":"FlatProt is a Python package for protein structure and sequence analysis. It provides standardized 2D visualizations for enhanced protein comparability, combining efficient processing of proteins with user-friendly visualizations.","title":"About"},{"location":"#standard-workflow-on-the-command-line","text":"FlatProt provides four main commands for protein structure analysis. Note The following examples assume you've installed FlatProt with uv tool add FlatProt . If you're using the no-install option, replace flatprot with uvx flatprot in all commands.","title":"Standard Workflow on the command line"},{"location":"#single-structure-projection","text":"Generate 2D projections of individual protein structures in three simple steps: Obtain the protein structure file (CIF or PDB format) From databases like PDB, AlphaFold, or your own modeling tools CIF format is recommended for better handling of complex structures Calculate secondary structure using DSSP Run: mkdssp -i structure.cif -o structure.cif This identifies \u03b1-helices, \u03b2-sheets, and other structural elements Generate the 2D projection with FlatProt Basic usage: flatprot project structure.cif -o projection.svg With pdb file: flatprot project structure.pdb --dssp structure.dssp -o projection.svg Customize with options like --canvas-width 500 --canvas-height 400 for sizing","title":"Single Structure Projection"},{"location":"#multi-structure-comparison","text":"Create overlay visualizations to compare multiple related structures: Collect related structure files (same family or similar proteins) Generate family-aligned overlay: flatprot overlay \"structures/*.cif\" -o comparison.png For consistent size comparison: flatprot overlay \"structures/*.cif\" --disable-scaling -o overlay.png","title":"Multi-Structure Comparison"},{"location":"#structure-alignment","text":"Align structures to known protein families: Find best matching family: flatprot align structure.cif -i alignment_info.json Use alignment in projections: flatprot project structure.cif --matrix alignment_matrix.npy -o aligned.svg","title":"Structure Alignment"},{"location":"#region-based-analysis","text":"Extract and visualize specific structural regions with comparative alignment: Define regions of interest: flatprot split protein.cif --regions \"A:1-100,A:150-250\" -o regions.svg With database alignment: flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_regions.svg Progressive gap positioning: flatprot split protein.cif --regions \"A:1-100,A:150-250\" --gap-x 150 --gap-y 100 -o positioned.svg","title":"Region-Based Analysis"},{"location":"#common-command-chaining-workflows","text":"","title":"Common Command Chaining Workflows"},{"location":"#family-comparison-with-optimal-conservation","text":"For optimal conservation across multiple structures, align all to the same family reference: # 1. Find optimal alignment for family flatprot align reference_protein.cif -i family_info.json # 2. Extract family ID from results family_id=$(jq -r '.best_hit.target_id' family_info.json) # 3. Create conserved overlay using fixed family ID flatprot overlay \"family_proteins/*.cif\" --family \"$family_id\" -o family_overlay.png","title":"Family Comparison with Optimal Conservation"},{"location":"#aligned-structure-visualization","text":"Create family-aligned 2D projections of individual structures: # 1. Find optimal family alignment flatprot align protein.cif -m alignment_matrix.npy # 2. Create aligned 2D projection flatprot project protein.cif --matrix alignment_matrix.npy -o aligned_protein.svg","title":"Aligned Structure Visualization"},{"location":"#comprehensive-domain-analysis","text":"Combine full structure and domain-specific views: # 1. Create full structure view flatprot project protein.cif -o full_structure.svg # 2. Extract and align specific domains flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o domains.svg The resulting files contain clean, publication-ready 2D representations that can be viewed in any web browser or vector graphics editor.","title":"Comprehensive Domain Analysis"},{"location":"#key-features","text":"Single Structure Visualization : Standardized 2D projections of individual protein structures Multi-Structure Overlays : Compare multiple structures with automatic clustering and alignment Region-Based Analysis : Extract and visualize specific domains, motifs, or binding sites with comparative alignment Family-Based Alignment : Integration with Foldseek alignments for protein family mapping with rotation-only transformations Database Annotations : Automatic SCOP family identification and alignment probability display Batch Processing : Efficient processing of proteins across varying sizes High Performance : Fast response times even for large, complex structures Scalable : Support for proteins up to 3,000 residues and datasets with 50+ structures Publication Ready : Clear and consistent visualizations for structure analysis","title":"Key Features"},{"location":"#visualization-options","text":"FlatProt offers multiple visualization types to suit different analysis needs: Normal : Standard visualization with detailed secondary structure representation Simple-coil : Simplified coil representation while maintaining detailed secondary structure elements Only-path : Minimalist path representation of the protein structure Special : Enhanced visualization with customizable features for specific analysis needs","title":"Visualization Options"},{"location":"#secondary-structure-representation","text":"Helices : Visualized in red (#F05039), with options for simple or detailed representation Sheets : Shown in blue (#1F449C) with arrow representations Coils : Displayed in black with adjustable simplification levels","title":"Secondary Structure Representation"},{"location":"#advanced-features","text":"Multi-chain Support : Automatic handling and visualization of multiple protein chains Region-Specific Extraction : Precise extraction of structural domains, motifs, and binding sites Database-Driven Alignment : Integration with FoldSeek for family-specific structural alignment Rotation-Only Transformations : Align region orientations while preserving spatial relationships SCOP Family Annotations : Automatic identification and display of structural classification annotations Alignment Quality Metrics : Display of alignment probabilities and confidence scores Progressive Gap Positioning : Flexible domain spacing with configurable horizontal and vertical gaps for comparative visualization LDDT Score Visualization : Color-coded representation of local distance difference test scores Residue Annotations : Optional display of amino acid annotations and chain positions Custom Highlighting : Support for manual residue and bond highlighting through JSON configuration","title":"Advanced Features"},{"location":"#citation-data","text":"If you use FlatProt in your research, please cite our preprint: FlatProt: 2D visualization eases protein structure comparison Tobias Olenyi, Constantin Carl, Tobias Senoner, Ivan Koludarov, Burkhard Rost bioRxiv 2025.04.22.650077; doi: https://doi.org/10.1101/2025.04.22.650077 Datasets and supplementary data are available on Zenodo:","title":"Citation &amp; Data"},{"location":"examples/","text":"Examples Interactive Jupyter notebooks demonstrating FlatProt's capabilities, from basic protein projections to advanced overlay visualizations. \ud83d\ude80 Getting Started Quick Start New to FlatProt? Start with the Basic Projection example Want to compare proteins? Try the Protein Alignment example Need publication graphics? Use the Protein Overlay example Running Examples Google Colab: Click any badge below - setup is automatic! Local Jupyter: Clone the repo and run notebooks directly Command Line: Extract the core commands marked with \ud83c\udfaf \ud83d\udcd6 Core Examples Basic Protein Projection Perfect for beginners! Ultra-clean example using native Jupyter shell commands ( !flatprot project ). Creates 2D visualizations with minimal complexity. Protein Family Overlay One command, multiple proteins! Ultra-simplified demonstration using shell commands. Shows automatic clustering, alignment, and family visualization. Protein Alignment and Projection Compare related protein structures with consistent alignment! Shows how to align three similar toxins to a reference database and create side-by-side projections with consistent orientation. Protein Domain Splitting Extract and visualize protein domains separately! Demonstrates how to use flatprot split to extract structural domains and create individual visualizations for comparative analysis. \ud83d\udd2c Advanced Examples UniProt to AlphaFold Visualization From UniProt ID to visualization in minutes! Automatically downloads AlphaFold structures, extracts functional annotations from UniProt, aligns to protein families, and creates publication-ready visualizations. Features automatic binding site detection and multiple visualization variants. Custom Styling and Annotations Create protein visualizations with custom colors and annotations! Demonstrates modern color schemes, point/line/area annotations, and style variations. Includes a side-by-side comparison gallery showing different aesthetic approaches. Disulfide Bond Detection Automated disulfide bond analysis! Shows how to detect disulfide bonds, generate annotation files programmatically, and create annotated visualizations. Perfect example of structural bioinformatics automation. \ud83d\udca1 Learning Path \ud83d\ude80 Recommended (Clean & Simple): 1. Start: Basic Projection - Pure shell commands, minimal complexity 2. Align: Protein Alignment and Projection - Structure comparison with consistent alignment 3. Domains: Protein Domain Splitting - Extract and visualize domains separately 4. Features: Disulfide Bond Detection - Automated bond analysis + annotations 5. Scale up: Protein Family Overlay - Multi-protein visualization \ud83d\udd2c Advanced (Full-Featured): 6. Customize: Custom Styling - Color schemes and annotations 7. Research: UniProt to AlphaFold - Complete research workflow \ud83d\udd27 Technical Notes About Notebook Complexity: Much of the code in these notebooks handles automatic Google Colab setup (dependency installation, data download, environment configuration). The actual FlatProt usage is typically just 1-3 commands per example! Essential Commands (in Jupyter): # Basic projection (SVG output) !flatprot project structure.cif -o output.svg # Multi-protein overlay (PNG/PDF available) !flatprot overlay \"structures/*.cif\" -o overlay.png --family 3000114 --clustering # Structure alignment !flatprot align structure.cif matrix.npy info.json Output Formats: - flatprot project \u2192 SVG only (vector graphics, perfect for notebooks) - flatprot overlay \u2192 SVG, PNG, PDF (PNG great for Colab compatibility) - flatprot split \u2192 SVG only Automation: Notebooks are automatically generated from Python source files using scripts/create-notebooks.sh and jupytext.","title":"Examples"},{"location":"examples/#examples","text":"Interactive Jupyter notebooks demonstrating FlatProt's capabilities, from basic protein projections to advanced overlay visualizations.","title":"Examples"},{"location":"examples/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"examples/#quick-start","text":"New to FlatProt? Start with the Basic Projection example Want to compare proteins? Try the Protein Alignment example Need publication graphics? Use the Protein Overlay example","title":"Quick Start"},{"location":"examples/#running-examples","text":"Google Colab: Click any badge below - setup is automatic! Local Jupyter: Clone the repo and run notebooks directly Command Line: Extract the core commands marked with \ud83c\udfaf","title":"Running Examples"},{"location":"examples/#core-examples","text":"","title":"\ud83d\udcd6 Core Examples"},{"location":"examples/#basic-protein-projection","text":"Perfect for beginners! Ultra-clean example using native Jupyter shell commands ( !flatprot project ). Creates 2D visualizations with minimal complexity.","title":"Basic Protein Projection"},{"location":"examples/#protein-family-overlay","text":"One command, multiple proteins! Ultra-simplified demonstration using shell commands. Shows automatic clustering, alignment, and family visualization.","title":"Protein Family Overlay"},{"location":"examples/#protein-alignment-and-projection","text":"Compare related protein structures with consistent alignment! Shows how to align three similar toxins to a reference database and create side-by-side projections with consistent orientation.","title":"Protein Alignment and Projection"},{"location":"examples/#protein-domain-splitting","text":"Extract and visualize protein domains separately! Demonstrates how to use flatprot split to extract structural domains and create individual visualizations for comparative analysis.","title":"Protein Domain Splitting"},{"location":"examples/#advanced-examples","text":"","title":"\ud83d\udd2c Advanced Examples"},{"location":"examples/#uniprot-to-alphafold-visualization","text":"From UniProt ID to visualization in minutes! Automatically downloads AlphaFold structures, extracts functional annotations from UniProt, aligns to protein families, and creates publication-ready visualizations. Features automatic binding site detection and multiple visualization variants.","title":"UniProt to AlphaFold Visualization"},{"location":"examples/#custom-styling-and-annotations","text":"Create protein visualizations with custom colors and annotations! Demonstrates modern color schemes, point/line/area annotations, and style variations. Includes a side-by-side comparison gallery showing different aesthetic approaches.","title":"Custom Styling and Annotations"},{"location":"examples/#disulfide-bond-detection","text":"Automated disulfide bond analysis! Shows how to detect disulfide bonds, generate annotation files programmatically, and create annotated visualizations. Perfect example of structural bioinformatics automation.","title":"Disulfide Bond Detection"},{"location":"examples/#learning-path","text":"\ud83d\ude80 Recommended (Clean & Simple): 1. Start: Basic Projection - Pure shell commands, minimal complexity 2. Align: Protein Alignment and Projection - Structure comparison with consistent alignment 3. Domains: Protein Domain Splitting - Extract and visualize domains separately 4. Features: Disulfide Bond Detection - Automated bond analysis + annotations 5. Scale up: Protein Family Overlay - Multi-protein visualization \ud83d\udd2c Advanced (Full-Featured): 6. Customize: Custom Styling - Color schemes and annotations 7. Research: UniProt to AlphaFold - Complete research workflow","title":"\ud83d\udca1 Learning Path"},{"location":"examples/#technical-notes","text":"About Notebook Complexity: Much of the code in these notebooks handles automatic Google Colab setup (dependency installation, data download, environment configuration). The actual FlatProt usage is typically just 1-3 commands per example! Essential Commands (in Jupyter): # Basic projection (SVG output) !flatprot project structure.cif -o output.svg # Multi-protein overlay (PNG/PDF available) !flatprot overlay \"structures/*.cif\" -o overlay.png --family 3000114 --clustering # Structure alignment !flatprot align structure.cif matrix.npy info.json Output Formats: - flatprot project \u2192 SVG only (vector graphics, perfect for notebooks) - flatprot overlay \u2192 SVG, PNG, PDF (PNG great for Colab compatibility) - flatprot split \u2192 SVG only Automation: Notebooks are automatically generated from Python source files using scripts/create-notebooks.sh and jupytext.","title":"\ud83d\udd27 Technical Notes"},{"location":"installation/","text":"Installation FlatProt can be installed using uv (recommended) or pip. The package requires Python 3.11-3.13. Quick Installation Using uv (Recommended) Install uv if you haven't already: curl -LsSf https://astral.sh/uv/install.sh | sh Then install FlatProt: uvx tool install flatprot Or for temporary usage: uvx flatprot Verify the installation: flatprot --version Using pip pip install flatprot Development Installation For development work: uv add flatprot Required Dependencies FlatProt has several external dependencies that need to be installed separately: 1. DSSP (Required for PDB Files) DSSP is required for secondary structure assignment when working with PDB format files. FlatProt requires mkdssp version 4.4.0+ . Installation Options: macOS (Homebrew): brew install dssp Ubuntu/Debian: sudo apt-get install dssp Conda/Mamba: conda install conda-forge::dssp Manual Installation: - Download from: DSSP Download Page - Follow platform-specific build instructions - Ensure the mkdssp executable is in your PATH Verification: mkdssp --version 2. FoldSeek (Required for Alignment Features) FoldSeek is required for database alignment functionality in the align and split commands. Installation Options: Conda/Mamba (Recommended): conda install bioconda::foldseek Manual Installation: - Download from: FoldSeek GitHub - Follow platform-specific build instructions - Ensure the foldseek executable is in your PATH Verification: foldseek --version 3. Cairo (Optional - Required for PNG/PDF Output) Cairo is required only for PNG and PDF output from the flatprot overlay command. SVG output works without Cairo. macOS: brew install cairo Ubuntu/Debian: sudo apt-get install libcairo2-dev pkg-config Windows: Install Cairo binaries or use conda: conda install cairo Verification: python -c \"import drawsvg; print('Cairo available:', hasattr(drawsvg, '_cairo_available') and drawsvg._cairo_available)\" Complete Setup Workflow Here's a complete setup workflow for different scenarios: Basic Usage (CIF files only) # Install FlatProt uvx tool install flatprot # Test with CIF file (no additional dependencies needed) flatprot project structure.cif -o output.svg Full Feature Usage # Install FlatProt uvx tool install flatprot # Install dependencies brew install dssp cairo # macOS conda install bioconda::foldseek conda-forge::dssp cairo # Cross-platform # Test full functionality flatprot split structure.cif --regions \"A:1-100\" --show-database-alignment flatprot overlay \"structures/*.cif\" -o overlay.png Platform-Specific Notes macOS: Homebrew provides the most reliable installations All dependencies available through brew On newer M-series models, setting up Cairo requires manual adjustment to find the library path. Linux: Use package manager when possible Conda/mamba provides consistent cross-distribution support Windows: Conda/mamba recommended for all dependencies Manual installation may require additional build tools Performance Optimization For better performance, consider: Use CIF format when possible Pre-compute DSSP files for batch processing of PDB files Next Steps After installation, check out: Getting Started Guide Command Line Interface Documentation Examples","title":"Installation"},{"location":"installation/#installation","text":"FlatProt can be installed using uv (recommended) or pip. The package requires Python 3.11-3.13.","title":"Installation"},{"location":"installation/#quick-installation","text":"","title":"Quick Installation"},{"location":"installation/#using-uv-recommended","text":"Install uv if you haven't already: curl -LsSf https://astral.sh/uv/install.sh | sh Then install FlatProt: uvx tool install flatprot Or for temporary usage: uvx flatprot Verify the installation: flatprot --version","title":"Using uv (Recommended)"},{"location":"installation/#using-pip","text":"pip install flatprot","title":"Using pip"},{"location":"installation/#development-installation","text":"For development work: uv add flatprot","title":"Development Installation"},{"location":"installation/#required-dependencies","text":"FlatProt has several external dependencies that need to be installed separately:","title":"Required Dependencies"},{"location":"installation/#1-dssp-required-for-pdb-files","text":"DSSP is required for secondary structure assignment when working with PDB format files. FlatProt requires mkdssp version 4.4.0+ . Installation Options: macOS (Homebrew): brew install dssp Ubuntu/Debian: sudo apt-get install dssp Conda/Mamba: conda install conda-forge::dssp Manual Installation: - Download from: DSSP Download Page - Follow platform-specific build instructions - Ensure the mkdssp executable is in your PATH Verification: mkdssp --version","title":"1. DSSP (Required for PDB Files)"},{"location":"installation/#2-foldseek-required-for-alignment-features","text":"FoldSeek is required for database alignment functionality in the align and split commands. Installation Options: Conda/Mamba (Recommended): conda install bioconda::foldseek Manual Installation: - Download from: FoldSeek GitHub - Follow platform-specific build instructions - Ensure the foldseek executable is in your PATH Verification: foldseek --version","title":"2. FoldSeek (Required for Alignment Features)"},{"location":"installation/#3-cairo-optional-required-for-pngpdf-output","text":"Cairo is required only for PNG and PDF output from the flatprot overlay command. SVG output works without Cairo. macOS: brew install cairo Ubuntu/Debian: sudo apt-get install libcairo2-dev pkg-config Windows: Install Cairo binaries or use conda: conda install cairo Verification: python -c \"import drawsvg; print('Cairo available:', hasattr(drawsvg, '_cairo_available') and drawsvg._cairo_available)\"","title":"3. Cairo (Optional - Required for PNG/PDF Output)"},{"location":"installation/#complete-setup-workflow","text":"Here's a complete setup workflow for different scenarios:","title":"Complete Setup Workflow"},{"location":"installation/#basic-usage-cif-files-only","text":"# Install FlatProt uvx tool install flatprot # Test with CIF file (no additional dependencies needed) flatprot project structure.cif -o output.svg","title":"Basic Usage (CIF files only)"},{"location":"installation/#full-feature-usage","text":"# Install FlatProt uvx tool install flatprot # Install dependencies brew install dssp cairo # macOS conda install bioconda::foldseek conda-forge::dssp cairo # Cross-platform # Test full functionality flatprot split structure.cif --regions \"A:1-100\" --show-database-alignment flatprot overlay \"structures/*.cif\" -o overlay.png","title":"Full Feature Usage"},{"location":"installation/#platform-specific-notes","text":"macOS: Homebrew provides the most reliable installations All dependencies available through brew On newer M-series models, setting up Cairo requires manual adjustment to find the library path. Linux: Use package manager when possible Conda/mamba provides consistent cross-distribution support Windows: Conda/mamba recommended for all dependencies Manual installation may require additional build tools","title":"Platform-Specific Notes"},{"location":"installation/#performance-optimization","text":"For better performance, consider: Use CIF format when possible Pre-compute DSSP files for batch processing of PDB files","title":"Performance Optimization"},{"location":"installation/#next-steps","text":"After installation, check out: Getting Started Guide Command Line Interface Documentation Examples","title":"Next Steps"},{"location":"api/alignment/","text":"Alignment API This section documents the components responsible for structural alignment in FlatProt, primarily focused on finding the best match in a reference database and retrieving the associated transformation matrix. Alignment Concept The alignment process in FlatProt serves to orient an input protein structure according to a standardized reference frame, typically based on its structural superfamily. Structural Search: It uses an external tool, Foldseek, to search a pre-compiled database of reference structures (e.g., CATH domains) for the best structural match to the input protein. Result Filtering: The Foldseek results are filtered based on metrics like alignment probability ( --min-probability ) or by specifying a direct target ID ( --target-db-id ). Matrix Retrieval: Once a suitable match is identified (represented by a target_id from Foldseek), FlatProt queries its internal HDF5 database ( AlignmentDatabase ) using this target_id . This database stores pre-calculated 4x4 transformation matrices that map the reference structure (the target) to a standardized orientation for its superfamily. Output: The primary output is the retrieved transformation matrix ( TransformationMatrix ), which can then be used by the project command to render the input structure in the standardized orientation. Alignment metadata (scores, matched IDs) can also be saved. Top-Level Alignment Functions These functions provide the main entry points for performing alignment using a database. AlignmentDBEntry dataclass Stores alignment data with its rotation matrix. Source code in src/flatprot/alignment/db.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @dataclass class AlignmentDBEntry : \"\"\"Stores alignment data with its rotation matrix.\"\"\" rotation_matrix : TransformationMatrix entry_id : str structure_name : str metadata : Optional [ Dict [ str , float | str ]] = None def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , AlignmentDBEntry ): return False return ( np . allclose ( self . rotation_matrix . to_array (), other . rotation_matrix . to_array () ) and self . entry_id == other . entry_id and self . structure_name == other . structure_name ) AlignmentDatabase Handles alignment database using HDF5 storage with memory-mapped arrays. Source code in src/flatprot/alignment/db.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AlignmentDatabase : \"\"\"Handles alignment database using HDF5 storage with memory-mapped arrays.\"\"\" def __init__ ( self , path : Path ): self . path = path self . _file : Optional [ h5py . File ] = None self . _structure_name_index : dict [ str , str ] = {} # structure_name -> entry_id def __enter__ ( self ): self . open () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None def _load_index ( self ) -> None : \"\"\"Loads structure name index from HDF5 file.\"\"\" if \"index\" not in self . _file : return names = self . _file [ \"index/structure_names\" ][:] ids = self . _file [ \"index/entry_ids\" ][:] self . _structure_name_index = dict ( zip ( names , ids )) def _save_index ( self ) -> None : \"\"\"Saves structure name index to HDF5 file.\"\"\" if \"index\" in self . _file : del self . _file [ \"index\" ] index = self . _file . create_group ( \"index\" ) names = list ( self . _structure_name_index . keys ()) ids = list ( self . _structure_name_index . values ()) index . create_dataset ( \"structure_names\" , data = names ) index . create_dataset ( \"entry_ids\" , data = ids ) def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index () add_entry ( entry ) Adds a new entry to the database. Source code in src/flatprot/alignment/db.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () close () Closes the database file. Source code in src/flatprot/alignment/db.py 55 56 57 58 59 def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None contains_entry_id ( entry_id ) Checks if an entry_id exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 81 82 83 84 85 def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file contains_structure_name ( structure_name ) Checks if a structure_name exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 87 88 89 def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index get_by_entry_id ( entry_id , default = None ) Returns alignment entry for given entry_id or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) get_by_structure_name ( structure_name , default = None ) Returns alignment entry for given structure_name or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 109 110 111 112 113 114 115 116 def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) open () Opens the database file in read/write mode. Source code in src/flatprot/alignment/db.py 50 51 52 53 def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () update ( entry ) Updates an existing entry in the database. Source code in src/flatprot/alignment/db.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index () AlignmentError Bases: FlatProtError Base class for alignment-related errors. Source code in src/flatprot/alignment/errors.py 8 9 10 11 class AlignmentError ( FlatProtError ): \"\"\"Base class for alignment-related errors.\"\"\" pass AlignmentResult Bases: NamedTuple Results from a structural family alignment. Source code in src/flatprot/alignment/foldseek.py 15 16 17 18 19 20 21 22 class AlignmentResult ( NamedTuple ): \"\"\"Results from a structural family alignment.\"\"\" db_id : str probability : float aligned_region : np . ndarray alignment_scores : np . ndarray rotation_matrix : TransformationMatrix DatabaseEntryNotFoundError Bases: AlignmentError Raised when a database entry is not found. Source code in src/flatprot/alignment/errors.py 20 21 22 23 class DatabaseEntryNotFoundError ( AlignmentError ): \"\"\"Raised when a database entry is not found.\"\"\" pass FoldseekAligner Handles structural family alignments using FoldSeek. Source code in src/flatprot/alignment/foldseek.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class FoldseekAligner : \"\"\"Handles structural family alignments using FoldSeek.\"\"\" def __init__ ( self , foldseek_executable : str , database_path : Path , ): self . foldseek_executable = foldseek_executable self . database_path = database_path def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results def _run_foldseek_batch_search ( self , structures_dir : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek batch search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structures_dir ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) def _run_foldseek_search ( self , structure_path : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structure_path ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) align_structure ( structure_path , min_probability = 0.5 , fixed_alignment_id = None , tmp_dir = None ) Aligns structure to family database and returns best match. Source code in src/flatprot/alignment/foldseek.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) align_structures_batch ( structure_paths , min_probability = 0.5 , fixed_alignment_id = None , tmp_dir = None ) Batch align multiple structures to family database for better performance. Parameters: structure_paths ( List [ Path ] ) \u2013 List of structure file paths to align min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold fixed_alignment_id ( Optional [ str ] , default: None ) \u2013 Optional fixed family ID for all alignments tmp_dir ( Optional [ Path ] , default: None ) \u2013 Optional temporary directory path Returns: Dict [ Path , Optional [ AlignmentResult ]] \u2013 Dictionary mapping structure paths to their alignment results Source code in src/flatprot/alignment/foldseek.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results NoSignificantAlignmentError Bases: AlignmentError Raised when no significant alignment is found. Source code in src/flatprot/alignment/errors.py 14 15 16 17 class NoSignificantAlignmentError ( AlignmentError ): \"\"\"Raised when no significant alignment is found.\"\"\" pass align_structure_database ( structure_file , foldseek_db_path , foldseek_command = 'foldseek' , min_probability = 0.5 , target_db_id = None ) Calculate the alignment result for structural alignment using FoldSeek. Parameters: structure_file ( Path ) \u2013 Path to input protein structure file (PDB/mmCIF). foldseek_db_path ( Path ) \u2013 Path to FoldSeek-specific database. foldseek_command ( str , default: 'foldseek' ) \u2013 FoldSeek executable name/path. min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold. target_db_id ( Optional [ str ] , default: None ) \u2013 If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult ( AlignmentResult ) \u2013 Result containing alignment details and rotation matrix. Raises: AlignmentError \u2013 General alignment failures NoSignificantAlignmentError \u2013 No alignment meets probability threshold Source code in src/flatprot/alignment/utils.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def align_structure_database ( structure_file : Path , foldseek_db_path : Path , foldseek_command : str = \"foldseek\" , min_probability : float = 0.5 , target_db_id : Optional [ str ] = None , ) -> AlignmentResult : \"\"\"Calculate the alignment result for structural alignment using FoldSeek. Args: structure_file: Path to input protein structure file (PDB/mmCIF). foldseek_db_path: Path to FoldSeek-specific database. foldseek_command: FoldSeek executable name/path. min_probability: Minimum alignment probability threshold. target_db_id: If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult: Result containing alignment details and rotation matrix. Raises: AlignmentError: General alignment failures NoSignificantAlignmentError: No alignment meets probability threshold \"\"\" aligner = FoldseekAligner ( foldseek_executable = foldseek_command , database_path = foldseek_db_path ) alignment_result = aligner . align_structure ( structure_path = structure_file , min_probability = min_probability , fixed_alignment_id = target_db_id , ) if alignment_result is None : raise NoSignificantAlignmentError ( f \"No alignment found above { min_probability } probability threshold\" ) return alignment_result get_aligned_rotation_database ( alignment , db , id_transform = _foldseek_id_to_db_id ) Combines alignment rotation with database rotation. Parameters: alignment ( AlignmentResult ) \u2013 Alignment result from align_structure_database db ( AlignmentDatabase ) \u2013 Initialized AlignmentDatabase instance id_transform ( Callable [[ str ], str ] , default: _foldseek_id_to_db_id ) \u2013 Function to transform FoldSeek IDs to database IDs Returns: tuple ( tuple [ TransformationMatrix , AlignmentDBEntry ] ) \u2013 A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError \u2013 If matched database entry is missing Source code in src/flatprot/alignment/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_aligned_rotation_database ( alignment : AlignmentResult , db : AlignmentDatabase , id_transform : Callable [[ str ], str ] = _foldseek_id_to_db_id , ) -> tuple [ TransformationMatrix , AlignmentDBEntry ]: \"\"\"Combines alignment rotation with database rotation. Args: alignment: Alignment result from align_structure_database db: Initialized AlignmentDatabase instance id_transform: Function to transform FoldSeek IDs to database IDs Returns: tuple: A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError: If matched database entry is missing \"\"\" with db : db_id = id_transform ( alignment . db_id ) if not db . contains_entry_id ( db_id ): raise DatabaseEntryNotFoundError ( f \"Database entry { alignment . db_id } not found\" ) db_entry = db . get_by_entry_id ( db_id ) alignment_transform : TransformationMatrix = alignment . rotation_matrix db_transform : TransformationMatrix = db_entry . rotation_matrix # Combine the transformations: apply query_to_target_transform first, then db_transform. # T_final = T_db \u2218 T_inv_align # Since T2.before(T1) applies T1 then T2, we use: final_transform = db_transform . before ( alignment_transform ) return final_transform , db_entry options: members: - align_structure_database - get_aligned_rotation_database show_root_heading: true show_root_toc_entry: false Foldseek Interaction Classes and functions related to running Foldseek and parsing its results. AlignmentResult Bases: NamedTuple Results from a structural family alignment. Source code in src/flatprot/alignment/foldseek.py 15 16 17 18 19 20 21 22 class AlignmentResult ( NamedTuple ): \"\"\"Results from a structural family alignment.\"\"\" db_id : str probability : float aligned_region : np . ndarray alignment_scores : np . ndarray rotation_matrix : TransformationMatrix FoldseekAligner Handles structural family alignments using FoldSeek. Source code in src/flatprot/alignment/foldseek.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class FoldseekAligner : \"\"\"Handles structural family alignments using FoldSeek.\"\"\" def __init__ ( self , foldseek_executable : str , database_path : Path , ): self . foldseek_executable = foldseek_executable self . database_path = database_path def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results def _run_foldseek_batch_search ( self , structures_dir : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek batch search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structures_dir ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) def _run_foldseek_search ( self , structure_path : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structure_path ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) align_structure ( structure_path , min_probability = 0.5 , fixed_alignment_id = None , tmp_dir = None ) Aligns structure to family database and returns best match. Source code in src/flatprot/alignment/foldseek.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) align_structures_batch ( structure_paths , min_probability = 0.5 , fixed_alignment_id = None , tmp_dir = None ) Batch align multiple structures to family database for better performance. Parameters: structure_paths ( List [ Path ] ) \u2013 List of structure file paths to align min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold fixed_alignment_id ( Optional [ str ] , default: None ) \u2013 Optional fixed family ID for all alignments tmp_dir ( Optional [ Path ] , default: None ) \u2013 Optional temporary directory path Returns: Dict [ Path , Optional [ AlignmentResult ]] \u2013 Dictionary mapping structure paths to their alignment results Source code in src/flatprot/alignment/foldseek.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results options: show_root_heading: true show_root_toc_entry: false Alignment Database Class for interacting with the HDF5 alignment database containing pre-calculated matrices and the associated data entry structure. AlignmentDBEntry dataclass Stores alignment data with its rotation matrix. Source code in src/flatprot/alignment/db.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @dataclass class AlignmentDBEntry : \"\"\"Stores alignment data with its rotation matrix.\"\"\" rotation_matrix : TransformationMatrix entry_id : str structure_name : str metadata : Optional [ Dict [ str , float | str ]] = None def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , AlignmentDBEntry ): return False return ( np . allclose ( self . rotation_matrix . to_array (), other . rotation_matrix . to_array () ) and self . entry_id == other . entry_id and self . structure_name == other . structure_name ) AlignmentDatabase Handles alignment database using HDF5 storage with memory-mapped arrays. Source code in src/flatprot/alignment/db.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AlignmentDatabase : \"\"\"Handles alignment database using HDF5 storage with memory-mapped arrays.\"\"\" def __init__ ( self , path : Path ): self . path = path self . _file : Optional [ h5py . File ] = None self . _structure_name_index : dict [ str , str ] = {} # structure_name -> entry_id def __enter__ ( self ): self . open () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None def _load_index ( self ) -> None : \"\"\"Loads structure name index from HDF5 file.\"\"\" if \"index\" not in self . _file : return names = self . _file [ \"index/structure_names\" ][:] ids = self . _file [ \"index/entry_ids\" ][:] self . _structure_name_index = dict ( zip ( names , ids )) def _save_index ( self ) -> None : \"\"\"Saves structure name index to HDF5 file.\"\"\" if \"index\" in self . _file : del self . _file [ \"index\" ] index = self . _file . create_group ( \"index\" ) names = list ( self . _structure_name_index . keys ()) ids = list ( self . _structure_name_index . values ()) index . create_dataset ( \"structure_names\" , data = names ) index . create_dataset ( \"entry_ids\" , data = ids ) def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index () add_entry ( entry ) Adds a new entry to the database. Source code in src/flatprot/alignment/db.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () close () Closes the database file. Source code in src/flatprot/alignment/db.py 55 56 57 58 59 def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None contains_entry_id ( entry_id ) Checks if an entry_id exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 81 82 83 84 85 def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file contains_structure_name ( structure_name ) Checks if a structure_name exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 87 88 89 def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index get_by_entry_id ( entry_id , default = None ) Returns alignment entry for given entry_id or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) get_by_structure_name ( structure_name , default = None ) Returns alignment entry for given structure_name or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 109 110 111 112 113 114 115 116 def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) open () Opens the database file in read/write mode. Source code in src/flatprot/alignment/db.py 50 51 52 53 def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () update ( entry ) Updates an existing entry in the database. Source code in src/flatprot/alignment/db.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index () options: show_root_heading: true show_root_toc_entry: false Alignment Utilities Utility functions used within the alignment module. align_structure_database ( structure_file , foldseek_db_path , foldseek_command = 'foldseek' , min_probability = 0.5 , target_db_id = None ) Calculate the alignment result for structural alignment using FoldSeek. Parameters: structure_file ( Path ) \u2013 Path to input protein structure file (PDB/mmCIF). foldseek_db_path ( Path ) \u2013 Path to FoldSeek-specific database. foldseek_command ( str , default: 'foldseek' ) \u2013 FoldSeek executable name/path. min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold. target_db_id ( Optional [ str ] , default: None ) \u2013 If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult ( AlignmentResult ) \u2013 Result containing alignment details and rotation matrix. Raises: AlignmentError \u2013 General alignment failures NoSignificantAlignmentError \u2013 No alignment meets probability threshold Source code in src/flatprot/alignment/utils.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def align_structure_database ( structure_file : Path , foldseek_db_path : Path , foldseek_command : str = \"foldseek\" , min_probability : float = 0.5 , target_db_id : Optional [ str ] = None , ) -> AlignmentResult : \"\"\"Calculate the alignment result for structural alignment using FoldSeek. Args: structure_file: Path to input protein structure file (PDB/mmCIF). foldseek_db_path: Path to FoldSeek-specific database. foldseek_command: FoldSeek executable name/path. min_probability: Minimum alignment probability threshold. target_db_id: If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult: Result containing alignment details and rotation matrix. Raises: AlignmentError: General alignment failures NoSignificantAlignmentError: No alignment meets probability threshold \"\"\" aligner = FoldseekAligner ( foldseek_executable = foldseek_command , database_path = foldseek_db_path ) alignment_result = aligner . align_structure ( structure_path = structure_file , min_probability = min_probability , fixed_alignment_id = target_db_id , ) if alignment_result is None : raise NoSignificantAlignmentError ( f \"No alignment found above { min_probability } probability threshold\" ) return alignment_result get_aligned_rotation_database ( alignment , db , id_transform = _foldseek_id_to_db_id ) Combines alignment rotation with database rotation. Parameters: alignment ( AlignmentResult ) \u2013 Alignment result from align_structure_database db ( AlignmentDatabase ) \u2013 Initialized AlignmentDatabase instance id_transform ( Callable [[ str ], str ] , default: _foldseek_id_to_db_id ) \u2013 Function to transform FoldSeek IDs to database IDs Returns: tuple ( tuple [ TransformationMatrix , AlignmentDBEntry ] ) \u2013 A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError \u2013 If matched database entry is missing Source code in src/flatprot/alignment/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_aligned_rotation_database ( alignment : AlignmentResult , db : AlignmentDatabase , id_transform : Callable [[ str ], str ] = _foldseek_id_to_db_id , ) -> tuple [ TransformationMatrix , AlignmentDBEntry ]: \"\"\"Combines alignment rotation with database rotation. Args: alignment: Alignment result from align_structure_database db: Initialized AlignmentDatabase instance id_transform: Function to transform FoldSeek IDs to database IDs Returns: tuple: A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError: If matched database entry is missing \"\"\" with db : db_id = id_transform ( alignment . db_id ) if not db . contains_entry_id ( db_id ): raise DatabaseEntryNotFoundError ( f \"Database entry { alignment . db_id } not found\" ) db_entry = db . get_by_entry_id ( db_id ) alignment_transform : TransformationMatrix = alignment . rotation_matrix db_transform : TransformationMatrix = db_entry . rotation_matrix # Combine the transformations: apply query_to_target_transform first, then db_transform. # T_final = T_db \u2218 T_inv_align # Since T2.before(T1) applies T1 then T2, we use: final_transform = db_transform . before ( alignment_transform ) return final_transform , db_entry options: show_root_heading: true show_root_toc_entry: false Alignment Errors Exceptions specific to the alignment process. AlignmentError Bases: FlatProtError Base class for alignment-related errors. Source code in src/flatprot/alignment/errors.py 8 9 10 11 class AlignmentError ( FlatProtError ): \"\"\"Base class for alignment-related errors.\"\"\" pass DatabaseEntryNotFoundError Bases: AlignmentError Raised when a database entry is not found. Source code in src/flatprot/alignment/errors.py 20 21 22 23 class DatabaseEntryNotFoundError ( AlignmentError ): \"\"\"Raised when a database entry is not found.\"\"\" pass NoSignificantAlignmentError Bases: AlignmentError Raised when no significant alignment is found. Source code in src/flatprot/alignment/errors.py 14 15 16 17 class NoSignificantAlignmentError ( AlignmentError ): \"\"\"Raised when no significant alignment is found.\"\"\" pass options: show_root_heading: true show_root_toc_entry: false","title":"DatabaseAlignment"},{"location":"api/alignment/#alignment-api","text":"This section documents the components responsible for structural alignment in FlatProt, primarily focused on finding the best match in a reference database and retrieving the associated transformation matrix.","title":"Alignment API"},{"location":"api/alignment/#alignment-concept","text":"The alignment process in FlatProt serves to orient an input protein structure according to a standardized reference frame, typically based on its structural superfamily. Structural Search: It uses an external tool, Foldseek, to search a pre-compiled database of reference structures (e.g., CATH domains) for the best structural match to the input protein. Result Filtering: The Foldseek results are filtered based on metrics like alignment probability ( --min-probability ) or by specifying a direct target ID ( --target-db-id ). Matrix Retrieval: Once a suitable match is identified (represented by a target_id from Foldseek), FlatProt queries its internal HDF5 database ( AlignmentDatabase ) using this target_id . This database stores pre-calculated 4x4 transformation matrices that map the reference structure (the target) to a standardized orientation for its superfamily. Output: The primary output is the retrieved transformation matrix ( TransformationMatrix ), which can then be used by the project command to render the input structure in the standardized orientation. Alignment metadata (scores, matched IDs) can also be saved.","title":"Alignment Concept"},{"location":"api/alignment/#top-level-alignment-functions","text":"These functions provide the main entry points for performing alignment using a database.","title":"Top-Level Alignment Functions"},{"location":"api/alignment/#flatprot.alignment.AlignmentDBEntry","text":"Stores alignment data with its rotation matrix. Source code in src/flatprot/alignment/db.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @dataclass class AlignmentDBEntry : \"\"\"Stores alignment data with its rotation matrix.\"\"\" rotation_matrix : TransformationMatrix entry_id : str structure_name : str metadata : Optional [ Dict [ str , float | str ]] = None def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , AlignmentDBEntry ): return False return ( np . allclose ( self . rotation_matrix . to_array (), other . rotation_matrix . to_array () ) and self . entry_id == other . entry_id and self . structure_name == other . structure_name )","title":"AlignmentDBEntry"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase","text":"Handles alignment database using HDF5 storage with memory-mapped arrays. Source code in src/flatprot/alignment/db.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AlignmentDatabase : \"\"\"Handles alignment database using HDF5 storage with memory-mapped arrays.\"\"\" def __init__ ( self , path : Path ): self . path = path self . _file : Optional [ h5py . File ] = None self . _structure_name_index : dict [ str , str ] = {} # structure_name -> entry_id def __enter__ ( self ): self . open () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None def _load_index ( self ) -> None : \"\"\"Loads structure name index from HDF5 file.\"\"\" if \"index\" not in self . _file : return names = self . _file [ \"index/structure_names\" ][:] ids = self . _file [ \"index/entry_ids\" ][:] self . _structure_name_index = dict ( zip ( names , ids )) def _save_index ( self ) -> None : \"\"\"Saves structure name index to HDF5 file.\"\"\" if \"index\" in self . _file : del self . _file [ \"index\" ] index = self . _file . create_group ( \"index\" ) names = list ( self . _structure_name_index . keys ()) ids = list ( self . _structure_name_index . values ()) index . create_dataset ( \"structure_names\" , data = names ) index . create_dataset ( \"entry_ids\" , data = ids ) def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index ()","title":"AlignmentDatabase"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.add_entry","text":"Adds a new entry to the database. Source code in src/flatprot/alignment/db.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index ()","title":"add_entry"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.close","text":"Closes the database file. Source code in src/flatprot/alignment/db.py 55 56 57 58 59 def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None","title":"close"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.contains_entry_id","text":"Checks if an entry_id exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 81 82 83 84 85 def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file","title":"contains_entry_id"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.contains_structure_name","text":"Checks if a structure_name exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 87 88 89 def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index","title":"contains_structure_name"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.get_by_entry_id","text":"Returns alignment entry for given entry_id or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , )","title":"get_by_entry_id"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.get_by_structure_name","text":"Returns alignment entry for given structure_name or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 109 110 111 112 113 114 115 116 def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id )","title":"get_by_structure_name"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.open","text":"Opens the database file in read/write mode. Source code in src/flatprot/alignment/db.py 50 51 52 53 def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index ()","title":"open"},{"location":"api/alignment/#flatprot.alignment.AlignmentDatabase.update","text":"Updates an existing entry in the database. Source code in src/flatprot/alignment/db.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index ()","title":"update"},{"location":"api/alignment/#flatprot.alignment.AlignmentError","text":"Bases: FlatProtError Base class for alignment-related errors. Source code in src/flatprot/alignment/errors.py 8 9 10 11 class AlignmentError ( FlatProtError ): \"\"\"Base class for alignment-related errors.\"\"\" pass","title":"AlignmentError"},{"location":"api/alignment/#flatprot.alignment.AlignmentResult","text":"Bases: NamedTuple Results from a structural family alignment. Source code in src/flatprot/alignment/foldseek.py 15 16 17 18 19 20 21 22 class AlignmentResult ( NamedTuple ): \"\"\"Results from a structural family alignment.\"\"\" db_id : str probability : float aligned_region : np . ndarray alignment_scores : np . ndarray rotation_matrix : TransformationMatrix","title":"AlignmentResult"},{"location":"api/alignment/#flatprot.alignment.DatabaseEntryNotFoundError","text":"Bases: AlignmentError Raised when a database entry is not found. Source code in src/flatprot/alignment/errors.py 20 21 22 23 class DatabaseEntryNotFoundError ( AlignmentError ): \"\"\"Raised when a database entry is not found.\"\"\" pass","title":"DatabaseEntryNotFoundError"},{"location":"api/alignment/#flatprot.alignment.FoldseekAligner","text":"Handles structural family alignments using FoldSeek. Source code in src/flatprot/alignment/foldseek.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class FoldseekAligner : \"\"\"Handles structural family alignments using FoldSeek.\"\"\" def __init__ ( self , foldseek_executable : str , database_path : Path , ): self . foldseek_executable = foldseek_executable self . database_path = database_path def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results def _run_foldseek_batch_search ( self , structures_dir : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek batch search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structures_dir ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) def _run_foldseek_search ( self , structure_path : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structure_path ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True )","title":"FoldseekAligner"},{"location":"api/alignment/#flatprot.alignment.FoldseekAligner.align_structure","text":"Aligns structure to family database and returns best match. Source code in src/flatprot/alignment/foldseek.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , )","title":"align_structure"},{"location":"api/alignment/#flatprot.alignment.FoldseekAligner.align_structures_batch","text":"Batch align multiple structures to family database for better performance. Parameters: structure_paths ( List [ Path ] ) \u2013 List of structure file paths to align min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold fixed_alignment_id ( Optional [ str ] , default: None ) \u2013 Optional fixed family ID for all alignments tmp_dir ( Optional [ Path ] , default: None ) \u2013 Optional temporary directory path Returns: Dict [ Path , Optional [ AlignmentResult ]] \u2013 Dictionary mapping structure paths to their alignment results Source code in src/flatprot/alignment/foldseek.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results","title":"align_structures_batch"},{"location":"api/alignment/#flatprot.alignment.NoSignificantAlignmentError","text":"Bases: AlignmentError Raised when no significant alignment is found. Source code in src/flatprot/alignment/errors.py 14 15 16 17 class NoSignificantAlignmentError ( AlignmentError ): \"\"\"Raised when no significant alignment is found.\"\"\" pass","title":"NoSignificantAlignmentError"},{"location":"api/alignment/#flatprot.alignment.align_structure_database","text":"Calculate the alignment result for structural alignment using FoldSeek. Parameters: structure_file ( Path ) \u2013 Path to input protein structure file (PDB/mmCIF). foldseek_db_path ( Path ) \u2013 Path to FoldSeek-specific database. foldseek_command ( str , default: 'foldseek' ) \u2013 FoldSeek executable name/path. min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold. target_db_id ( Optional [ str ] , default: None ) \u2013 If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult ( AlignmentResult ) \u2013 Result containing alignment details and rotation matrix. Raises: AlignmentError \u2013 General alignment failures NoSignificantAlignmentError \u2013 No alignment meets probability threshold Source code in src/flatprot/alignment/utils.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def align_structure_database ( structure_file : Path , foldseek_db_path : Path , foldseek_command : str = \"foldseek\" , min_probability : float = 0.5 , target_db_id : Optional [ str ] = None , ) -> AlignmentResult : \"\"\"Calculate the alignment result for structural alignment using FoldSeek. Args: structure_file: Path to input protein structure file (PDB/mmCIF). foldseek_db_path: Path to FoldSeek-specific database. foldseek_command: FoldSeek executable name/path. min_probability: Minimum alignment probability threshold. target_db_id: If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult: Result containing alignment details and rotation matrix. Raises: AlignmentError: General alignment failures NoSignificantAlignmentError: No alignment meets probability threshold \"\"\" aligner = FoldseekAligner ( foldseek_executable = foldseek_command , database_path = foldseek_db_path ) alignment_result = aligner . align_structure ( structure_path = structure_file , min_probability = min_probability , fixed_alignment_id = target_db_id , ) if alignment_result is None : raise NoSignificantAlignmentError ( f \"No alignment found above { min_probability } probability threshold\" ) return alignment_result","title":"align_structure_database"},{"location":"api/alignment/#flatprot.alignment.get_aligned_rotation_database","text":"Combines alignment rotation with database rotation. Parameters: alignment ( AlignmentResult ) \u2013 Alignment result from align_structure_database db ( AlignmentDatabase ) \u2013 Initialized AlignmentDatabase instance id_transform ( Callable [[ str ], str ] , default: _foldseek_id_to_db_id ) \u2013 Function to transform FoldSeek IDs to database IDs Returns: tuple ( tuple [ TransformationMatrix , AlignmentDBEntry ] ) \u2013 A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError \u2013 If matched database entry is missing Source code in src/flatprot/alignment/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_aligned_rotation_database ( alignment : AlignmentResult , db : AlignmentDatabase , id_transform : Callable [[ str ], str ] = _foldseek_id_to_db_id , ) -> tuple [ TransformationMatrix , AlignmentDBEntry ]: \"\"\"Combines alignment rotation with database rotation. Args: alignment: Alignment result from align_structure_database db: Initialized AlignmentDatabase instance id_transform: Function to transform FoldSeek IDs to database IDs Returns: tuple: A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError: If matched database entry is missing \"\"\" with db : db_id = id_transform ( alignment . db_id ) if not db . contains_entry_id ( db_id ): raise DatabaseEntryNotFoundError ( f \"Database entry { alignment . db_id } not found\" ) db_entry = db . get_by_entry_id ( db_id ) alignment_transform : TransformationMatrix = alignment . rotation_matrix db_transform : TransformationMatrix = db_entry . rotation_matrix # Combine the transformations: apply query_to_target_transform first, then db_transform. # T_final = T_db \u2218 T_inv_align # Since T2.before(T1) applies T1 then T2, we use: final_transform = db_transform . before ( alignment_transform ) return final_transform , db_entry options: members: - align_structure_database - get_aligned_rotation_database show_root_heading: true show_root_toc_entry: false","title":"get_aligned_rotation_database"},{"location":"api/alignment/#foldseek-interaction","text":"Classes and functions related to running Foldseek and parsing its results.","title":"Foldseek Interaction"},{"location":"api/alignment/#flatprot.alignment.foldseek.AlignmentResult","text":"Bases: NamedTuple Results from a structural family alignment. Source code in src/flatprot/alignment/foldseek.py 15 16 17 18 19 20 21 22 class AlignmentResult ( NamedTuple ): \"\"\"Results from a structural family alignment.\"\"\" db_id : str probability : float aligned_region : np . ndarray alignment_scores : np . ndarray rotation_matrix : TransformationMatrix","title":"AlignmentResult"},{"location":"api/alignment/#flatprot.alignment.foldseek.FoldseekAligner","text":"Handles structural family alignments using FoldSeek. Source code in src/flatprot/alignment/foldseek.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class FoldseekAligner : \"\"\"Handles structural family alignments using FoldSeek.\"\"\" def __init__ ( self , foldseek_executable : str , database_path : Path , ): self . foldseek_executable = foldseek_executable self . database_path = database_path def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results def _run_foldseek_batch_search ( self , structures_dir : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek batch search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structures_dir ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True ) def _run_foldseek_search ( self , structure_path : Path , output_file : Path , tmp_dir : Path ) -> None : \"\"\"Runs FoldSeek search against family database.\"\"\" cmd = [ self . foldseek_executable , \"easy-search\" , str ( structure_path ), str ( self . database_path ), str ( output_file ), str ( tmp_dir ), \"--format-output\" , \"query,target,qstart,qend,tstart,tend,tseq,prob,alntmscore,u,t,lddtfull\" , ] subprocess . run ( cmd , check = True , capture_output = True , text = True )","title":"FoldseekAligner"},{"location":"api/alignment/#flatprot.alignment.foldseek.FoldseekAligner.align_structure","text":"Aligns structure to family database and returns best match. Source code in src/flatprot/alignment/foldseek.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def align_structure ( self , structure_path : Path , min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Optional [ AlignmentResult ]: \"\"\"Aligns structure to family database and returns best match.\"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Run FoldSeek search result_file = tmp_dir_path / \"foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_search ( structure_path , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek result file not found\" ) # Parse results results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) if len ( results ) == 0 : return None # Get best match (or fixed family if specified) if fixed_alignment_id : match = results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) else : match = results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : return None if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Manually calculate the inverse of the alignment transformation # Inverse rotation is the transpose of the rotation matrix R_align_inv = target_to_query_matrix . T # Inverse translation is -R_inv @ t t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) return AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array (( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ]))), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , )","title":"align_structure"},{"location":"api/alignment/#flatprot.alignment.foldseek.FoldseekAligner.align_structures_batch","text":"Batch align multiple structures to family database for better performance. Parameters: structure_paths ( List [ Path ] ) \u2013 List of structure file paths to align min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold fixed_alignment_id ( Optional [ str ] , default: None ) \u2013 Optional fixed family ID for all alignments tmp_dir ( Optional [ Path ] , default: None ) \u2013 Optional temporary directory path Returns: Dict [ Path , Optional [ AlignmentResult ]] \u2013 Dictionary mapping structure paths to their alignment results Source code in src/flatprot/alignment/foldseek.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def align_structures_batch ( self , structure_paths : List [ Path ], min_probability : float = 0.5 , fixed_alignment_id : Optional [ str ] = None , tmp_dir : Optional [ Path ] = None , ) -> Dict [ Path , Optional [ AlignmentResult ]]: \"\"\"Batch align multiple structures to family database for better performance. Args: structure_paths: List of structure file paths to align min_probability: Minimum alignment probability threshold fixed_alignment_id: Optional fixed family ID for all alignments tmp_dir: Optional temporary directory path Returns: Dictionary mapping structure paths to their alignment results \"\"\" if tmp_dir is None : tmp_dir = tempfile . TemporaryDirectory ( ignore_cleanup_errors = True , prefix = \"foldseek_batch_\" ) tmp_dir_path = Path ( tmp_dir . name ) else : tmp_dir_path = tmp_dir # Create input directory with all structures structures_dir = tmp_dir_path / \"batch_structures\" structures_dir . mkdir ( parents = True , exist_ok = True ) # Copy all structures to batch directory structure_mapping = {} for i , structure_path in enumerate ( structure_paths ): # Use index to avoid naming conflicts batch_filename = ( f \"structure_ { i } _ { structure_path . stem }{ structure_path . suffix } \" ) batch_file = structures_dir / batch_filename batch_file . write_bytes ( structure_path . read_bytes ()) structure_mapping [ batch_filename ] = structure_path # Run batch foldseek search result_file = tmp_dir_path / \"batch_foldseek_result.tsv\" foldseek_tmp_dir = tmp_dir_path / \"foldseek_tmp\" self . _run_foldseek_batch_search ( structures_dir , result_file , foldseek_tmp_dir ) if not result_file . exists (): raise RuntimeError ( \"FoldSeek batch result file not found\" ) # Parse batch results try : results = pl . read_csv ( result_file , separator = \" \\t \" , has_header = False , new_columns = [ \"query\" , \"target\" , \"qstart\" , \"qend\" , \"tstart\" , \"tend\" , \"tseq\" , \"prob\" , \"alntmscore\" , \"u\" , \"t\" , \"lddtfull\" , ], schema_overrides = { \"query\" : pl . Utf8 , \"target\" : pl . Utf8 , }, ) except Exception : # Return empty results if parsing fails return { path : None for path in structure_paths } # Group results by query and process each structure alignment_results = {} for structure_path in structure_paths : # Find the batch filename for this structure batch_filename = None for batch_name , orig_path in structure_mapping . items (): if orig_path == structure_path : batch_filename = batch_name break if batch_filename is None : alignment_results [ structure_path ] = None continue # Filter results for this specific query query_results = results . filter ( pl . col ( \"query\" ) . str . contains ( Path ( batch_filename ) . stem ) ) if len ( query_results ) == 0 : alignment_results [ structure_path ] = None continue # Get best match (or fixed family if specified) if fixed_alignment_id : match = query_results . filter ( pl . col ( \"target\" ) == fixed_alignment_id ) if len ( match ) == 0 : alignment_results [ structure_path ] = None continue else : match = query_results . sort ( \"prob\" , descending = True ) if match [ 0 , \"prob\" ] < min_probability : alignment_results [ structure_path ] = None continue # Create alignment result target_to_query_matrix = _parse_foldseek_vector ( match [ 0 , \"u\" ]) . reshape ( 3 , 3 ) target_to_query_translation = _parse_foldseek_vector ( match [ 0 , \"t\" ]) # Calculate inverse transformation R_align_inv = target_to_query_matrix . T t_align_inv = - R_align_inv @ target_to_query_translation query_to_target_transform = TransformationMatrix ( rotation = R_align_inv , translation = t_align_inv ) alignment_results [ structure_path ] = AlignmentResult ( db_id = match [ 0 , \"target\" ], probability = float ( match [ 0 , \"prob\" ]), aligned_region = np . array ( ( int ( match [ 0 , \"qstart\" ]), int ( match [ 0 , \"qend\" ])) ), alignment_scores = _parse_foldseek_vector ( match [ 0 , \"lddtfull\" ]), rotation_matrix = query_to_target_transform , ) if isinstance ( tmp_dir , tempfile . TemporaryDirectory ): tmp_dir . cleanup () return alignment_results options: show_root_heading: true show_root_toc_entry: false","title":"align_structures_batch"},{"location":"api/alignment/#alignment-database","text":"Class for interacting with the HDF5 alignment database containing pre-calculated matrices and the associated data entry structure.","title":"Alignment Database"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDBEntry","text":"Stores alignment data with its rotation matrix. Source code in src/flatprot/alignment/db.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @dataclass class AlignmentDBEntry : \"\"\"Stores alignment data with its rotation matrix.\"\"\" rotation_matrix : TransformationMatrix entry_id : str structure_name : str metadata : Optional [ Dict [ str , float | str ]] = None def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , AlignmentDBEntry ): return False return ( np . allclose ( self . rotation_matrix . to_array (), other . rotation_matrix . to_array () ) and self . entry_id == other . entry_id and self . structure_name == other . structure_name )","title":"AlignmentDBEntry"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase","text":"Handles alignment database using HDF5 storage with memory-mapped arrays. Source code in src/flatprot/alignment/db.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AlignmentDatabase : \"\"\"Handles alignment database using HDF5 storage with memory-mapped arrays.\"\"\" def __init__ ( self , path : Path ): self . path = path self . _file : Optional [ h5py . File ] = None self . _structure_name_index : dict [ str , str ] = {} # structure_name -> entry_id def __enter__ ( self ): self . open () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . close () def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index () def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None def _load_index ( self ) -> None : \"\"\"Loads structure name index from HDF5 file.\"\"\" if \"index\" not in self . _file : return names = self . _file [ \"index/structure_names\" ][:] ids = self . _file [ \"index/entry_ids\" ][:] self . _structure_name_index = dict ( zip ( names , ids )) def _save_index ( self ) -> None : \"\"\"Saves structure name index to HDF5 file.\"\"\" if \"index\" in self . _file : del self . _file [ \"index\" ] index = self . _file . create_group ( \"index\" ) names = list ( self . _structure_name_index . keys ()) ids = list ( self . _structure_name_index . values ()) index . create_dataset ( \"structure_names\" , data = names ) index . create_dataset ( \"entry_ids\" , data = ids ) def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , ) def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id ) def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index () def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index ()","title":"AlignmentDatabase"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.add_entry","text":"Adds a new entry to the database. Source code in src/flatprot/alignment/db.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_entry ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Adds a new entry to the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id in self . _file : raise ValueError ( f \"Entry ID { entry . entry_id } already exists\" ) if entry . structure_name in self . _structure_name_index : raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Create entry group and save data entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Update index self . _structure_name_index [ entry . structure_name ] = entry . entry_id self . _save_index ()","title":"add_entry"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.close","text":"Closes the database file. Source code in src/flatprot/alignment/db.py 55 56 57 58 59 def close ( self ) -> None : \"\"\"Closes the database file.\"\"\" if self . _file is not None : self . _file . close () self . _file = None","title":"close"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.contains_entry_id","text":"Checks if an entry_id exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 81 82 83 84 85 def contains_entry_id ( self , entry_id : str ) -> bool : \"\"\"Checks if an entry_id exists in the database. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) return entry_id in self . _file","title":"contains_entry_id"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.contains_structure_name","text":"Checks if a structure_name exists in the database. O(1) lookup. Source code in src/flatprot/alignment/db.py 87 88 89 def contains_structure_name ( self , structure_name : str ) -> bool : \"\"\"Checks if a structure_name exists in the database. O(1) lookup.\"\"\" return structure_name in self . _structure_name_index","title":"contains_structure_name"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.get_by_entry_id","text":"Returns alignment entry for given entry_id or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_by_entry_id ( self , entry_id : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given entry_id or default if not found. O(1) lookup.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry_id not in self . _file : return default entry_group = self . _file [ entry_id ] metadata = { k : v for k , v in entry_group . attrs . items () if k != \"structure_name\" } return AlignmentDBEntry ( rotation_matrix = TransformationMatrix . from_array ( entry_group [ \"rotation\" ][:]), entry_id = entry_id , structure_name = entry_group . attrs [ \"structure_name\" ], metadata = metadata if metadata else None , )","title":"get_by_entry_id"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.get_by_structure_name","text":"Returns alignment entry for given structure_name or default if not found. O(1) lookup. Source code in src/flatprot/alignment/db.py 109 110 111 112 113 114 115 116 def get_by_structure_name ( self , structure_name : str , default : Optional [ AlignmentDBEntry ] = None ) -> Optional [ AlignmentDBEntry ]: \"\"\"Returns alignment entry for given structure_name or default if not found. O(1) lookup.\"\"\" if structure_name not in self . _structure_name_index : return default entry_id = self . _structure_name_index [ structure_name ] return self . get_by_entry_id ( entry_id )","title":"get_by_structure_name"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.open","text":"Opens the database file in read/write mode. Source code in src/flatprot/alignment/db.py 50 51 52 53 def open ( self ) -> None : \"\"\"Opens the database file in read/write mode.\"\"\" self . _file = h5py . File ( self . path , \"a\" ) self . _load_index ()","title":"open"},{"location":"api/alignment/#flatprot.alignment.db.AlignmentDatabase.update","text":"Updates an existing entry in the database. Source code in src/flatprot/alignment/db.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def update ( self , entry : AlignmentDBEntry ) -> None : \"\"\"Updates an existing entry in the database.\"\"\" if self . _file is None : raise RuntimeError ( \"Database not opened\" ) if entry . entry_id not in self . _file : raise KeyError ( f \"Entry ID { entry . entry_id } not found in database\" ) old_entry = self . get_by_entry_id ( entry . entry_id ) # Check structure name conflicts if ( entry . structure_name != old_entry . structure_name and entry . structure_name in self . _structure_name_index ): raise ValueError ( f \"Structure name { entry . structure_name } already exists\" ) # Update index if structure name changed if entry . structure_name != old_entry . structure_name : del self . _structure_name_index [ old_entry . structure_name ] self . _structure_name_index [ entry . structure_name ] = entry . entry_id # Update entry data del self . _file [ entry . entry_id ] entry_group = self . _file . create_group ( entry . entry_id ) entry_group . create_dataset ( \"rotation\" , data = entry . rotation_matrix . to_array ()) entry_group . attrs [ \"structure_name\" ] = entry . structure_name # Store metadata if available if entry . metadata : for key , value in entry . metadata . items (): entry_group . attrs [ key ] = value # Save index self . _save_index () options: show_root_heading: true show_root_toc_entry: false","title":"update"},{"location":"api/alignment/#alignment-utilities","text":"Utility functions used within the alignment module.","title":"Alignment Utilities"},{"location":"api/alignment/#flatprot.alignment.utils.align_structure_database","text":"Calculate the alignment result for structural alignment using FoldSeek. Parameters: structure_file ( Path ) \u2013 Path to input protein structure file (PDB/mmCIF). foldseek_db_path ( Path ) \u2013 Path to FoldSeek-specific database. foldseek_command ( str , default: 'foldseek' ) \u2013 FoldSeek executable name/path. min_probability ( float , default: 0.5 ) \u2013 Minimum alignment probability threshold. target_db_id ( Optional [ str ] , default: None ) \u2013 If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult ( AlignmentResult ) \u2013 Result containing alignment details and rotation matrix. Raises: AlignmentError \u2013 General alignment failures NoSignificantAlignmentError \u2013 No alignment meets probability threshold Source code in src/flatprot/alignment/utils.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def align_structure_database ( structure_file : Path , foldseek_db_path : Path , foldseek_command : str = \"foldseek\" , min_probability : float = 0.5 , target_db_id : Optional [ str ] = None , ) -> AlignmentResult : \"\"\"Calculate the alignment result for structural alignment using FoldSeek. Args: structure_file: Path to input protein structure file (PDB/mmCIF). foldseek_db_path: Path to FoldSeek-specific database. foldseek_command: FoldSeek executable name/path. min_probability: Minimum alignment probability threshold. target_db_id: If provided, force alignment to this specific FoldSeek target ID. Returns: AlignmentResult: Result containing alignment details and rotation matrix. Raises: AlignmentError: General alignment failures NoSignificantAlignmentError: No alignment meets probability threshold \"\"\" aligner = FoldseekAligner ( foldseek_executable = foldseek_command , database_path = foldseek_db_path ) alignment_result = aligner . align_structure ( structure_path = structure_file , min_probability = min_probability , fixed_alignment_id = target_db_id , ) if alignment_result is None : raise NoSignificantAlignmentError ( f \"No alignment found above { min_probability } probability threshold\" ) return alignment_result","title":"align_structure_database"},{"location":"api/alignment/#flatprot.alignment.utils.get_aligned_rotation_database","text":"Combines alignment rotation with database rotation. Parameters: alignment ( AlignmentResult ) \u2013 Alignment result from align_structure_database db ( AlignmentDatabase ) \u2013 Initialized AlignmentDatabase instance id_transform ( Callable [[ str ], str ] , default: _foldseek_id_to_db_id ) \u2013 Function to transform FoldSeek IDs to database IDs Returns: tuple ( tuple [ TransformationMatrix , AlignmentDBEntry ] ) \u2013 A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError \u2013 If matched database entry is missing Source code in src/flatprot/alignment/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_aligned_rotation_database ( alignment : AlignmentResult , db : AlignmentDatabase , id_transform : Callable [[ str ], str ] = _foldseek_id_to_db_id , ) -> tuple [ TransformationMatrix , AlignmentDBEntry ]: \"\"\"Combines alignment rotation with database rotation. Args: alignment: Alignment result from align_structure_database db: Initialized AlignmentDatabase instance id_transform: Function to transform FoldSeek IDs to database IDs Returns: tuple: A tuple containing: - Combined transformation matrix - Database entry object for the matched alignment Raises: DatabaseEntryNotFoundError: If matched database entry is missing \"\"\" with db : db_id = id_transform ( alignment . db_id ) if not db . contains_entry_id ( db_id ): raise DatabaseEntryNotFoundError ( f \"Database entry { alignment . db_id } not found\" ) db_entry = db . get_by_entry_id ( db_id ) alignment_transform : TransformationMatrix = alignment . rotation_matrix db_transform : TransformationMatrix = db_entry . rotation_matrix # Combine the transformations: apply query_to_target_transform first, then db_transform. # T_final = T_db \u2218 T_inv_align # Since T2.before(T1) applies T1 then T2, we use: final_transform = db_transform . before ( alignment_transform ) return final_transform , db_entry options: show_root_heading: true show_root_toc_entry: false","title":"get_aligned_rotation_database"},{"location":"api/alignment/#alignment-errors","text":"Exceptions specific to the alignment process.","title":"Alignment Errors"},{"location":"api/alignment/#flatprot.alignment.errors.AlignmentError","text":"Bases: FlatProtError Base class for alignment-related errors. Source code in src/flatprot/alignment/errors.py 8 9 10 11 class AlignmentError ( FlatProtError ): \"\"\"Base class for alignment-related errors.\"\"\" pass","title":"AlignmentError"},{"location":"api/alignment/#flatprot.alignment.errors.DatabaseEntryNotFoundError","text":"Bases: AlignmentError Raised when a database entry is not found. Source code in src/flatprot/alignment/errors.py 20 21 22 23 class DatabaseEntryNotFoundError ( AlignmentError ): \"\"\"Raised when a database entry is not found.\"\"\" pass","title":"DatabaseEntryNotFoundError"},{"location":"api/alignment/#flatprot.alignment.errors.NoSignificantAlignmentError","text":"Bases: AlignmentError Raised when no significant alignment is found. Source code in src/flatprot/alignment/errors.py 14 15 16 17 class NoSignificantAlignmentError ( AlignmentError ): \"\"\"Raised when no significant alignment is found.\"\"\" pass options: show_root_heading: true show_root_toc_entry: false","title":"NoSignificantAlignmentError"},{"location":"api/core/","text":"Core API This section documents the core data structures and fundamental types used within FlatProt. Structure Representation Represents a complete protein structure composed of multiple chains. Source code in src/flatprot/core/structure.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class Structure : \"\"\"Represents a complete protein structure composed of multiple chains.\"\"\" def __init__ ( self , chains : list [ Chain ], id : Optional [ str ] = None ): \"\"\"Initializes a Structure object. Args: chains: A list of Chain objects representing the chains in the structure. id: An optional identifier for the structure (e.g., PDB ID or filename stem). \"\"\" self . __chains = { chain . id : chain for chain in chains } self . id = id or \"unknown_structure\" # Assign ID or a default # Pre-calculate total coordinates for validation if needed self . _total_coordinates = sum ( len ( chain . coordinates ) if chain . coordinates is not None else 0 for chain in self . values () ) def __getitem__ ( self , chain_id : str ) -> Chain : \"\"\"Get a chain by its ID.\"\"\" return self . __chains [ chain_id ] def __contains__ ( self , chain_id : str | ResidueCoordinate ) -> bool : \"\"\"Check if a chain ID or ResidueCoordinate exists in the structure.\"\"\" if isinstance ( chain_id , str ): return chain_id in self . __chains elif isinstance ( chain_id , ResidueCoordinate ): return ( chain_id . chain_id in self . __chains and chain_id . residue_index in self . __chains [ chain_id . chain_id ] ) return False def __iter__ ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Iterate over chain IDs and Chain objects.\"\"\" return iter ( self . __chains . items ()) def items ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Return an iterator over chain ID / Chain pairs.\"\"\" return self . __chains . items () def values ( self ) -> Iterator [ Chain ]: \"\"\"Return an iterator over Chain objects.\"\"\" return self . __chains . values () def __len__ ( self ) -> int : \"\"\"Return the number of chains in the structure.\"\"\" return len ( self . __chains ) @property def residues ( self ) -> list [ ResidueType ]: \"\"\"Get a flattened list of all residues across all chains.\"\"\" all_residues = [] for chain in self . __chains . values (): all_residues . extend ( chain . residues ) return all_residues @property def coordinates ( self ) -> Optional [ np . ndarray ]: \"\"\"Get a concatenated array of all coordinates across all chains, or None if empty.\"\"\" all_coords = [ chain . coordinates for chain in self . __chains . values () if chain . coordinates is not None and chain . coordinates . size > 0 ] if not all_coords : return None return np . vstack ( all_coords ) def __str__ ( self ) -> str : return f \"Structure(ID: { self . id } , Chains: { list ( self . __chains . keys ()) } )\" def apply_vectorized_transformation ( self , transformer_func : Callable [[ np . ndarray ], np . ndarray ] ) -> \"Structure\" : \"\"\"Applies a transformation function to all coordinates and returns a new Structure. Args: transformer_func: A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: A new Structure instance with transformed coordinates. \"\"\" new_chains = [] start_index = 0 original_coords = self . coordinates if original_coords is None : # Handle case with no coordinates - return a structure with chains having None coordinates # Recreate chains with None coords, ensuring topology is preserved for _ , chain in self . items (): # Create new chain with None coords new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , # Use property to get list index = chain . index , # Use original index coordinates = None , # Explicitly None # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) return Structure ( new_chains , id = self . id ) transformed_coords = transformer_func ( original_coords ) # Check for shape change after transformation if transformed_coords . shape != original_coords . shape : raise ValueError ( f \"Transformer function changed coordinate array shape from \" f \" { original_coords . shape } to { transformed_coords . shape } \" ) for ( _ , chain , ) in ( self . items () ): # Iterate in insertion order (Python 3.7+) or sorted order if needed num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the transformed coordinates for the current chain chain_transformed_coords = transformed_coords [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = chain_transformed_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Ensure all coordinates were assigned if start_index != transformed_coords . shape [ 0 ]: raise ValueError ( f \"Coordinate slicing error: processed { start_index } coordinates, \" f \"but expected { transformed_coords . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) def get_coordinate_at_residue ( self , residue : ResidueCoordinate ) -> Optional [ np . ndarray ]: \"\"\"Get the 3D coordinate for a specific residue. Args: residue: The residue coordinate to query. Returns: A NumPy array of coordinates (shape [3]) representing the residue's position (X, Y, Z), or None if the residue is not found. \"\"\" chain = self . __chains . get ( residue . chain_id ) if chain is None : return None # Use the Chain's __contains__ and __getitem__ for residue lookup if residue . residue_index in chain : target_residue_coord = chain [ residue . residue_index ] # Access the coordinates using the coordinate_index stored in ResidueCoordinate # Ensure the chain has coordinates and the index is valid if ( chain . coordinates is not None and 0 <= target_residue_coord . coordinate_index < len ( chain . coordinates ) ): return chain . coordinates [ target_residue_coord . coordinate_index ] # Residue index not found in chain or coordinate index invalid return None def with_coordinates ( self , coordinates : np . ndarray ) -> \"Structure\" : \"\"\"Create a new Structure with the given coordinates, preserving topology. Args: coordinates: A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: A new Structure instance with the provided coordinates. Raises: ValueError: If the shape or total number of input coordinates does not match the original structure's coordinate count. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) # Validate that the number of provided coordinates matches the original structure if coordinates . shape [ 0 ] != self . _total_coordinates : raise ValueError ( f \"Input coordinates count ( { coordinates . shape [ 0 ] } ) does not match \" f \"the original structure's total coordinates ( { self . _total_coordinates } ).\" ) new_chains = [] start_index = 0 for ( _ , chain , ) in self . items (): # Iterate through original chains to maintain order num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the *new* coordinates array for the current chain new_chain_coords = coordinates [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = new_chain_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Final check to ensure all provided coordinates were used if start_index != coordinates . shape [ 0 ]: raise ValueError ( # Should not happen if initial count check passes, but good sanity check f \"Coordinate assignment error during 'with_coordinates': processed { start_index } coordinates, \" f \"but input had { coordinates . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) coordinates property Get a concatenated array of all coordinates across all chains, or None if empty. residues property Get a flattened list of all residues across all chains. __contains__ ( chain_id ) Check if a chain ID or ResidueCoordinate exists in the structure. Source code in src/flatprot/core/structure.py 354 355 356 357 358 359 360 361 362 363 def __contains__ ( self , chain_id : str | ResidueCoordinate ) -> bool : \"\"\"Check if a chain ID or ResidueCoordinate exists in the structure.\"\"\" if isinstance ( chain_id , str ): return chain_id in self . __chains elif isinstance ( chain_id , ResidueCoordinate ): return ( chain_id . chain_id in self . __chains and chain_id . residue_index in self . __chains [ chain_id . chain_id ] ) return False __getitem__ ( chain_id ) Get a chain by its ID. Source code in src/flatprot/core/structure.py 350 351 352 def __getitem__ ( self , chain_id : str ) -> Chain : \"\"\"Get a chain by its ID.\"\"\" return self . __chains [ chain_id ] __init__ ( chains , id = None ) Initializes a Structure object. Parameters: chains ( list [ Chain ] ) \u2013 A list of Chain objects representing the chains in the structure. id ( Optional [ str ] , default: None ) \u2013 An optional identifier for the structure (e.g., PDB ID or filename stem). Source code in src/flatprot/core/structure.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def __init__ ( self , chains : list [ Chain ], id : Optional [ str ] = None ): \"\"\"Initializes a Structure object. Args: chains: A list of Chain objects representing the chains in the structure. id: An optional identifier for the structure (e.g., PDB ID or filename stem). \"\"\" self . __chains = { chain . id : chain for chain in chains } self . id = id or \"unknown_structure\" # Assign ID or a default # Pre-calculate total coordinates for validation if needed self . _total_coordinates = sum ( len ( chain . coordinates ) if chain . coordinates is not None else 0 for chain in self . values () ) __iter__ () Iterate over chain IDs and Chain objects. Source code in src/flatprot/core/structure.py 365 366 367 def __iter__ ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Iterate over chain IDs and Chain objects.\"\"\" return iter ( self . __chains . items ()) __len__ () Return the number of chains in the structure. Source code in src/flatprot/core/structure.py 377 378 379 def __len__ ( self ) -> int : \"\"\"Return the number of chains in the structure.\"\"\" return len ( self . __chains ) apply_vectorized_transformation ( transformer_func ) Applies a transformation function to all coordinates and returns a new Structure. Parameters: transformer_func ( Callable [[ ndarray ], ndarray ] ) \u2013 A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: Structure \u2013 A new Structure instance with transformed coordinates. Source code in src/flatprot/core/structure.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def apply_vectorized_transformation ( self , transformer_func : Callable [[ np . ndarray ], np . ndarray ] ) -> \"Structure\" : \"\"\"Applies a transformation function to all coordinates and returns a new Structure. Args: transformer_func: A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: A new Structure instance with transformed coordinates. \"\"\" new_chains = [] start_index = 0 original_coords = self . coordinates if original_coords is None : # Handle case with no coordinates - return a structure with chains having None coordinates # Recreate chains with None coords, ensuring topology is preserved for _ , chain in self . items (): # Create new chain with None coords new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , # Use property to get list index = chain . index , # Use original index coordinates = None , # Explicitly None # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) return Structure ( new_chains , id = self . id ) transformed_coords = transformer_func ( original_coords ) # Check for shape change after transformation if transformed_coords . shape != original_coords . shape : raise ValueError ( f \"Transformer function changed coordinate array shape from \" f \" { original_coords . shape } to { transformed_coords . shape } \" ) for ( _ , chain , ) in ( self . items () ): # Iterate in insertion order (Python 3.7+) or sorted order if needed num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the transformed coordinates for the current chain chain_transformed_coords = transformed_coords [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = chain_transformed_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Ensure all coordinates were assigned if start_index != transformed_coords . shape [ 0 ]: raise ValueError ( f \"Coordinate slicing error: processed { start_index } coordinates, \" f \"but expected { transformed_coords . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) get_coordinate_at_residue ( residue ) Get the 3D coordinate for a specific residue. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate to query. Returns: Optional [ ndarray ] \u2013 A NumPy array of coordinates (shape [3]) representing the residue's Optional [ ndarray ] \u2013 position (X, Y, Z), or None if the residue is not found. Source code in src/flatprot/core/structure.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 def get_coordinate_at_residue ( self , residue : ResidueCoordinate ) -> Optional [ np . ndarray ]: \"\"\"Get the 3D coordinate for a specific residue. Args: residue: The residue coordinate to query. Returns: A NumPy array of coordinates (shape [3]) representing the residue's position (X, Y, Z), or None if the residue is not found. \"\"\" chain = self . __chains . get ( residue . chain_id ) if chain is None : return None # Use the Chain's __contains__ and __getitem__ for residue lookup if residue . residue_index in chain : target_residue_coord = chain [ residue . residue_index ] # Access the coordinates using the coordinate_index stored in ResidueCoordinate # Ensure the chain has coordinates and the index is valid if ( chain . coordinates is not None and 0 <= target_residue_coord . coordinate_index < len ( chain . coordinates ) ): return chain . coordinates [ target_residue_coord . coordinate_index ] # Residue index not found in chain or coordinate index invalid return None items () Return an iterator over chain ID / Chain pairs. Source code in src/flatprot/core/structure.py 369 370 371 def items ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Return an iterator over chain ID / Chain pairs.\"\"\" return self . __chains . items () values () Return an iterator over Chain objects. Source code in src/flatprot/core/structure.py 373 374 375 def values ( self ) -> Iterator [ Chain ]: \"\"\"Return an iterator over Chain objects.\"\"\" return self . __chains . values () with_coordinates ( coordinates ) Create a new Structure with the given coordinates, preserving topology. Parameters: coordinates ( ndarray ) \u2013 A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: Structure \u2013 A new Structure instance with the provided coordinates. Raises: ValueError \u2013 If the shape or total number of input coordinates does not match the original structure's coordinate count. Source code in src/flatprot/core/structure.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def with_coordinates ( self , coordinates : np . ndarray ) -> \"Structure\" : \"\"\"Create a new Structure with the given coordinates, preserving topology. Args: coordinates: A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: A new Structure instance with the provided coordinates. Raises: ValueError: If the shape or total number of input coordinates does not match the original structure's coordinate count. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) # Validate that the number of provided coordinates matches the original structure if coordinates . shape [ 0 ] != self . _total_coordinates : raise ValueError ( f \"Input coordinates count ( { coordinates . shape [ 0 ] } ) does not match \" f \"the original structure's total coordinates ( { self . _total_coordinates } ).\" ) new_chains = [] start_index = 0 for ( _ , chain , ) in self . items (): # Iterate through original chains to maintain order num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the *new* coordinates array for the current chain new_chain_coords = coordinates [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = new_chain_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Final check to ensure all provided coordinates were used if start_index != coordinates . shape [ 0 ]: raise ValueError ( # Should not happen if initial count check passes, but good sanity check f \"Coordinate assignment error during 'with_coordinates': processed { start_index } coordinates, \" f \"but input had { coordinates . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) options: show_root_heading: true members_order: source Coordinate and Range Types ResidueCoordinate dataclass Source code in src/flatprot/core/coordinates.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class ResidueCoordinate : chain_id : str residue_index : int residue_type : Optional [ ResidueType ] = None coordinate_index : Optional [ int ] = None @staticmethod def from_string ( string : str ) -> \"ResidueCoordinate\" : \"\"\"Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Args: string: The string representation to parse. Returns: A ResidueCoordinate instance. Raises: ValueError: If the string format is invalid. \"\"\" match = _RESIDUE_COORD_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueCoordinate format: ' { string } '. Expected 'CHAIN:INDEX'.\" ) chain_name , residue_index_str = match . groups () return ResidueCoordinate ( chain_name , int ( residue_index_str )) def __str__ ( self ) -> str : if self . residue_type : return f \" { self . chain_id } : { self . residue_index } ( { self . residue_type . name } )\" else : return f \" { self . chain_id } : { self . residue_index } \" def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , ResidueCoordinate ): raise TypeError ( f \"Cannot compare ResidueCoordinate with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . residue_index == other . residue_index ) def __lt__ ( self , other : object ) -> bool : if not isinstance ( other , ResidueCoordinate ): raise TypeError ( f \"Cannot compare ResidueCoordinate with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . residue_index < other . residue_index from_string ( string ) staticmethod Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueCoordinate \u2013 A ResidueCoordinate instance. Raises: ValueError \u2013 If the string format is invalid. Source code in src/flatprot/core/coordinates.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @staticmethod def from_string ( string : str ) -> \"ResidueCoordinate\" : \"\"\"Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Args: string: The string representation to parse. Returns: A ResidueCoordinate instance. Raises: ValueError: If the string format is invalid. \"\"\" match = _RESIDUE_COORD_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueCoordinate format: ' { string } '. Expected 'CHAIN:INDEX'.\" ) chain_name , residue_index_str = match . groups () return ResidueCoordinate ( chain_name , int ( residue_index_str )) ResidueRange dataclass Represents a continuous range of residues within a single chain. Source code in src/flatprot/core/coordinates.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @dataclass ( frozen = True ) class ResidueRange : \"\"\"Represents a continuous range of residues within a single chain.\"\"\" chain_id : str start : int end : int coordinates_start_index : Optional [ int ] = None secondary_structure_type : Optional [ SecondaryStructureType ] = None def to_set ( self ) -> \"ResidueRangeSet\" : return ResidueRangeSet ([ self ]) def __post_init__ ( self ) -> None : if self . start > self . end : raise ValueError ( f \"Invalid range: { self . start } > { self . end } \" ) def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in this range.\"\"\" for i in range ( self . start , self . end + 1 ): yield ResidueCoordinate ( self . chain_id , i ) def __len__ ( self ) -> int : \"\"\"Number of residues in this range.\"\"\" return self . end - self . start + 1 @staticmethod def from_string ( string : str ) -> \"ResidueRange\" : \"\"\"Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Args: string: The string representation to parse. Returns: A ResidueRange instance. Raises: ValueError: If the string format is invalid or start > end. \"\"\" match = _RESIDUE_RANGE_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueRange format: ' { string } '. Expected 'CHAIN:START-END'.\" ) chain , start_str , end_str = match . groups () start , end = int ( start_str ), int ( end_str ) # The __post_init__ check for start > end will still run return ResidueRange ( chain , start , end ) def __str__ ( self ) -> str : if self . secondary_structure_type : return f \" { self . chain_id } : { self . start } - { self . end } ( { self . secondary_structure_type . name } )\" else : return f \" { self . chain_id } : { self . start } - { self . end } \" def __lt__ ( self , other : \"ResidueRange\" ) -> bool : \"\"\"Compare ranges for sorting. Sorts first by chain_id, then by start position. Args: other: Another ResidueRange to compare with Returns: bool: True if this range should come before the other \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . start < other . start def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two ranges are equal. Args: other: Another object to compare with Returns: bool: True if the ranges are equal \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . start == other . start and self . end == other . end ) def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range contains the other object \"\"\" if isinstance ( other , ResidueRange ): return ( self . chain_id == other . chain_id and self . start <= other . start and self . end >= other . end ) elif isinstance ( other , ResidueCoordinate ): return ( self . chain_id == other . chain_id and self . start <= other . residue_index <= self . end ) def is_adjacent_to ( self , other : Union [ \"ResidueRange\" , ResidueCoordinate ]) -> bool : \"\"\"Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Args: other: The other range or residue coordinate to check adjacency with. Returns: bool: True if the range is adjacent to the other object, False otherwise. Raises: TypeError: If other is not a ResidueRange or ResidueCoordinate. \"\"\" if not isinstance ( other , ( ResidueRange , ResidueCoordinate )): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) # Must be in the same chain to be adjacent if self . chain_id != other . chain_id : return False if isinstance ( other , ResidueRange ): # Check if self's end is exactly one residue before other's start if self . end + 1 == other . start : return True # Check if other's end is exactly one residue before self's start if other . end + 1 == self . start : return True else : # ResidueCoordinate # Check if the coordinate is exactly one residue before the range's start if other . residue_index + 1 == self . start : return True # Check if the coordinate is exactly one residue after the range's end if self . end + 1 == other . residue_index : return True return False __contains__ ( other ) Check if this range contains another range or residue coordinate. Parameters: other ( object ) \u2013 Another object to check containment with Returns: bool ( bool ) \u2013 True if this range contains the other object Source code in src/flatprot/core/coordinates.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range contains the other object \"\"\" if isinstance ( other , ResidueRange ): return ( self . chain_id == other . chain_id and self . start <= other . start and self . end >= other . end ) elif isinstance ( other , ResidueCoordinate ): return ( self . chain_id == other . chain_id and self . start <= other . residue_index <= self . end ) __eq__ ( other ) Check if two ranges are equal. Parameters: other ( object ) \u2013 Another object to compare with Returns: bool ( bool ) \u2013 True if the ranges are equal Source code in src/flatprot/core/coordinates.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two ranges are equal. Args: other: Another object to compare with Returns: bool: True if the ranges are equal \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . start == other . start and self . end == other . end ) __iter__ () Iterate over all ResidueCoordinates in this range. Source code in src/flatprot/core/coordinates.py 84 85 86 87 def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in this range.\"\"\" for i in range ( self . start , self . end + 1 ): yield ResidueCoordinate ( self . chain_id , i ) __len__ () Number of residues in this range. Source code in src/flatprot/core/coordinates.py 89 90 91 def __len__ ( self ) -> int : \"\"\"Number of residues in this range.\"\"\" return self . end - self . start + 1 __lt__ ( other ) Compare ranges for sorting. Sorts first by chain_id, then by start position. Parameters: other ( ResidueRange ) \u2013 Another ResidueRange to compare with Returns: bool ( bool ) \u2013 True if this range should come before the other Source code in src/flatprot/core/coordinates.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __lt__ ( self , other : \"ResidueRange\" ) -> bool : \"\"\"Compare ranges for sorting. Sorts first by chain_id, then by start position. Args: other: Another ResidueRange to compare with Returns: bool: True if this range should come before the other \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . start < other . start from_string ( string ) staticmethod Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueRange \u2013 A ResidueRange instance. Raises: ValueError \u2013 If the string format is invalid or start > end. Source code in src/flatprot/core/coordinates.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @staticmethod def from_string ( string : str ) -> \"ResidueRange\" : \"\"\"Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Args: string: The string representation to parse. Returns: A ResidueRange instance. Raises: ValueError: If the string format is invalid or start > end. \"\"\" match = _RESIDUE_RANGE_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueRange format: ' { string } '. Expected 'CHAIN:START-END'.\" ) chain , start_str , end_str = match . groups () start , end = int ( start_str ), int ( end_str ) # The __post_init__ check for start > end will still run return ResidueRange ( chain , start , end ) is_adjacent_to ( other ) Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Parameters: other ( Union [ ResidueRange , ResidueCoordinate ] ) \u2013 The other range or residue coordinate to check adjacency with. Returns: bool ( bool ) \u2013 True if the range is adjacent to the other object, False otherwise. Raises: TypeError \u2013 If other is not a ResidueRange or ResidueCoordinate. Source code in src/flatprot/core/coordinates.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def is_adjacent_to ( self , other : Union [ \"ResidueRange\" , ResidueCoordinate ]) -> bool : \"\"\"Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Args: other: The other range or residue coordinate to check adjacency with. Returns: bool: True if the range is adjacent to the other object, False otherwise. Raises: TypeError: If other is not a ResidueRange or ResidueCoordinate. \"\"\" if not isinstance ( other , ( ResidueRange , ResidueCoordinate )): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) # Must be in the same chain to be adjacent if self . chain_id != other . chain_id : return False if isinstance ( other , ResidueRange ): # Check if self's end is exactly one residue before other's start if self . end + 1 == other . start : return True # Check if other's end is exactly one residue before self's start if other . end + 1 == self . start : return True else : # ResidueCoordinate # Check if the coordinate is exactly one residue before the range's start if other . residue_index + 1 == self . start : return True # Check if the coordinate is exactly one residue after the range's end if self . end + 1 == other . residue_index : return True return False ResidueRangeSet Represents multiple ranges of residues, potentially across different chains. Source code in src/flatprot/core/coordinates.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class ResidueRangeSet : \"\"\"Represents multiple ranges of residues, potentially across different chains.\"\"\" def __init__ ( self , ranges : List [ ResidueRange ]): # Sort ranges for consistent representation and efficient searching self . ranges = sorted ( ranges , key = lambda r : ( r . chain_id , r . start )) @staticmethod def from_string ( string : str ) -> \"ResidueRangeSet\" : \"\"\"Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Args: string: The string representation to parse. Returns: A ResidueRangeSet instance. Raises: ValueError: If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. \"\"\" if not string : raise ValueError ( \"Input string for ResidueRangeSet cannot be empty.\" ) parts = string . split ( \",\" ) ranges = [] for part in parts : stripped_part = part . strip () if not stripped_part : # Handle cases like \"A:1-5,,B:6-10\" or leading/trailing commas raise ValueError ( f \"Empty range part found in string: ' { string } ' after splitting by comma.\" ) try : # Leverage ResidueRange's parsing and validation ranges . append ( ResidueRange . from_string ( stripped_part )) except ValueError as e : # Re-raise with context about which part failed raise ValueError ( f \"Error parsing range part ' { stripped_part } ' in ' { string } ': { e } \" ) from e if not ranges : # This case might be redundant if empty string/parts are caught above, # but kept for robustness, e.g., if string only contains commas/whitespace. raise ValueError ( f \"No valid residue ranges found in string: ' { string } '.\" ) return ResidueRangeSet ( ranges ) def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in all ranges.\"\"\" for range_ in self . ranges : yield from range_ def __len__ ( self ) -> int : \"\"\"Total number of residues across all ranges.\"\"\" return sum ( len ( range_ ) for range_ in self . ranges ) def __str__ ( self ) -> str : return \",\" . join ( str ( r ) for r in self . ranges ) def __repr__ ( self ) -> str : return f \"ResidueRangeSet( { self . __str__ () } )\" def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range set contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range set contains the other object \"\"\" if isinstance ( other , ResidueRange ): return any ( other in range_ for range_ in self . ranges ) elif isinstance ( other , ResidueCoordinate ): return any ( other in range_ for range_ in self . ranges ) return False def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two range sets are equal. Args: other: Another object to compare with Returns: bool: True if the range sets are equal \"\"\" if not isinstance ( other , ResidueRangeSet ): raise TypeError ( f \"Cannot compare ResidueRangeSet with { type ( other ) } \" ) return sorted ( self . ranges ) == sorted ( other . ranges ) def is_adjacent_to ( self , other : Union [ \"ResidueRangeSet\" , ResidueRange , ResidueCoordinate ] ) -> bool : \"\"\"Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Args: other: The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool: True if the range sets are adjacent, False otherwise. Raises: TypeError: If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. \"\"\" if isinstance ( other , ResidueRangeSet ): # Check each pair of ranges from both sets for range1 in self . ranges : for range2 in other . ranges : if range1 . is_adjacent_to ( range2 ): return True elif isinstance ( other , ( ResidueRange , ResidueCoordinate )): # Convert the single range to a set and check adjacency for range1 in self . ranges : if range1 . is_adjacent_to ( other ): return True else : raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return False __contains__ ( other ) Check if this range set contains another range or residue coordinate. Parameters: other ( object ) \u2013 Another object to check containment with Returns: bool ( bool ) \u2013 True if this range set contains the other object Source code in src/flatprot/core/coordinates.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range set contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range set contains the other object \"\"\" if isinstance ( other , ResidueRange ): return any ( other in range_ for range_ in self . ranges ) elif isinstance ( other , ResidueCoordinate ): return any ( other in range_ for range_ in self . ranges ) return False __eq__ ( other ) Check if two range sets are equal. Parameters: other ( object ) \u2013 Another object to compare with Returns: bool ( bool ) \u2013 True if the range sets are equal Source code in src/flatprot/core/coordinates.py 310 311 312 313 314 315 316 317 318 319 320 321 322 def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two range sets are equal. Args: other: Another object to compare with Returns: bool: True if the range sets are equal \"\"\" if not isinstance ( other , ResidueRangeSet ): raise TypeError ( f \"Cannot compare ResidueRangeSet with { type ( other ) } \" ) return sorted ( self . ranges ) == sorted ( other . ranges ) __iter__ () Iterate over all ResidueCoordinates in all ranges. Source code in src/flatprot/core/coordinates.py 280 281 282 283 def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in all ranges.\"\"\" for range_ in self . ranges : yield from range_ __len__ () Total number of residues across all ranges. Source code in src/flatprot/core/coordinates.py 285 286 287 def __len__ ( self ) -> int : \"\"\"Total number of residues across all ranges.\"\"\" return sum ( len ( range_ ) for range_ in self . ranges ) from_string ( string ) staticmethod Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueRangeSet \u2013 A ResidueRangeSet instance. Raises: ValueError \u2013 If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. Source code in src/flatprot/core/coordinates.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @staticmethod def from_string ( string : str ) -> \"ResidueRangeSet\" : \"\"\"Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Args: string: The string representation to parse. Returns: A ResidueRangeSet instance. Raises: ValueError: If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. \"\"\" if not string : raise ValueError ( \"Input string for ResidueRangeSet cannot be empty.\" ) parts = string . split ( \",\" ) ranges = [] for part in parts : stripped_part = part . strip () if not stripped_part : # Handle cases like \"A:1-5,,B:6-10\" or leading/trailing commas raise ValueError ( f \"Empty range part found in string: ' { string } ' after splitting by comma.\" ) try : # Leverage ResidueRange's parsing and validation ranges . append ( ResidueRange . from_string ( stripped_part )) except ValueError as e : # Re-raise with context about which part failed raise ValueError ( f \"Error parsing range part ' { stripped_part } ' in ' { string } ': { e } \" ) from e if not ranges : # This case might be redundant if empty string/parts are caught above, # but kept for robustness, e.g., if string only contains commas/whitespace. raise ValueError ( f \"No valid residue ranges found in string: ' { string } '.\" ) return ResidueRangeSet ( ranges ) is_adjacent_to ( other ) Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Parameters: other ( Union [ ResidueRangeSet , ResidueRange , ResidueCoordinate ] ) \u2013 The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool ( bool ) \u2013 True if the range sets are adjacent, False otherwise. Raises: TypeError \u2013 If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Source code in src/flatprot/core/coordinates.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def is_adjacent_to ( self , other : Union [ \"ResidueRangeSet\" , ResidueRange , ResidueCoordinate ] ) -> bool : \"\"\"Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Args: other: The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool: True if the range sets are adjacent, False otherwise. Raises: TypeError: If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. \"\"\" if isinstance ( other , ResidueRangeSet ): # Check each pair of ranges from both sets for range1 in self . ranges : for range2 in other . ranges : if range1 . is_adjacent_to ( range2 ): return True elif isinstance ( other , ( ResidueRange , ResidueCoordinate )): # Convert the single range to a set and check adjacency for range1 in self . ranges : if range1 . is_adjacent_to ( other ): return True else : raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return False options: show_root_heading: true members_order: source Core Errors CoordinateCalculationError Bases: CoordinateError Error raised when calculation of display coordinates fails (e.g., insufficient points). Source code in src/flatprot/core/errors.py 20 21 22 23 24 class CoordinateCalculationError ( CoordinateError ): \"\"\"Error raised when calculation of display coordinates fails (e.g., insufficient points).\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message ) CoordinateError Bases: FlatProtError Error related to coordinate management. Source code in src/flatprot/core/errors.py 13 14 15 16 17 class CoordinateError ( FlatProtError ): \"\"\"Error related to coordinate management.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message ) FlatProtError Bases: Exception Base exception class for FlatProt CLI errors. This class is used as the base for all custom exceptions raised by the CLI. It provides a consistent interface for error handling and formatting. Source code in src/flatprot/core/errors.py 1 2 3 4 5 6 7 8 9 10 class FlatProtError ( Exception ): \"\"\"Base exception class for FlatProt CLI errors. This class is used as the base for all custom exceptions raised by the CLI. It provides a consistent interface for error handling and formatting. \"\"\" def __init__ ( self , message : str ): self . message = message super () . __init__ ( self . message ) options: show_root_heading: true members_order: source Logger Logging utilities for FlatProt. getLogger ( name = __app_name__ ) Get a configured logger with the given name. Parameters: name ( str , default: __app_name__ ) \u2013 Logger name (defaults to \"flatprot\") Returns: Logger \u2013 Configured logging.Logger instance Source code in src/flatprot/core/logger.py 10 11 12 13 14 15 16 17 18 19 20 21 def getLogger ( name : str = __app_name__ ) -> logging . Logger : \"\"\"Get a configured logger with the given name. Args: name: Logger name (defaults to \"flatprot\") Returns: Configured logging.Logger instance \"\"\" # Get the logger logger = logging . getLogger ( name ) return logger options: show_root_heading: true members_order: source","title":"Core"},{"location":"api/core/#core-api","text":"This section documents the core data structures and fundamental types used within FlatProt.","title":"Core API"},{"location":"api/core/#structure-representation","text":"Represents a complete protein structure composed of multiple chains. Source code in src/flatprot/core/structure.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class Structure : \"\"\"Represents a complete protein structure composed of multiple chains.\"\"\" def __init__ ( self , chains : list [ Chain ], id : Optional [ str ] = None ): \"\"\"Initializes a Structure object. Args: chains: A list of Chain objects representing the chains in the structure. id: An optional identifier for the structure (e.g., PDB ID or filename stem). \"\"\" self . __chains = { chain . id : chain for chain in chains } self . id = id or \"unknown_structure\" # Assign ID or a default # Pre-calculate total coordinates for validation if needed self . _total_coordinates = sum ( len ( chain . coordinates ) if chain . coordinates is not None else 0 for chain in self . values () ) def __getitem__ ( self , chain_id : str ) -> Chain : \"\"\"Get a chain by its ID.\"\"\" return self . __chains [ chain_id ] def __contains__ ( self , chain_id : str | ResidueCoordinate ) -> bool : \"\"\"Check if a chain ID or ResidueCoordinate exists in the structure.\"\"\" if isinstance ( chain_id , str ): return chain_id in self . __chains elif isinstance ( chain_id , ResidueCoordinate ): return ( chain_id . chain_id in self . __chains and chain_id . residue_index in self . __chains [ chain_id . chain_id ] ) return False def __iter__ ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Iterate over chain IDs and Chain objects.\"\"\" return iter ( self . __chains . items ()) def items ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Return an iterator over chain ID / Chain pairs.\"\"\" return self . __chains . items () def values ( self ) -> Iterator [ Chain ]: \"\"\"Return an iterator over Chain objects.\"\"\" return self . __chains . values () def __len__ ( self ) -> int : \"\"\"Return the number of chains in the structure.\"\"\" return len ( self . __chains ) @property def residues ( self ) -> list [ ResidueType ]: \"\"\"Get a flattened list of all residues across all chains.\"\"\" all_residues = [] for chain in self . __chains . values (): all_residues . extend ( chain . residues ) return all_residues @property def coordinates ( self ) -> Optional [ np . ndarray ]: \"\"\"Get a concatenated array of all coordinates across all chains, or None if empty.\"\"\" all_coords = [ chain . coordinates for chain in self . __chains . values () if chain . coordinates is not None and chain . coordinates . size > 0 ] if not all_coords : return None return np . vstack ( all_coords ) def __str__ ( self ) -> str : return f \"Structure(ID: { self . id } , Chains: { list ( self . __chains . keys ()) } )\" def apply_vectorized_transformation ( self , transformer_func : Callable [[ np . ndarray ], np . ndarray ] ) -> \"Structure\" : \"\"\"Applies a transformation function to all coordinates and returns a new Structure. Args: transformer_func: A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: A new Structure instance with transformed coordinates. \"\"\" new_chains = [] start_index = 0 original_coords = self . coordinates if original_coords is None : # Handle case with no coordinates - return a structure with chains having None coordinates # Recreate chains with None coords, ensuring topology is preserved for _ , chain in self . items (): # Create new chain with None coords new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , # Use property to get list index = chain . index , # Use original index coordinates = None , # Explicitly None # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) return Structure ( new_chains , id = self . id ) transformed_coords = transformer_func ( original_coords ) # Check for shape change after transformation if transformed_coords . shape != original_coords . shape : raise ValueError ( f \"Transformer function changed coordinate array shape from \" f \" { original_coords . shape } to { transformed_coords . shape } \" ) for ( _ , chain , ) in ( self . items () ): # Iterate in insertion order (Python 3.7+) or sorted order if needed num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the transformed coordinates for the current chain chain_transformed_coords = transformed_coords [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = chain_transformed_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Ensure all coordinates were assigned if start_index != transformed_coords . shape [ 0 ]: raise ValueError ( f \"Coordinate slicing error: processed { start_index } coordinates, \" f \"but expected { transformed_coords . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) def get_coordinate_at_residue ( self , residue : ResidueCoordinate ) -> Optional [ np . ndarray ]: \"\"\"Get the 3D coordinate for a specific residue. Args: residue: The residue coordinate to query. Returns: A NumPy array of coordinates (shape [3]) representing the residue's position (X, Y, Z), or None if the residue is not found. \"\"\" chain = self . __chains . get ( residue . chain_id ) if chain is None : return None # Use the Chain's __contains__ and __getitem__ for residue lookup if residue . residue_index in chain : target_residue_coord = chain [ residue . residue_index ] # Access the coordinates using the coordinate_index stored in ResidueCoordinate # Ensure the chain has coordinates and the index is valid if ( chain . coordinates is not None and 0 <= target_residue_coord . coordinate_index < len ( chain . coordinates ) ): return chain . coordinates [ target_residue_coord . coordinate_index ] # Residue index not found in chain or coordinate index invalid return None def with_coordinates ( self , coordinates : np . ndarray ) -> \"Structure\" : \"\"\"Create a new Structure with the given coordinates, preserving topology. Args: coordinates: A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: A new Structure instance with the provided coordinates. Raises: ValueError: If the shape or total number of input coordinates does not match the original structure's coordinate count. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) # Validate that the number of provided coordinates matches the original structure if coordinates . shape [ 0 ] != self . _total_coordinates : raise ValueError ( f \"Input coordinates count ( { coordinates . shape [ 0 ] } ) does not match \" f \"the original structure's total coordinates ( { self . _total_coordinates } ).\" ) new_chains = [] start_index = 0 for ( _ , chain , ) in self . items (): # Iterate through original chains to maintain order num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the *new* coordinates array for the current chain new_chain_coords = coordinates [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = new_chain_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Final check to ensure all provided coordinates were used if start_index != coordinates . shape [ 0 ]: raise ValueError ( # Should not happen if initial count check passes, but good sanity check f \"Coordinate assignment error during 'with_coordinates': processed { start_index } coordinates, \" f \"but input had { coordinates . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id )","title":"Structure Representation"},{"location":"api/core/#flatprot.core.Structure.coordinates","text":"Get a concatenated array of all coordinates across all chains, or None if empty.","title":"coordinates"},{"location":"api/core/#flatprot.core.Structure.residues","text":"Get a flattened list of all residues across all chains.","title":"residues"},{"location":"api/core/#flatprot.core.Structure.__contains__","text":"Check if a chain ID or ResidueCoordinate exists in the structure. Source code in src/flatprot/core/structure.py 354 355 356 357 358 359 360 361 362 363 def __contains__ ( self , chain_id : str | ResidueCoordinate ) -> bool : \"\"\"Check if a chain ID or ResidueCoordinate exists in the structure.\"\"\" if isinstance ( chain_id , str ): return chain_id in self . __chains elif isinstance ( chain_id , ResidueCoordinate ): return ( chain_id . chain_id in self . __chains and chain_id . residue_index in self . __chains [ chain_id . chain_id ] ) return False","title":"__contains__"},{"location":"api/core/#flatprot.core.Structure.__getitem__","text":"Get a chain by its ID. Source code in src/flatprot/core/structure.py 350 351 352 def __getitem__ ( self , chain_id : str ) -> Chain : \"\"\"Get a chain by its ID.\"\"\" return self . __chains [ chain_id ]","title":"__getitem__"},{"location":"api/core/#flatprot.core.Structure.__init__","text":"Initializes a Structure object. Parameters: chains ( list [ Chain ] ) \u2013 A list of Chain objects representing the chains in the structure. id ( Optional [ str ] , default: None ) \u2013 An optional identifier for the structure (e.g., PDB ID or filename stem). Source code in src/flatprot/core/structure.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def __init__ ( self , chains : list [ Chain ], id : Optional [ str ] = None ): \"\"\"Initializes a Structure object. Args: chains: A list of Chain objects representing the chains in the structure. id: An optional identifier for the structure (e.g., PDB ID or filename stem). \"\"\" self . __chains = { chain . id : chain for chain in chains } self . id = id or \"unknown_structure\" # Assign ID or a default # Pre-calculate total coordinates for validation if needed self . _total_coordinates = sum ( len ( chain . coordinates ) if chain . coordinates is not None else 0 for chain in self . values () )","title":"__init__"},{"location":"api/core/#flatprot.core.Structure.__iter__","text":"Iterate over chain IDs and Chain objects. Source code in src/flatprot/core/structure.py 365 366 367 def __iter__ ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Iterate over chain IDs and Chain objects.\"\"\" return iter ( self . __chains . items ())","title":"__iter__"},{"location":"api/core/#flatprot.core.Structure.__len__","text":"Return the number of chains in the structure. Source code in src/flatprot/core/structure.py 377 378 379 def __len__ ( self ) -> int : \"\"\"Return the number of chains in the structure.\"\"\" return len ( self . __chains )","title":"__len__"},{"location":"api/core/#flatprot.core.Structure.apply_vectorized_transformation","text":"Applies a transformation function to all coordinates and returns a new Structure. Parameters: transformer_func ( Callable [[ ndarray ], ndarray ] ) \u2013 A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: Structure \u2013 A new Structure instance with transformed coordinates. Source code in src/flatprot/core/structure.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 def apply_vectorized_transformation ( self , transformer_func : Callable [[ np . ndarray ], np . ndarray ] ) -> \"Structure\" : \"\"\"Applies a transformation function to all coordinates and returns a new Structure. Args: transformer_func: A function that takes an (N, 3) coordinate array and returns a transformed (N, 3) array. Returns: A new Structure instance with transformed coordinates. \"\"\" new_chains = [] start_index = 0 original_coords = self . coordinates if original_coords is None : # Handle case with no coordinates - return a structure with chains having None coordinates # Recreate chains with None coords, ensuring topology is preserved for _ , chain in self . items (): # Create new chain with None coords new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , # Use property to get list index = chain . index , # Use original index coordinates = None , # Explicitly None # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) return Structure ( new_chains , id = self . id ) transformed_coords = transformer_func ( original_coords ) # Check for shape change after transformation if transformed_coords . shape != original_coords . shape : raise ValueError ( f \"Transformer function changed coordinate array shape from \" f \" { original_coords . shape } to { transformed_coords . shape } \" ) for ( _ , chain , ) in ( self . items () ): # Iterate in insertion order (Python 3.7+) or sorted order if needed num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the transformed coordinates for the current chain chain_transformed_coords = transformed_coords [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = chain_transformed_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Ensure all coordinates were assigned if start_index != transformed_coords . shape [ 0 ]: raise ValueError ( f \"Coordinate slicing error: processed { start_index } coordinates, \" f \"but expected { transformed_coords . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id )","title":"apply_vectorized_transformation"},{"location":"api/core/#flatprot.core.Structure.get_coordinate_at_residue","text":"Get the 3D coordinate for a specific residue. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate to query. Returns: Optional [ ndarray ] \u2013 A NumPy array of coordinates (shape [3]) representing the residue's Optional [ ndarray ] \u2013 position (X, Y, Z), or None if the residue is not found. Source code in src/flatprot/core/structure.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 def get_coordinate_at_residue ( self , residue : ResidueCoordinate ) -> Optional [ np . ndarray ]: \"\"\"Get the 3D coordinate for a specific residue. Args: residue: The residue coordinate to query. Returns: A NumPy array of coordinates (shape [3]) representing the residue's position (X, Y, Z), or None if the residue is not found. \"\"\" chain = self . __chains . get ( residue . chain_id ) if chain is None : return None # Use the Chain's __contains__ and __getitem__ for residue lookup if residue . residue_index in chain : target_residue_coord = chain [ residue . residue_index ] # Access the coordinates using the coordinate_index stored in ResidueCoordinate # Ensure the chain has coordinates and the index is valid if ( chain . coordinates is not None and 0 <= target_residue_coord . coordinate_index < len ( chain . coordinates ) ): return chain . coordinates [ target_residue_coord . coordinate_index ] # Residue index not found in chain or coordinate index invalid return None","title":"get_coordinate_at_residue"},{"location":"api/core/#flatprot.core.Structure.items","text":"Return an iterator over chain ID / Chain pairs. Source code in src/flatprot/core/structure.py 369 370 371 def items ( self ) -> Iterator [ tuple [ str , Chain ]]: \"\"\"Return an iterator over chain ID / Chain pairs.\"\"\" return self . __chains . items ()","title":"items"},{"location":"api/core/#flatprot.core.Structure.values","text":"Return an iterator over Chain objects. Source code in src/flatprot/core/structure.py 373 374 375 def values ( self ) -> Iterator [ Chain ]: \"\"\"Return an iterator over Chain objects.\"\"\" return self . __chains . values ()","title":"values"},{"location":"api/core/#flatprot.core.Structure.with_coordinates","text":"Create a new Structure with the given coordinates, preserving topology. Parameters: coordinates ( ndarray ) \u2013 A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: Structure \u2013 A new Structure instance with the provided coordinates. Raises: ValueError \u2013 If the shape or total number of input coordinates does not match the original structure's coordinate count. Source code in src/flatprot/core/structure.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 def with_coordinates ( self , coordinates : np . ndarray ) -> \"Structure\" : \"\"\"Create a new Structure with the given coordinates, preserving topology. Args: coordinates: A NumPy array of shape (N, 3) containing the new coordinates, ordered consistently with the original structure's concatenated coordinates. Returns: A new Structure instance with the provided coordinates. Raises: ValueError: If the shape or total number of input coordinates does not match the original structure's coordinate count. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) # Validate that the number of provided coordinates matches the original structure if coordinates . shape [ 0 ] != self . _total_coordinates : raise ValueError ( f \"Input coordinates count ( { coordinates . shape [ 0 ] } ) does not match \" f \"the original structure's total coordinates ( { self . _total_coordinates } ).\" ) new_chains = [] start_index = 0 for ( _ , chain , ) in self . items (): # Iterate through original chains to maintain order num_coords_in_chain = ( len ( chain . coordinates ) if chain . coordinates is not None else 0 ) if num_coords_in_chain > 0 : # Slice the *new* coordinates array for the current chain new_chain_coords = coordinates [ start_index : start_index + num_coords_in_chain ] # Create the new chain with the sliced coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = new_chain_coords , # Pass a copy of the original secondary structure list secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) start_index += num_coords_in_chain else : # Handle chains originally having no coordinates new_chains . append ( Chain ( chain_id = chain . id , residues = chain . residues , index = chain . index , coordinates = None , # Keep coordinates as None secondary_structure = list ( chain . _Chain__secondary_structure ), ) ) # Final check to ensure all provided coordinates were used if start_index != coordinates . shape [ 0 ]: raise ValueError ( # Should not happen if initial count check passes, but good sanity check f \"Coordinate assignment error during 'with_coordinates': processed { start_index } coordinates, \" f \"but input had { coordinates . shape [ 0 ] } .\" ) return Structure ( new_chains , id = self . id ) options: show_root_heading: true members_order: source","title":"with_coordinates"},{"location":"api/core/#coordinate-and-range-types","text":"","title":"Coordinate and Range Types"},{"location":"api/core/#flatprot.core.coordinates.ResidueCoordinate","text":"Source code in src/flatprot/core/coordinates.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass ( frozen = True ) class ResidueCoordinate : chain_id : str residue_index : int residue_type : Optional [ ResidueType ] = None coordinate_index : Optional [ int ] = None @staticmethod def from_string ( string : str ) -> \"ResidueCoordinate\" : \"\"\"Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Args: string: The string representation to parse. Returns: A ResidueCoordinate instance. Raises: ValueError: If the string format is invalid. \"\"\" match = _RESIDUE_COORD_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueCoordinate format: ' { string } '. Expected 'CHAIN:INDEX'.\" ) chain_name , residue_index_str = match . groups () return ResidueCoordinate ( chain_name , int ( residue_index_str )) def __str__ ( self ) -> str : if self . residue_type : return f \" { self . chain_id } : { self . residue_index } ( { self . residue_type . name } )\" else : return f \" { self . chain_id } : { self . residue_index } \" def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , ResidueCoordinate ): raise TypeError ( f \"Cannot compare ResidueCoordinate with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . residue_index == other . residue_index ) def __lt__ ( self , other : object ) -> bool : if not isinstance ( other , ResidueCoordinate ): raise TypeError ( f \"Cannot compare ResidueCoordinate with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . residue_index < other . residue_index","title":"ResidueCoordinate"},{"location":"api/core/#flatprot.core.coordinates.ResidueCoordinate.from_string","text":"Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueCoordinate \u2013 A ResidueCoordinate instance. Raises: ValueError \u2013 If the string format is invalid. Source code in src/flatprot/core/coordinates.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @staticmethod def from_string ( string : str ) -> \"ResidueCoordinate\" : \"\"\"Parse 'CHAIN:INDEX' format (e.g., 'A:123'). Args: string: The string representation to parse. Returns: A ResidueCoordinate instance. Raises: ValueError: If the string format is invalid. \"\"\" match = _RESIDUE_COORD_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueCoordinate format: ' { string } '. Expected 'CHAIN:INDEX'.\" ) chain_name , residue_index_str = match . groups () return ResidueCoordinate ( chain_name , int ( residue_index_str ))","title":"from_string"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange","text":"Represents a continuous range of residues within a single chain. Source code in src/flatprot/core/coordinates.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @dataclass ( frozen = True ) class ResidueRange : \"\"\"Represents a continuous range of residues within a single chain.\"\"\" chain_id : str start : int end : int coordinates_start_index : Optional [ int ] = None secondary_structure_type : Optional [ SecondaryStructureType ] = None def to_set ( self ) -> \"ResidueRangeSet\" : return ResidueRangeSet ([ self ]) def __post_init__ ( self ) -> None : if self . start > self . end : raise ValueError ( f \"Invalid range: { self . start } > { self . end } \" ) def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in this range.\"\"\" for i in range ( self . start , self . end + 1 ): yield ResidueCoordinate ( self . chain_id , i ) def __len__ ( self ) -> int : \"\"\"Number of residues in this range.\"\"\" return self . end - self . start + 1 @staticmethod def from_string ( string : str ) -> \"ResidueRange\" : \"\"\"Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Args: string: The string representation to parse. Returns: A ResidueRange instance. Raises: ValueError: If the string format is invalid or start > end. \"\"\" match = _RESIDUE_RANGE_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueRange format: ' { string } '. Expected 'CHAIN:START-END'.\" ) chain , start_str , end_str = match . groups () start , end = int ( start_str ), int ( end_str ) # The __post_init__ check for start > end will still run return ResidueRange ( chain , start , end ) def __str__ ( self ) -> str : if self . secondary_structure_type : return f \" { self . chain_id } : { self . start } - { self . end } ( { self . secondary_structure_type . name } )\" else : return f \" { self . chain_id } : { self . start } - { self . end } \" def __lt__ ( self , other : \"ResidueRange\" ) -> bool : \"\"\"Compare ranges for sorting. Sorts first by chain_id, then by start position. Args: other: Another ResidueRange to compare with Returns: bool: True if this range should come before the other \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . start < other . start def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two ranges are equal. Args: other: Another object to compare with Returns: bool: True if the ranges are equal \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . start == other . start and self . end == other . end ) def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range contains the other object \"\"\" if isinstance ( other , ResidueRange ): return ( self . chain_id == other . chain_id and self . start <= other . start and self . end >= other . end ) elif isinstance ( other , ResidueCoordinate ): return ( self . chain_id == other . chain_id and self . start <= other . residue_index <= self . end ) def is_adjacent_to ( self , other : Union [ \"ResidueRange\" , ResidueCoordinate ]) -> bool : \"\"\"Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Args: other: The other range or residue coordinate to check adjacency with. Returns: bool: True if the range is adjacent to the other object, False otherwise. Raises: TypeError: If other is not a ResidueRange or ResidueCoordinate. \"\"\" if not isinstance ( other , ( ResidueRange , ResidueCoordinate )): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) # Must be in the same chain to be adjacent if self . chain_id != other . chain_id : return False if isinstance ( other , ResidueRange ): # Check if self's end is exactly one residue before other's start if self . end + 1 == other . start : return True # Check if other's end is exactly one residue before self's start if other . end + 1 == self . start : return True else : # ResidueCoordinate # Check if the coordinate is exactly one residue before the range's start if other . residue_index + 1 == self . start : return True # Check if the coordinate is exactly one residue after the range's end if self . end + 1 == other . residue_index : return True return False","title":"ResidueRange"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.__contains__","text":"Check if this range contains another range or residue coordinate. Parameters: other ( object ) \u2013 Another object to check containment with Returns: bool ( bool ) \u2013 True if this range contains the other object Source code in src/flatprot/core/coordinates.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range contains the other object \"\"\" if isinstance ( other , ResidueRange ): return ( self . chain_id == other . chain_id and self . start <= other . start and self . end >= other . end ) elif isinstance ( other , ResidueCoordinate ): return ( self . chain_id == other . chain_id and self . start <= other . residue_index <= self . end )","title":"__contains__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.__eq__","text":"Check if two ranges are equal. Parameters: other ( object ) \u2013 Another object to compare with Returns: bool ( bool ) \u2013 True if the ranges are equal Source code in src/flatprot/core/coordinates.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two ranges are equal. Args: other: Another object to compare with Returns: bool: True if the ranges are equal \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) return ( self . chain_id == other . chain_id and self . start == other . start and self . end == other . end )","title":"__eq__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.__iter__","text":"Iterate over all ResidueCoordinates in this range. Source code in src/flatprot/core/coordinates.py 84 85 86 87 def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in this range.\"\"\" for i in range ( self . start , self . end + 1 ): yield ResidueCoordinate ( self . chain_id , i )","title":"__iter__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.__len__","text":"Number of residues in this range. Source code in src/flatprot/core/coordinates.py 89 90 91 def __len__ ( self ) -> int : \"\"\"Number of residues in this range.\"\"\" return self . end - self . start + 1","title":"__len__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.__lt__","text":"Compare ranges for sorting. Sorts first by chain_id, then by start position. Parameters: other ( ResidueRange ) \u2013 Another ResidueRange to compare with Returns: bool ( bool ) \u2013 True if this range should come before the other Source code in src/flatprot/core/coordinates.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __lt__ ( self , other : \"ResidueRange\" ) -> bool : \"\"\"Compare ranges for sorting. Sorts first by chain_id, then by start position. Args: other: Another ResidueRange to compare with Returns: bool: True if this range should come before the other \"\"\" if not isinstance ( other , ResidueRange ): raise TypeError ( f \"Cannot compare ResidueRange with { type ( other ) } \" ) if self . chain_id != other . chain_id : return self . chain_id < other . chain_id return self . start < other . start","title":"__lt__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.from_string","text":"Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueRange \u2013 A ResidueRange instance. Raises: ValueError \u2013 If the string format is invalid or start > end. Source code in src/flatprot/core/coordinates.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @staticmethod def from_string ( string : str ) -> \"ResidueRange\" : \"\"\"Parse 'CHAIN:START-END' format (e.g., 'A:14-20'). Args: string: The string representation to parse. Returns: A ResidueRange instance. Raises: ValueError: If the string format is invalid or start > end. \"\"\" match = _RESIDUE_RANGE_PATTERN . match ( string ) if not match : raise ValueError ( f \"Invalid ResidueRange format: ' { string } '. Expected 'CHAIN:START-END'.\" ) chain , start_str , end_str = match . groups () start , end = int ( start_str ), int ( end_str ) # The __post_init__ check for start > end will still run return ResidueRange ( chain , start , end )","title":"from_string"},{"location":"api/core/#flatprot.core.coordinates.ResidueRange.is_adjacent_to","text":"Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Parameters: other ( Union [ ResidueRange , ResidueCoordinate ] ) \u2013 The other range or residue coordinate to check adjacency with. Returns: bool ( bool ) \u2013 True if the range is adjacent to the other object, False otherwise. Raises: TypeError \u2013 If other is not a ResidueRange or ResidueCoordinate. Source code in src/flatprot/core/coordinates.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def is_adjacent_to ( self , other : Union [ \"ResidueRange\" , ResidueCoordinate ]) -> bool : \"\"\"Check if this range is adjacent to another range or residue coordinate. Two ranges are considered adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start. For example, A:10-15 is adjacent to A:16-20, but not to A:15-20 (overlap) or A:17-20 (gap). A range and a residue coordinate are considered adjacent if they are in the same chain and the coordinate is exactly one residue before the range's start or exactly one residue after the range's end. Args: other: The other range or residue coordinate to check adjacency with. Returns: bool: True if the range is adjacent to the other object, False otherwise. Raises: TypeError: If other is not a ResidueRange or ResidueCoordinate. \"\"\" if not isinstance ( other , ( ResidueRange , ResidueCoordinate )): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) # Must be in the same chain to be adjacent if self . chain_id != other . chain_id : return False if isinstance ( other , ResidueRange ): # Check if self's end is exactly one residue before other's start if self . end + 1 == other . start : return True # Check if other's end is exactly one residue before self's start if other . end + 1 == self . start : return True else : # ResidueCoordinate # Check if the coordinate is exactly one residue before the range's start if other . residue_index + 1 == self . start : return True # Check if the coordinate is exactly one residue after the range's end if self . end + 1 == other . residue_index : return True return False","title":"is_adjacent_to"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet","text":"Represents multiple ranges of residues, potentially across different chains. Source code in src/flatprot/core/coordinates.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class ResidueRangeSet : \"\"\"Represents multiple ranges of residues, potentially across different chains.\"\"\" def __init__ ( self , ranges : List [ ResidueRange ]): # Sort ranges for consistent representation and efficient searching self . ranges = sorted ( ranges , key = lambda r : ( r . chain_id , r . start )) @staticmethod def from_string ( string : str ) -> \"ResidueRangeSet\" : \"\"\"Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Args: string: The string representation to parse. Returns: A ResidueRangeSet instance. Raises: ValueError: If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. \"\"\" if not string : raise ValueError ( \"Input string for ResidueRangeSet cannot be empty.\" ) parts = string . split ( \",\" ) ranges = [] for part in parts : stripped_part = part . strip () if not stripped_part : # Handle cases like \"A:1-5,,B:6-10\" or leading/trailing commas raise ValueError ( f \"Empty range part found in string: ' { string } ' after splitting by comma.\" ) try : # Leverage ResidueRange's parsing and validation ranges . append ( ResidueRange . from_string ( stripped_part )) except ValueError as e : # Re-raise with context about which part failed raise ValueError ( f \"Error parsing range part ' { stripped_part } ' in ' { string } ': { e } \" ) from e if not ranges : # This case might be redundant if empty string/parts are caught above, # but kept for robustness, e.g., if string only contains commas/whitespace. raise ValueError ( f \"No valid residue ranges found in string: ' { string } '.\" ) return ResidueRangeSet ( ranges ) def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in all ranges.\"\"\" for range_ in self . ranges : yield from range_ def __len__ ( self ) -> int : \"\"\"Total number of residues across all ranges.\"\"\" return sum ( len ( range_ ) for range_ in self . ranges ) def __str__ ( self ) -> str : return \",\" . join ( str ( r ) for r in self . ranges ) def __repr__ ( self ) -> str : return f \"ResidueRangeSet( { self . __str__ () } )\" def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range set contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range set contains the other object \"\"\" if isinstance ( other , ResidueRange ): return any ( other in range_ for range_ in self . ranges ) elif isinstance ( other , ResidueCoordinate ): return any ( other in range_ for range_ in self . ranges ) return False def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two range sets are equal. Args: other: Another object to compare with Returns: bool: True if the range sets are equal \"\"\" if not isinstance ( other , ResidueRangeSet ): raise TypeError ( f \"Cannot compare ResidueRangeSet with { type ( other ) } \" ) return sorted ( self . ranges ) == sorted ( other . ranges ) def is_adjacent_to ( self , other : Union [ \"ResidueRangeSet\" , ResidueRange , ResidueCoordinate ] ) -> bool : \"\"\"Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Args: other: The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool: True if the range sets are adjacent, False otherwise. Raises: TypeError: If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. \"\"\" if isinstance ( other , ResidueRangeSet ): # Check each pair of ranges from both sets for range1 in self . ranges : for range2 in other . ranges : if range1 . is_adjacent_to ( range2 ): return True elif isinstance ( other , ( ResidueRange , ResidueCoordinate )): # Convert the single range to a set and check adjacency for range1 in self . ranges : if range1 . is_adjacent_to ( other ): return True else : raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return False","title":"ResidueRangeSet"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.__contains__","text":"Check if this range set contains another range or residue coordinate. Parameters: other ( object ) \u2013 Another object to check containment with Returns: bool ( bool ) \u2013 True if this range set contains the other object Source code in src/flatprot/core/coordinates.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def __contains__ ( self , other : object ) -> bool : \"\"\"Check if this range set contains another range or residue coordinate. Args: other: Another object to check containment with Returns: bool: True if this range set contains the other object \"\"\" if isinstance ( other , ResidueRange ): return any ( other in range_ for range_ in self . ranges ) elif isinstance ( other , ResidueCoordinate ): return any ( other in range_ for range_ in self . ranges ) return False","title":"__contains__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.__eq__","text":"Check if two range sets are equal. Parameters: other ( object ) \u2013 Another object to compare with Returns: bool ( bool ) \u2013 True if the range sets are equal Source code in src/flatprot/core/coordinates.py 310 311 312 313 314 315 316 317 318 319 320 321 322 def __eq__ ( self , other : object ) -> bool : \"\"\"Check if two range sets are equal. Args: other: Another object to compare with Returns: bool: True if the range sets are equal \"\"\" if not isinstance ( other , ResidueRangeSet ): raise TypeError ( f \"Cannot compare ResidueRangeSet with { type ( other ) } \" ) return sorted ( self . ranges ) == sorted ( other . ranges )","title":"__eq__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.__iter__","text":"Iterate over all ResidueCoordinates in all ranges. Source code in src/flatprot/core/coordinates.py 280 281 282 283 def __iter__ ( self ) -> Iterator [ ResidueCoordinate ]: \"\"\"Iterate over all ResidueCoordinates in all ranges.\"\"\" for range_ in self . ranges : yield from range_","title":"__iter__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.__len__","text":"Total number of residues across all ranges. Source code in src/flatprot/core/coordinates.py 285 286 287 def __len__ ( self ) -> int : \"\"\"Total number of residues across all ranges.\"\"\" return sum ( len ( range_ ) for range_ in self . ranges )","title":"__len__"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.from_string","text":"Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Parameters: string ( str ) \u2013 The string representation to parse. Returns: ResidueRangeSet \u2013 A ResidueRangeSet instance. Raises: ValueError \u2013 If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. Source code in src/flatprot/core/coordinates.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @staticmethod def from_string ( string : str ) -> \"ResidueRangeSet\" : \"\"\"Parse 'A:14-20, B:10-15' format. Ranges are separated by commas. Whitespace around ranges and commas is ignored. Args: string: The string representation to parse. Returns: A ResidueRangeSet instance. Raises: ValueError: If the string is empty, contains empty parts after splitting by comma, or if any individual range part is invalid according to ResidueRange.from_string. \"\"\" if not string : raise ValueError ( \"Input string for ResidueRangeSet cannot be empty.\" ) parts = string . split ( \",\" ) ranges = [] for part in parts : stripped_part = part . strip () if not stripped_part : # Handle cases like \"A:1-5,,B:6-10\" or leading/trailing commas raise ValueError ( f \"Empty range part found in string: ' { string } ' after splitting by comma.\" ) try : # Leverage ResidueRange's parsing and validation ranges . append ( ResidueRange . from_string ( stripped_part )) except ValueError as e : # Re-raise with context about which part failed raise ValueError ( f \"Error parsing range part ' { stripped_part } ' in ' { string } ': { e } \" ) from e if not ranges : # This case might be redundant if empty string/parts are caught above, # but kept for robustness, e.g., if string only contains commas/whitespace. raise ValueError ( f \"No valid residue ranges found in string: ' { string } '.\" ) return ResidueRangeSet ( ranges )","title":"from_string"},{"location":"api/core/#flatprot.core.coordinates.ResidueRangeSet.is_adjacent_to","text":"Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Parameters: other ( Union [ ResidueRangeSet , ResidueRange , ResidueCoordinate ] ) \u2013 The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool ( bool ) \u2013 True if the range sets are adjacent, False otherwise. Raises: TypeError \u2013 If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Source code in src/flatprot/core/coordinates.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 def is_adjacent_to ( self , other : Union [ \"ResidueRangeSet\" , ResidueRange , ResidueCoordinate ] ) -> bool : \"\"\"Check if this range set is adjacent to another range set, range, or coordinate. Two range sets are considered adjacent if any range in one set is adjacent to any range in the other set. Ranges are adjacent if they are in the same chain and one range's end is exactly one residue before the other range's start, or vice versa. Args: other: The other object to check adjacency with. Can be a ResidueRangeSet, ResidueRange, or ResidueCoordinate. Returns: bool: True if the range sets are adjacent, False otherwise. Raises: TypeError: If other is not a ResidueRangeSet, ResidueRange, or ResidueCoordinate. \"\"\" if isinstance ( other , ResidueRangeSet ): # Check each pair of ranges from both sets for range1 in self . ranges : for range2 in other . ranges : if range1 . is_adjacent_to ( range2 ): return True elif isinstance ( other , ( ResidueRange , ResidueCoordinate )): # Convert the single range to a set and check adjacency for range1 in self . ranges : if range1 . is_adjacent_to ( other ): return True else : raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return False options: show_root_heading: true members_order: source","title":"is_adjacent_to"},{"location":"api/core/#core-errors","text":"","title":"Core Errors"},{"location":"api/core/#flatprot.core.errors.CoordinateCalculationError","text":"Bases: CoordinateError Error raised when calculation of display coordinates fails (e.g., insufficient points). Source code in src/flatprot/core/errors.py 20 21 22 23 24 class CoordinateCalculationError ( CoordinateError ): \"\"\"Error raised when calculation of display coordinates fails (e.g., insufficient points).\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message )","title":"CoordinateCalculationError"},{"location":"api/core/#flatprot.core.errors.CoordinateError","text":"Bases: FlatProtError Error related to coordinate management. Source code in src/flatprot/core/errors.py 13 14 15 16 17 class CoordinateError ( FlatProtError ): \"\"\"Error related to coordinate management.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message )","title":"CoordinateError"},{"location":"api/core/#flatprot.core.errors.FlatProtError","text":"Bases: Exception Base exception class for FlatProt CLI errors. This class is used as the base for all custom exceptions raised by the CLI. It provides a consistent interface for error handling and formatting. Source code in src/flatprot/core/errors.py 1 2 3 4 5 6 7 8 9 10 class FlatProtError ( Exception ): \"\"\"Base exception class for FlatProt CLI errors. This class is used as the base for all custom exceptions raised by the CLI. It provides a consistent interface for error handling and formatting. \"\"\" def __init__ ( self , message : str ): self . message = message super () . __init__ ( self . message ) options: show_root_heading: true members_order: source","title":"FlatProtError"},{"location":"api/core/#logger","text":"Logging utilities for FlatProt.","title":"Logger"},{"location":"api/core/#flatprot.core.logger.getLogger","text":"Get a configured logger with the given name. Parameters: name ( str , default: __app_name__ ) \u2013 Logger name (defaults to \"flatprot\") Returns: Logger \u2013 Configured logging.Logger instance Source code in src/flatprot/core/logger.py 10 11 12 13 14 15 16 17 18 19 20 21 def getLogger ( name : str = __app_name__ ) -> logging . Logger : \"\"\"Get a configured logger with the given name. Args: name: Logger name (defaults to \"flatprot\") Returns: Configured logging.Logger instance \"\"\" # Get the logger logger = logging . getLogger ( name ) return logger options: show_root_heading: true members_order: source","title":"getLogger"},{"location":"api/io/","text":"Input/Output API This section documents the components responsible for handling file input and output in FlatProt, including parsing structure files and configuration files (styles, annotations). IO Concept The IO module acts as the interface between FlatProt's internal data structures and external files. Its primary responsibilities are: Structure Parsing: Reading 3D coordinates, sequence information, and potentially secondary structure assignments from standard formats like PDB and mmCIF. This often involves leveraging libraries like Gemmi (e.g., via GemmiStructureParser ). Configuration Parsing: Reading and validating configuration files written in TOML format, specifically for custom styles ( StyleParser ) and annotations ( AnnotationParser ). These parsers translate the TOML definitions into structured Pydantic models used by the Scene and Rendering systems. Validation: Performing basic checks on input files (e.g., existence, basic format validation) before attempting full parsing. Error Handling: Defining specific exception types related to file reading, parsing, and validation errors. Structure Parser Handles reading and parsing protein structure files (PDB, mmCIF). Bases: StructureParser Source code in src/flatprot/io/structure_gemmi_adapter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class GemmiStructureParser ( StructureParser ): def parse_structure ( self , structure_file : Path , secondary_structure_file : Optional [ Path ] = None ) -> Structure : \"\"\"Main entry point for structure parsing\"\"\" # 1. Parse structure structure = self . _parse_structure_file ( structure_file ) # 2. Process each chain chains = [] for chain in structure [ 0 ]: # Extract basic chain data chain_data = self . _parse_chain_data ( chain ) # Get secondary structure ss_regions = self . _get_secondary_structure ( structure , secondary_structure_file ) chain_obj = Chain ( chain . name , ** chain_data ) for region in ss_regions : chain_obj . add_secondary_structure ( region [ 0 ], region [ 1 ], region [ 2 ], allow_missing_residues = True ) chains . append ( chain_obj ) # Assign structure ID from filename stem structure_id = structure_file . stem return Structure ( chains , id = structure_id ) def _parse_structure_file ( self , structure_file : Path ) -> gemmi . Structure : \"\"\"Parse structure from file using gemmi\"\"\" structure = gemmi . read_structure ( str ( structure_file )) return structure def _parse_chain_data ( self , chain : gemmi . Chain ) -> dict : \"\"\"Extract basic chain data using gemmi\"\"\" residue_indices = [] residue_names = [] coordinates = [] def get_ca_coordinates ( residue : gemmi . Residue ) -> np . ndarray : for atom in residue : if atom . name == \"CA\" : return np . array ([ atom . pos . x , atom . pos . y , atom . pos . z ]) return None for residue in chain : coordinate = get_ca_coordinates ( residue ) if coordinate is not None : coordinates . append ( coordinate ) residue_indices . append ( residue . seqid . num ) residue = gemmi . find_tabulated_residue ( residue . name ) . one_letter_code residue = \"X\" if not residue . isupper () else residue residue_names . append ( ResidueType ( residue )) assert len ( residue_indices ) == len ( coordinates ) assert len ( residue_indices ) == len ( residue_names ) return { \"index\" : residue_indices , \"residues\" : residue_names , \"coordinates\" : np . array ( coordinates , dtype = np . float32 ), } def _get_secondary_structure ( self , structure : gemmi . Structure , secondary_structure_file : Optional [ Path ] = None , ) -> list [ tuple [ SecondaryStructureType , int , int ]]: if secondary_structure_file is not None : return parse_dssp ( secondary_structure_file ) else : return self . _get_secondary_structure_cif ( structure ) def _get_secondary_structure_cif ( self , structure : gemmi . Structure ) -> list [ tuple [ SecondaryStructureType , int , int ]]: \"\"\"Get secondary structure from gemmi structure\"\"\" ss_regions = [] # Extract helices and sheets from gemmi structure for helix in structure . helices : start = helix . start . res_id . seqid . num end = helix . end . res_id . seqid . num ss_regions . append (( SecondaryStructureType . HELIX , start , end )) for sheet in structure . sheets : for strand in sheet . strands : start = strand . start . res_id . seqid . num end = strand . end . res_id . seqid . num ss_regions . append (( SecondaryStructureType . SHEET , start , end )) return ss_regions def save_structure ( self , structure : Structure , output_file : Path , separate_chains = False ) -> None : \"\"\"Save structure using gemmi\"\"\" gemmi_structure = gemmi . Structure () model = gemmi . Model ( \"1\" ) for chain_id , chain_data in structure . items (): chain = gemmi . Chain ( chain_id ) for idx , ( residue_idx , residue , coord ) in enumerate ( zip ( chain_data . index , chain_data . residues , chain_data . coordinates ) ): gemmi_res = gemmi . Residue () gemmi_res . name = residue . name gemmi_res . seqid = gemmi . SeqId ( residue_idx ) ca = gemmi . Atom () ca . name = \"CA\" ca . pos = gemmi . Position ( * coord ) ca . element = gemmi . Element ( \"C\" ) gemmi_res . add_atom ( ca ) chain . add_residue ( gemmi_res ) model . add_chain ( chain ) gemmi_structure . add_model ( model ) gemmi_structure . write_pdb ( str ( output_file )) parse_structure ( structure_file , secondary_structure_file = None ) Main entry point for structure parsing Source code in src/flatprot/io/structure_gemmi_adapter.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def parse_structure ( self , structure_file : Path , secondary_structure_file : Optional [ Path ] = None ) -> Structure : \"\"\"Main entry point for structure parsing\"\"\" # 1. Parse structure structure = self . _parse_structure_file ( structure_file ) # 2. Process each chain chains = [] for chain in structure [ 0 ]: # Extract basic chain data chain_data = self . _parse_chain_data ( chain ) # Get secondary structure ss_regions = self . _get_secondary_structure ( structure , secondary_structure_file ) chain_obj = Chain ( chain . name , ** chain_data ) for region in ss_regions : chain_obj . add_secondary_structure ( region [ 0 ], region [ 1 ], region [ 2 ], allow_missing_residues = True ) chains . append ( chain_obj ) # Assign structure ID from filename stem structure_id = structure_file . stem return Structure ( chains , id = structure_id ) save_structure ( structure , output_file , separate_chains = False ) Save structure using gemmi Source code in src/flatprot/io/structure_gemmi_adapter.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def save_structure ( self , structure : Structure , output_file : Path , separate_chains = False ) -> None : \"\"\"Save structure using gemmi\"\"\" gemmi_structure = gemmi . Structure () model = gemmi . Model ( \"1\" ) for chain_id , chain_data in structure . items (): chain = gemmi . Chain ( chain_id ) for idx , ( residue_idx , residue , coord ) in enumerate ( zip ( chain_data . index , chain_data . residues , chain_data . coordinates ) ): gemmi_res = gemmi . Residue () gemmi_res . name = residue . name gemmi_res . seqid = gemmi . SeqId ( residue_idx ) ca = gemmi . Atom () ca . name = \"CA\" ca . pos = gemmi . Position ( * coord ) ca . element = gemmi . Element ( \"C\" ) gemmi_res . add_atom ( ca ) chain . add_residue ( gemmi_res ) model . add_chain ( chain ) gemmi_structure . add_model ( model ) gemmi_structure . write_pdb ( str ( output_file )) options: show_root_heading: true members_order: source Style Parser Parses TOML files defining custom styles for structure elements. Parser for TOML style files focusing on structure elements and connections. Source code in src/flatprot/io/styles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class StyleParser : \"\"\"Parser for TOML style files focusing on structure elements and connections.\"\"\" # Define known sections and their corresponding Pydantic models KNOWN_SECTIONS = { \"helix\" : HelixStyle , \"sheet\" : SheetStyle , \"coil\" : CoilStyle , \"connection\" : ConnectionStyle , \"position_annotation\" : PositionAnnotationStyle , } def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the style parser. Args: file_path: Path to the TOML style file Raises: StyleFileNotFoundError: If the file doesn't exist InvalidTomlError: If the TOML is malformed \"\"\" self . file_path = Path ( file_path ) if not self . file_path . exists (): raise StyleFileNotFoundError ( f \"Style file not found: { self . file_path } \" ) try : with open ( self . file_path , \"r\" ) as f : self . raw_style_data = toml . load ( f ) except toml . TomlDecodeError as e : raise InvalidTomlError ( f \"Invalid TOML format: { e } \" ) self . _validate_structure () def _validate_structure ( self ) -> None : \"\"\"Checks for unknown top-level sections in the style file.\"\"\" unknown_sections = [ section for section in self . raw_style_data if section not in self . KNOWN_SECTIONS ] if unknown_sections : # This is just a warning, not an error print ( f \"Warning: Unknown style sections found and ignored: { ', ' . join ( unknown_sections ) } \" ) def parse ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parses the known sections from the TOML file into Pydantic style objects. Returns: A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their corresponding Pydantic style model instances. Raises: StyleValidationError: If any style section has invalid data according to its Pydantic model. StyleParsingError: For other general parsing issues. \"\"\" parsed_styles : Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ] ] = {} for section_name , StyleModelClass in self . KNOWN_SECTIONS . items (): section_data = self . raw_style_data . get ( section_name ) if section_data is None : # Section not present in the file, skip it (will use default later) continue if not isinstance ( section_data , dict ): raise StyleValidationError ( f \"Invalid format for section ' { section_name } '. Expected a table (dictionary), got { type ( section_data ) . __name__ } .\" ) try : # Pydantic handles validation and type conversion (including Color) style_instance = StyleModelClass ( ** section_data ) parsed_styles [ section_name ] = style_instance except ValidationError as e : # Provide more context for validation errors error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise StyleValidationError ( f \"Invalid style definition in section ' { section_name } ': \\\\ n\" + \" \\\\ n\" . join ( error_msgs ) ) from e except Exception as e : # Catch other potential errors during instantiation raise StyleParsingError ( f \"Error processing style section ' { section_name } ': { e } \" ) from e return parsed_styles def get_element_styles ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parse and return the element styles defined in the TOML file. Returns: Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their parsed Pydantic style objects. Sections not found in the TOML file will be omitted from the dictionary. Raises: StyleValidationError: If validation of any section fails. StyleParsingError: For general parsing issues. \"\"\" try : return self . parse () except ( StyleValidationError , StyleParsingError ): # Re-raise exceptions from parse raise except Exception as e : # Catch unexpected errors during the overall process raise StyleParsingError ( f \"Failed to get element styles: { e } \" ) from e def get_raw_data ( self ) -> Dict [ str , Any ]: \"\"\"Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict containing the raw parsed TOML data. \"\"\" return self . raw_style_data __init__ ( file_path ) Initialize the style parser. Parameters: file_path ( Union [ str , Path ] ) \u2013 Path to the TOML style file Raises: StyleFileNotFoundError \u2013 If the file doesn't exist InvalidTomlError \u2013 If the TOML is malformed Source code in src/flatprot/io/styles.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the style parser. Args: file_path: Path to the TOML style file Raises: StyleFileNotFoundError: If the file doesn't exist InvalidTomlError: If the TOML is malformed \"\"\" self . file_path = Path ( file_path ) if not self . file_path . exists (): raise StyleFileNotFoundError ( f \"Style file not found: { self . file_path } \" ) try : with open ( self . file_path , \"r\" ) as f : self . raw_style_data = toml . load ( f ) except toml . TomlDecodeError as e : raise InvalidTomlError ( f \"Invalid TOML format: { e } \" ) self . _validate_structure () get_element_styles () Parse and return the element styles defined in the TOML file. Returns: Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 to their parsed Pydantic style objects. Sections not found in the TOML Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 file will be omitted from the dictionary. Raises: StyleValidationError \u2013 If validation of any section fails. StyleParsingError \u2013 For general parsing issues. Source code in src/flatprot/io/styles.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_element_styles ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parse and return the element styles defined in the TOML file. Returns: Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their parsed Pydantic style objects. Sections not found in the TOML file will be omitted from the dictionary. Raises: StyleValidationError: If validation of any section fails. StyleParsingError: For general parsing issues. \"\"\" try : return self . parse () except ( StyleValidationError , StyleParsingError ): # Re-raise exceptions from parse raise except Exception as e : # Catch unexpected errors during the overall process raise StyleParsingError ( f \"Failed to get element styles: { e } \" ) from e get_raw_data () Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict [ str , Any ] \u2013 Dict containing the raw parsed TOML data. Source code in src/flatprot/io/styles.py 152 153 154 155 156 157 158 def get_raw_data ( self ) -> Dict [ str , Any ]: \"\"\"Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict containing the raw parsed TOML data. \"\"\" return self . raw_style_data parse () Parses the known sections from the TOML file into Pydantic style objects. Returns: Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 to their corresponding Pydantic style model instances. Raises: StyleValidationError \u2013 If any style section has invalid data according to its Pydantic model. StyleParsingError \u2013 For other general parsing issues. Source code in src/flatprot/io/styles.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def parse ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parses the known sections from the TOML file into Pydantic style objects. Returns: A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their corresponding Pydantic style model instances. Raises: StyleValidationError: If any style section has invalid data according to its Pydantic model. StyleParsingError: For other general parsing issues. \"\"\" parsed_styles : Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ] ] = {} for section_name , StyleModelClass in self . KNOWN_SECTIONS . items (): section_data = self . raw_style_data . get ( section_name ) if section_data is None : # Section not present in the file, skip it (will use default later) continue if not isinstance ( section_data , dict ): raise StyleValidationError ( f \"Invalid format for section ' { section_name } '. Expected a table (dictionary), got { type ( section_data ) . __name__ } .\" ) try : # Pydantic handles validation and type conversion (including Color) style_instance = StyleModelClass ( ** section_data ) parsed_styles [ section_name ] = style_instance except ValidationError as e : # Provide more context for validation errors error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise StyleValidationError ( f \"Invalid style definition in section ' { section_name } ': \\\\ n\" + \" \\\\ n\" . join ( error_msgs ) ) from e except Exception as e : # Catch other potential errors during instantiation raise StyleParsingError ( f \"Error processing style section ' { section_name } ': { e } \" ) from e return parsed_styles options: show_root_heading: true members_order: source Annotation Parser Parses TOML files defining annotations (points, lines, areas) and their inline styles. Parses annotation files in TOML format with optional inline styles. Creates fully initialized PointAnnotation, LineAnnotation, or AreaAnnotation objects from the flatprot.scene.annotations module. Source code in src/flatprot/io/annotations.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class AnnotationParser : \"\"\"Parses annotation files in TOML format with optional inline styles. Creates fully initialized PointAnnotation, LineAnnotation, or AreaAnnotation objects from the `flatprot.scene.annotations` module. \"\"\" def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the parser with the path to the annotation file. Args: file_path: Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError: If the file does not exist. \"\"\" self . file_path = Path ( file_path ) # Check file existence if not self . file_path . exists (): raise AnnotationFileNotFoundError ( str ( self . file_path )) # Map annotation type strings to their respective parsing methods self . _parsers : Dict [ str , Callable [[ Dict [ str , Any ], str , str ], AnnotationObjectType ] ] = { \"point\" : self . _parse_point_annotation , \"line\" : self . _parse_line_annotation , \"area\" : self . _parse_area_annotation , } def _parse_inline_style ( self , style_dict : Optional [ Dict [ str , Any ]], StyleModel : Type [ BaseAnnotationStyle ], context : str , ) -> Optional [ BaseAnnotationStyle ]: \"\"\"Parses the inline style dictionary using the provided Pydantic model.\"\"\" if style_dict is None : return None if not isinstance ( style_dict , dict ): raise MalformedAnnotationError ( context , f \"'style' entry must be a table (dictionary), got { type ( style_dict ) . __name__ } .\" , ) try : style_instance = StyleModel . model_validate ( style_dict ) return style_instance except ValidationError as e : error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise MalformedAnnotationError ( context , \"Invalid style definition: \\n \" + \" \\n \" . join ( error_msgs ) ) from e except Exception as e : raise AnnotationError ( f \" { context } : Error creating style object: { e } \" ) from e def _parse_point_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> PointAnnotation : \"\"\"Parses a point annotation entry.\"\"\" label = anno_data . get ( \"label\" ) index_str = anno_data . get ( \"index\" ) style_dict = anno_data . get ( \"style\" ) if index_str is None : raise MalformedAnnotationError ( context , \"Missing 'index' field for 'point' annotation.\" ) target_coord = _parse_residue_coordinate ( index_str , context ) style_instance = self . _parse_inline_style ( style_dict , PointAnnotationStyle , context ) return PointAnnotation ( id = anno_id , target = target_coord , style = cast ( Optional [ PointAnnotationStyle ], style_instance ), label = label , ) def _parse_line_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> LineAnnotation : \"\"\"Parses a line annotation entry.\"\"\" label = anno_data . get ( \"label\" ) indices_list = anno_data . get ( \"indices\" ) style_dict = anno_data . get ( \"style\" ) if not isinstance ( indices_list , list ) or len ( indices_list ) != 2 : raise MalformedAnnotationError ( context , \"Field 'indices' for 'line' annotation must be a list of exactly two coordinate strings (e.g., ['A:10', 'A:20']).\" , ) target_coords = [ _parse_residue_coordinate ( s , f \" { context } , index { j + 1 } \" ) for j , s in enumerate ( indices_list ) ] style_instance = self . _parse_inline_style ( style_dict , LineAnnotationStyle , context ) return LineAnnotation ( id = anno_id , start_coordinate = target_coords [ 0 ], end_coordinate = target_coords [ 1 ], style = cast ( Optional [ LineAnnotationStyle ], style_instance ), # Cast for type checker label = label , ) def _parse_area_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> AreaAnnotation : \"\"\"Parses an area annotation entry.\"\"\" label = anno_data . get ( \"label\" ) range_str = anno_data . get ( \"range\" ) style_dict = anno_data . get ( \"style\" ) # AreaAnnotation currently only supports range, not list of indices if range_str is None : raise MalformedAnnotationError ( context , \"Missing 'range' field for 'area' annotation.\" ) target_range = _parse_residue_range ( range_str , context ) target_range_set = ResidueRangeSet ([ target_range ]) style_instance = self . _parse_inline_style ( style_dict , AreaAnnotationStyle , context ) return AreaAnnotation ( id = anno_id , residue_range_set = target_range_set , style = cast ( Optional [ AreaAnnotationStyle ], style_instance ), # Cast for type checker label = label , ) def parse ( self ) -> List [ AnnotationObjectType ]: \"\"\"Parse the annotation file and create annotation objects. Returns: List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError: If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError: For other general parsing issues. \"\"\" try : # Parse TOML content raw_data = toml . load ( self . file_path ) except toml . TomlDecodeError as e : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , f \"Invalid TOML syntax: { str ( e ) } \" ) from e except Exception as e : raise AnnotationError ( f \"Error loading TOML file { self . file_path } : { e } \" ) from e if not isinstance ( raw_data , dict ) or \"annotations\" not in raw_data : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"Missing top-level 'annotations' list.\" ) if not isinstance ( raw_data [ \"annotations\" ], list ): raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"'annotations' key must contain a list.\" ) parsed_annotations : List [ AnnotationObjectType ] = [] for i , anno_data in enumerate ( raw_data [ \"annotations\" ]): context = f \"File: { self . file_path } , Annotation # { i + 1 } \" try : if not isinstance ( anno_data , dict ): raise MalformedAnnotationError ( context , \"Annotation entry must be a table (dictionary).\" ) anno_type = anno_data . get ( \"type\" ) if not isinstance ( anno_type , str ): raise MalformedAnnotationError ( context , f \"Missing or invalid 'type' field. Expected a string, got { type ( anno_type ) . __name__ } .\" , ) # Look up the parser function based on the type parser_func = self . _parsers . get ( anno_type ) if parser_func is None : raise MalformedAnnotationError ( context , f \"Unknown annotation 'type': ' { anno_type } '. Must be one of { list ( self . _parsers . keys ()) } .\" , ) # Check for optional user-provided ID provided_id = anno_data . get ( \"id\" ) if provided_id is not None : if isinstance ( provided_id , str ): anno_id = provided_id else : raise MalformedAnnotationError ( context , f \"Optional 'id' field must be a string, got { type ( provided_id ) . __name__ } .\" , ) else : # Generate ID if not provided anno_id = f \"annotation_ { self . file_path . stem } _ { i } _ { anno_type } \" # Call the specific parser method annotation_object = parser_func ( anno_data , anno_id , context ) parsed_annotations . append ( annotation_object ) except ( MalformedAnnotationError , AnnotationError ) as e : raise e except Exception as e : raise AnnotationError ( f \"Unexpected error processing annotation in { context } : { e } \" ) from e return parsed_annotations __init__ ( file_path ) Initialize the parser with the path to the annotation file. Parameters: file_path ( Union [ str , Path ] ) \u2013 Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError \u2013 If the file does not exist. Source code in src/flatprot/io/annotations.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the parser with the path to the annotation file. Args: file_path: Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError: If the file does not exist. \"\"\" self . file_path = Path ( file_path ) # Check file existence if not self . file_path . exists (): raise AnnotationFileNotFoundError ( str ( self . file_path )) # Map annotation type strings to their respective parsing methods self . _parsers : Dict [ str , Callable [[ Dict [ str , Any ], str , str ], AnnotationObjectType ] ] = { \"point\" : self . _parse_point_annotation , \"line\" : self . _parse_line_annotation , \"area\" : self . _parse_area_annotation , } parse () Parse the annotation file and create annotation objects. Returns: List [ AnnotationObjectType ] \u2013 List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError \u2013 If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError \u2013 For other general parsing issues. Source code in src/flatprot/io/annotations.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse ( self ) -> List [ AnnotationObjectType ]: \"\"\"Parse the annotation file and create annotation objects. Returns: List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError: If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError: For other general parsing issues. \"\"\" try : # Parse TOML content raw_data = toml . load ( self . file_path ) except toml . TomlDecodeError as e : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , f \"Invalid TOML syntax: { str ( e ) } \" ) from e except Exception as e : raise AnnotationError ( f \"Error loading TOML file { self . file_path } : { e } \" ) from e if not isinstance ( raw_data , dict ) or \"annotations\" not in raw_data : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"Missing top-level 'annotations' list.\" ) if not isinstance ( raw_data [ \"annotations\" ], list ): raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"'annotations' key must contain a list.\" ) parsed_annotations : List [ AnnotationObjectType ] = [] for i , anno_data in enumerate ( raw_data [ \"annotations\" ]): context = f \"File: { self . file_path } , Annotation # { i + 1 } \" try : if not isinstance ( anno_data , dict ): raise MalformedAnnotationError ( context , \"Annotation entry must be a table (dictionary).\" ) anno_type = anno_data . get ( \"type\" ) if not isinstance ( anno_type , str ): raise MalformedAnnotationError ( context , f \"Missing or invalid 'type' field. Expected a string, got { type ( anno_type ) . __name__ } .\" , ) # Look up the parser function based on the type parser_func = self . _parsers . get ( anno_type ) if parser_func is None : raise MalformedAnnotationError ( context , f \"Unknown annotation 'type': ' { anno_type } '. Must be one of { list ( self . _parsers . keys ()) } .\" , ) # Check for optional user-provided ID provided_id = anno_data . get ( \"id\" ) if provided_id is not None : if isinstance ( provided_id , str ): anno_id = provided_id else : raise MalformedAnnotationError ( context , f \"Optional 'id' field must be a string, got { type ( provided_id ) . __name__ } .\" , ) else : # Generate ID if not provided anno_id = f \"annotation_ { self . file_path . stem } _ { i } _ { anno_type } \" # Call the specific parser method annotation_object = parser_func ( anno_data , anno_id , context ) parsed_annotations . append ( annotation_object ) except ( MalformedAnnotationError , AnnotationError ) as e : raise e except Exception as e : raise AnnotationError ( f \"Unexpected error processing annotation in { context } : { e } \" ) from e return parsed_annotations options: show_root_heading: true members_order: source File Validation Utility functions for validating input files. Validate that the file exists and is a valid PDB or CIF format. Parameters: path ( Path ) \u2013 Path to the structure file Raises: StructureFileNotFoundError \u2013 If the file does not exist InvalidStructureError \u2013 If the file is not a valid PDB or CIF format Source code in src/flatprot/io/structure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def validate_structure_file ( path : Path ) -> None : \"\"\"Validate that the file exists and is a valid PDB or CIF format. Args: path: Path to the structure file Raises: StructureFileNotFoundError: If the file does not exist InvalidStructureError: If the file is not a valid PDB or CIF format \"\"\" # Check file existence if not path . exists (): raise StructureFileNotFoundError ( str ( path )) # Check file extension suffix = path . suffix . lower () if suffix not in [ \".pdb\" , \".cif\" , \".mmcif\" , \".ent\" ]: raise InvalidStructureError ( str ( path ), \"PDB or CIF\" , \"File does not have a recognized structure file extension (.pdb, .cif, .mmcif, .ent)\" , ) # Basic content validation try : with open ( path , \"r\" ) as f : content = f . read ( 1000 ) # Read first 1000 bytes for quick check # Basic check for PDB format if suffix in [ \".pdb\" , \".ent\" ]: if not ( \"ATOM\" in content or \"HETATM\" in content or \"HEADER\" in content ): raise InvalidStructureError ( str ( path ), \"PDB\" , \"File does not contain required PDB records (ATOM, HETATM, or HEADER)\" , ) # Basic check for mmCIF format if suffix in [ \".cif\" , \".mmcif\" ]: if not ( \"_atom_site.\" in content or \"loop_\" in content or \"data_\" in content ): raise InvalidStructureError ( str ( path ), \"CIF\" , \"File does not contain required CIF categories (_atom_site, loop_, or data_)\" , ) except UnicodeDecodeError : raise InvalidStructureError ( str ( path ), \"PDB or CIF\" , \"File contains invalid characters and is not a valid text file\" , ) options: show_root_heading: true Validate that optional files exist if specified. Parameters: file_paths ( List [ Optional [ Path ]] ) \u2013 List of file paths to check (can include None values) Raises: FileNotFoundError \u2013 If any specified file does not exist Source code in src/flatprot/io/__init__.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def validate_optional_files ( file_paths : List [ Optional [ Path ]], ) -> None : \"\"\"Validate that optional files exist if specified. Args: file_paths: List of file paths to check (can include None values) Raises: FileNotFoundError: If any specified file does not exist \"\"\" for path in file_paths : if path and not path . exists (): raise FileNotFoundError ( str ( path )) options: show_root_heading: true IO Errors Exceptions specific to file input, output, parsing, and validation. Error classes for the FlatProt IO module. AnnotationError Bases: IOError Base class for annotation-related errors. Source code in src/flatprot/io/errors.py 90 91 92 93 94 class AnnotationError ( IOError ): \"\"\"Base class for annotation-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Annotation error: { message } \" ) AnnotationFileError Bases: AnnotationError Exception raised when there's an issue with an annotation file. Source code in src/flatprot/io/errors.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class AnnotationFileError ( AnnotationError ): \"\"\"Exception raised when there's an issue with an annotation file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid annotation file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = ( \" \\n Annotation files should be in TOML format with an 'annotations' list.\" ) suggestion += \" \\n Example annotation format: \\n \" suggestion += \"\"\" [[annotations]] type = \"point\" label = \"Active site\" chain = \"A\" indices = 123 color = \"#FF0000\" \"\"\" super () . __init__ ( f \" { message }{ suggestion } \" ) AnnotationFileNotFoundError Bases: AnnotationError Exception raised when an annotation file is not found. Source code in src/flatprot/io/errors.py 97 98 99 100 101 102 class AnnotationFileNotFoundError ( AnnotationError ): \"\"\"Exception raised when an annotation file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Annotation file not found: { file_path } \" super () . __init__ ( message ) FileError Bases: IOError Base class for file-related errors. Source code in src/flatprot/io/errors.py 22 23 24 25 26 class FileError ( IOError ): \"\"\"Base class for file-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message ) FileNotFoundError Bases: FileError Exception raised when a required file is not found. Source code in src/flatprot/io/errors.py 29 30 31 32 33 34 35 36 class FileNotFoundError ( FileError ): \"\"\"Exception raised when a required file is not found.\"\"\" def __init__ ( self , file_path : str ): self . file_path = file_path message = f \"File not found: { file_path } \" suggestion = \"Please check that the file exists and the path is correct.\" super () . __init__ ( f \" { message } \\n { suggestion } \" ) IOError Bases: FlatProtError Base class for all IO-related errors in FlatProt. Source code in src/flatprot/io/errors.py 15 16 17 18 19 class IOError ( FlatProtError ): \"\"\"Base class for all IO-related errors in FlatProt.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"IO error: { message } \" ) InvalidColorError Bases: StyleError Exception raised when an invalid color is specified. Source code in src/flatprot/io/errors.py 236 237 238 239 240 241 242 243 244 245 246 class InvalidColorError ( StyleError ): \"\"\"Exception raised when an invalid color is specified.\"\"\" def __init__ ( self , color_value : str , element_type : str ): self . color_value = color_value self . element_type = element_type message = f \"Invalid color value ' { color_value } ' for { element_type } .\" suggestion = \" \\n Colors should be specified as hex (#RRGGBB), RGB (rgb(r,g,b)), or named colors.\" super () . __init__ ( f \" { message }{ suggestion } \" ) InvalidFieldTypeError Bases: AnnotationError Exception raised when a field has an invalid type. Source code in src/flatprot/io/errors.py 121 122 123 124 125 126 127 128 129 130 131 132 class InvalidFieldTypeError ( AnnotationError ): \"\"\"Exception raised when a field has an invalid type.\"\"\" def __init__ ( self , annotation_type : str , field_name : str , expected_type : str , annotation_index : int , ): message = f \"Invalid type for field ' { field_name } ' in { annotation_type } annotation at index { annotation_index } . Expected { expected_type } .\" super () . __init__ ( message ) InvalidFileFormatError Bases: FileError Exception raised when a file has an invalid format. Source code in src/flatprot/io/errors.py 39 40 41 42 43 44 45 46 class InvalidFileFormatError ( FileError ): \"\"\"Exception raised when a file has an invalid format.\"\"\" def __init__ ( self , file_path : str , expected_format : str ): self . file_path = file_path self . expected_format = expected_format message = f \"Invalid file format for { file_path } . Expected { expected_format } .\" super () . __init__ ( message ) InvalidMatrixDimensionsError Bases: MatrixError Error raised when a matrix has invalid dimensions. Source code in src/flatprot/io/errors.py 265 266 267 268 class InvalidMatrixDimensionsError ( MatrixError ): \"\"\"Error raised when a matrix has invalid dimensions.\"\"\" pass InvalidMatrixError Bases: MatrixError Exception raised when a matrix file has an invalid format. Source code in src/flatprot/io/errors.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class InvalidMatrixError ( MatrixError ): \"\"\"Exception raised when a matrix file has an invalid format.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid matrix file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Matrix files should be NumPy .npy files containing a 4x4 transformation matrix.\" suggestion += \" \\n Alternatively, you can use separate .npy files for rotation (3x3) and translation (3x1).\" super () . __init__ ( f \" { message }{ suggestion } \" ) InvalidMatrixFormatError Bases: MatrixError Error raised when a matrix file has an invalid format. Source code in src/flatprot/io/errors.py 271 272 273 274 class InvalidMatrixFormatError ( MatrixError ): \"\"\"Error raised when a matrix file has an invalid format.\"\"\" pass InvalidReferenceError Bases: AnnotationError Exception raised when an annotation references a nonexistent chain or residue. Source code in src/flatprot/io/errors.py 135 136 137 138 139 140 141 142 143 144 145 146 class InvalidReferenceError ( AnnotationError ): \"\"\"Exception raised when an annotation references a nonexistent chain or residue.\"\"\" def __init__ ( self , annotation_type : str , reference_type : str , reference : str , annotation_index : int , ): message = f \"Invalid { reference_type } reference ' { reference } ' in { annotation_type } annotation at index { annotation_index } .\" super () . __init__ ( message ) InvalidStructureError Bases: StructureError Exception raised when a structure file has an invalid format. Source code in src/flatprot/io/errors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class InvalidStructureError ( StructureError ): \"\"\"Exception raised when a structure file has an invalid format.\"\"\" def __init__ ( self , file_path : str , expected_format : str , details : Optional [ str ] = None ): self . file_path = file_path self . expected_format = expected_format self . details = details message = f \"Invalid { expected_format } file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = f \" \\n Please ensure the file is a valid { expected_format } format. \" if expected_format == \"PDB\" : suggestion += \"PDB files should contain ATOM, HETATM, or HEADER records.\" elif expected_format == \"CIF\" : suggestion += \"CIF files should contain _atom_site categories, loop_, or data_ sections.\" super () . __init__ ( f \" { message } \\n { suggestion } \" ) InvalidTomlError Bases: StyleParsingError Error for malformed TOML files. Source code in src/flatprot/io/errors.py 198 199 200 201 class InvalidTomlError ( StyleParsingError ): \"\"\"Error for malformed TOML files.\"\"\" pass MalformedAnnotationError Bases: AnnotationError Exception raised when an annotation file has an invalid format. Source code in src/flatprot/io/errors.py 105 106 107 108 109 110 class MalformedAnnotationError ( AnnotationError ): \"\"\"Exception raised when an annotation file has an invalid format.\"\"\" def __init__ ( self , file_path : str , details : str ): message = f \"Malformed annotation file: { file_path } \\n { details } \" super () . __init__ ( message ) MatrixError Bases: IOError Base class for matrix-related errors. Source code in src/flatprot/io/errors.py 250 251 252 253 254 class MatrixError ( IOError ): \"\"\"Base class for matrix-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Matrix error: { message } \" ) MatrixFileError Bases: MatrixError Error raised when a matrix file can't be read. Source code in src/flatprot/io/errors.py 277 278 279 280 class MatrixFileError ( MatrixError ): \"\"\"Error raised when a matrix file can't be read.\"\"\" pass MatrixFileNotFoundError Bases: MatrixError Exception raised when a matrix file is not found. Source code in src/flatprot/io/errors.py 257 258 259 260 261 262 class MatrixFileNotFoundError ( MatrixError ): \"\"\"Exception raised when a matrix file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Matrix file not found: { file_path } \" super () . __init__ ( message ) MissingRequiredFieldError Bases: AnnotationError Exception raised when a required field is missing from an annotation. Source code in src/flatprot/io/errors.py 113 114 115 116 117 118 class MissingRequiredFieldError ( AnnotationError ): \"\"\"Exception raised when a required field is missing from an annotation.\"\"\" def __init__ ( self , annotation_type : str , field_name : str , annotation_index : int ): message = f \"Missing required field ' { field_name } ' for { annotation_type } annotation at index { annotation_index } \" super () . __init__ ( message ) OutputError Bases: IOError Base class for output-related errors. Source code in src/flatprot/io/errors.py 301 302 303 304 305 class OutputError ( IOError ): \"\"\"Base class for output-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Output error: { message } \" ) OutputFileError Bases: OutputError Exception raised when there's an issue with an output file. Source code in src/flatprot/io/errors.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class OutputFileError ( OutputError ): \"\"\"Exception raised when there's an issue with an output file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Error writing to output file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Please check that you have write permissions to the directory and sufficient disk space.\" super () . __init__ ( f \" { message }{ suggestion } \" ) StructureError Bases: IOError Base class for structure-related errors. Source code in src/flatprot/io/errors.py 50 51 52 53 54 class StructureError ( IOError ): \"\"\"Base class for structure-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Structure error: { message } \" ) StructureFileNotFoundError Bases: StructureError Exception raised when a structure file is not found. Source code in src/flatprot/io/errors.py 57 58 59 60 61 62 63 class StructureFileNotFoundError ( StructureError ): \"\"\"Exception raised when a structure file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Structure file not found: { file_path } \" suggestion = \"Please check that the file exists and the path is correct.\" super () . __init__ ( f \" { message } \\n { suggestion } \" ) StyleError Bases: IOError Base class for style-related errors. Source code in src/flatprot/io/errors.py 177 178 179 180 181 class StyleError ( IOError ): \"\"\"Base class for style-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Style error: { message } \" ) StyleFileError Bases: StyleError Exception raised when there's an issue with a style file. Source code in src/flatprot/io/errors.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class StyleFileError ( StyleError ): \"\"\"Exception raised when there's an issue with a style file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid style file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Style files should be in TOML format with sections for different elements.\" suggestion += \" \\n Example style format: \\n \" suggestion += \"\"\" [helix] fill_color = \"#FF0000\" stroke_color = \"#800000\" [sheet] fill_color = \"#00FF00\" stroke_color = \"#008000\" \"\"\" super () . __init__ ( f \" { message }{ suggestion } \" ) StyleFileNotFoundError Bases: StyleError Exception raised when a style file is not found. Source code in src/flatprot/io/errors.py 184 185 186 187 188 189 class StyleFileNotFoundError ( StyleError ): \"\"\"Exception raised when a style file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Style file not found: { file_path } \" super () . __init__ ( message ) StyleParsingError Bases: StyleError Base error for style parsing issues. Source code in src/flatprot/io/errors.py 192 193 194 195 class StyleParsingError ( StyleError ): \"\"\"Base error for style parsing issues.\"\"\" pass StyleValidationError Bases: StyleParsingError Error for invalid style field types or values. Source code in src/flatprot/io/errors.py 204 205 206 207 class StyleValidationError ( StyleParsingError ): \"\"\"Error for invalid style field types or values.\"\"\" pass options: show_root_heading: true","title":"IO"},{"location":"api/io/#inputoutput-api","text":"This section documents the components responsible for handling file input and output in FlatProt, including parsing structure files and configuration files (styles, annotations).","title":"Input/Output API"},{"location":"api/io/#io-concept","text":"The IO module acts as the interface between FlatProt's internal data structures and external files. Its primary responsibilities are: Structure Parsing: Reading 3D coordinates, sequence information, and potentially secondary structure assignments from standard formats like PDB and mmCIF. This often involves leveraging libraries like Gemmi (e.g., via GemmiStructureParser ). Configuration Parsing: Reading and validating configuration files written in TOML format, specifically for custom styles ( StyleParser ) and annotations ( AnnotationParser ). These parsers translate the TOML definitions into structured Pydantic models used by the Scene and Rendering systems. Validation: Performing basic checks on input files (e.g., existence, basic format validation) before attempting full parsing. Error Handling: Defining specific exception types related to file reading, parsing, and validation errors.","title":"IO Concept"},{"location":"api/io/#structure-parser","text":"Handles reading and parsing protein structure files (PDB, mmCIF). Bases: StructureParser Source code in src/flatprot/io/structure_gemmi_adapter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class GemmiStructureParser ( StructureParser ): def parse_structure ( self , structure_file : Path , secondary_structure_file : Optional [ Path ] = None ) -> Structure : \"\"\"Main entry point for structure parsing\"\"\" # 1. Parse structure structure = self . _parse_structure_file ( structure_file ) # 2. Process each chain chains = [] for chain in structure [ 0 ]: # Extract basic chain data chain_data = self . _parse_chain_data ( chain ) # Get secondary structure ss_regions = self . _get_secondary_structure ( structure , secondary_structure_file ) chain_obj = Chain ( chain . name , ** chain_data ) for region in ss_regions : chain_obj . add_secondary_structure ( region [ 0 ], region [ 1 ], region [ 2 ], allow_missing_residues = True ) chains . append ( chain_obj ) # Assign structure ID from filename stem structure_id = structure_file . stem return Structure ( chains , id = structure_id ) def _parse_structure_file ( self , structure_file : Path ) -> gemmi . Structure : \"\"\"Parse structure from file using gemmi\"\"\" structure = gemmi . read_structure ( str ( structure_file )) return structure def _parse_chain_data ( self , chain : gemmi . Chain ) -> dict : \"\"\"Extract basic chain data using gemmi\"\"\" residue_indices = [] residue_names = [] coordinates = [] def get_ca_coordinates ( residue : gemmi . Residue ) -> np . ndarray : for atom in residue : if atom . name == \"CA\" : return np . array ([ atom . pos . x , atom . pos . y , atom . pos . z ]) return None for residue in chain : coordinate = get_ca_coordinates ( residue ) if coordinate is not None : coordinates . append ( coordinate ) residue_indices . append ( residue . seqid . num ) residue = gemmi . find_tabulated_residue ( residue . name ) . one_letter_code residue = \"X\" if not residue . isupper () else residue residue_names . append ( ResidueType ( residue )) assert len ( residue_indices ) == len ( coordinates ) assert len ( residue_indices ) == len ( residue_names ) return { \"index\" : residue_indices , \"residues\" : residue_names , \"coordinates\" : np . array ( coordinates , dtype = np . float32 ), } def _get_secondary_structure ( self , structure : gemmi . Structure , secondary_structure_file : Optional [ Path ] = None , ) -> list [ tuple [ SecondaryStructureType , int , int ]]: if secondary_structure_file is not None : return parse_dssp ( secondary_structure_file ) else : return self . _get_secondary_structure_cif ( structure ) def _get_secondary_structure_cif ( self , structure : gemmi . Structure ) -> list [ tuple [ SecondaryStructureType , int , int ]]: \"\"\"Get secondary structure from gemmi structure\"\"\" ss_regions = [] # Extract helices and sheets from gemmi structure for helix in structure . helices : start = helix . start . res_id . seqid . num end = helix . end . res_id . seqid . num ss_regions . append (( SecondaryStructureType . HELIX , start , end )) for sheet in structure . sheets : for strand in sheet . strands : start = strand . start . res_id . seqid . num end = strand . end . res_id . seqid . num ss_regions . append (( SecondaryStructureType . SHEET , start , end )) return ss_regions def save_structure ( self , structure : Structure , output_file : Path , separate_chains = False ) -> None : \"\"\"Save structure using gemmi\"\"\" gemmi_structure = gemmi . Structure () model = gemmi . Model ( \"1\" ) for chain_id , chain_data in structure . items (): chain = gemmi . Chain ( chain_id ) for idx , ( residue_idx , residue , coord ) in enumerate ( zip ( chain_data . index , chain_data . residues , chain_data . coordinates ) ): gemmi_res = gemmi . Residue () gemmi_res . name = residue . name gemmi_res . seqid = gemmi . SeqId ( residue_idx ) ca = gemmi . Atom () ca . name = \"CA\" ca . pos = gemmi . Position ( * coord ) ca . element = gemmi . Element ( \"C\" ) gemmi_res . add_atom ( ca ) chain . add_residue ( gemmi_res ) model . add_chain ( chain ) gemmi_structure . add_model ( model ) gemmi_structure . write_pdb ( str ( output_file ))","title":"Structure Parser"},{"location":"api/io/#flatprot.io.GemmiStructureParser.parse_structure","text":"Main entry point for structure parsing Source code in src/flatprot/io/structure_gemmi_adapter.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def parse_structure ( self , structure_file : Path , secondary_structure_file : Optional [ Path ] = None ) -> Structure : \"\"\"Main entry point for structure parsing\"\"\" # 1. Parse structure structure = self . _parse_structure_file ( structure_file ) # 2. Process each chain chains = [] for chain in structure [ 0 ]: # Extract basic chain data chain_data = self . _parse_chain_data ( chain ) # Get secondary structure ss_regions = self . _get_secondary_structure ( structure , secondary_structure_file ) chain_obj = Chain ( chain . name , ** chain_data ) for region in ss_regions : chain_obj . add_secondary_structure ( region [ 0 ], region [ 1 ], region [ 2 ], allow_missing_residues = True ) chains . append ( chain_obj ) # Assign structure ID from filename stem structure_id = structure_file . stem return Structure ( chains , id = structure_id )","title":"parse_structure"},{"location":"api/io/#flatprot.io.GemmiStructureParser.save_structure","text":"Save structure using gemmi Source code in src/flatprot/io/structure_gemmi_adapter.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def save_structure ( self , structure : Structure , output_file : Path , separate_chains = False ) -> None : \"\"\"Save structure using gemmi\"\"\" gemmi_structure = gemmi . Structure () model = gemmi . Model ( \"1\" ) for chain_id , chain_data in structure . items (): chain = gemmi . Chain ( chain_id ) for idx , ( residue_idx , residue , coord ) in enumerate ( zip ( chain_data . index , chain_data . residues , chain_data . coordinates ) ): gemmi_res = gemmi . Residue () gemmi_res . name = residue . name gemmi_res . seqid = gemmi . SeqId ( residue_idx ) ca = gemmi . Atom () ca . name = \"CA\" ca . pos = gemmi . Position ( * coord ) ca . element = gemmi . Element ( \"C\" ) gemmi_res . add_atom ( ca ) chain . add_residue ( gemmi_res ) model . add_chain ( chain ) gemmi_structure . add_model ( model ) gemmi_structure . write_pdb ( str ( output_file )) options: show_root_heading: true members_order: source","title":"save_structure"},{"location":"api/io/#style-parser","text":"Parses TOML files defining custom styles for structure elements. Parser for TOML style files focusing on structure elements and connections. Source code in src/flatprot/io/styles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class StyleParser : \"\"\"Parser for TOML style files focusing on structure elements and connections.\"\"\" # Define known sections and their corresponding Pydantic models KNOWN_SECTIONS = { \"helix\" : HelixStyle , \"sheet\" : SheetStyle , \"coil\" : CoilStyle , \"connection\" : ConnectionStyle , \"position_annotation\" : PositionAnnotationStyle , } def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the style parser. Args: file_path: Path to the TOML style file Raises: StyleFileNotFoundError: If the file doesn't exist InvalidTomlError: If the TOML is malformed \"\"\" self . file_path = Path ( file_path ) if not self . file_path . exists (): raise StyleFileNotFoundError ( f \"Style file not found: { self . file_path } \" ) try : with open ( self . file_path , \"r\" ) as f : self . raw_style_data = toml . load ( f ) except toml . TomlDecodeError as e : raise InvalidTomlError ( f \"Invalid TOML format: { e } \" ) self . _validate_structure () def _validate_structure ( self ) -> None : \"\"\"Checks for unknown top-level sections in the style file.\"\"\" unknown_sections = [ section for section in self . raw_style_data if section not in self . KNOWN_SECTIONS ] if unknown_sections : # This is just a warning, not an error print ( f \"Warning: Unknown style sections found and ignored: { ', ' . join ( unknown_sections ) } \" ) def parse ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parses the known sections from the TOML file into Pydantic style objects. Returns: A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their corresponding Pydantic style model instances. Raises: StyleValidationError: If any style section has invalid data according to its Pydantic model. StyleParsingError: For other general parsing issues. \"\"\" parsed_styles : Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ] ] = {} for section_name , StyleModelClass in self . KNOWN_SECTIONS . items (): section_data = self . raw_style_data . get ( section_name ) if section_data is None : # Section not present in the file, skip it (will use default later) continue if not isinstance ( section_data , dict ): raise StyleValidationError ( f \"Invalid format for section ' { section_name } '. Expected a table (dictionary), got { type ( section_data ) . __name__ } .\" ) try : # Pydantic handles validation and type conversion (including Color) style_instance = StyleModelClass ( ** section_data ) parsed_styles [ section_name ] = style_instance except ValidationError as e : # Provide more context for validation errors error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise StyleValidationError ( f \"Invalid style definition in section ' { section_name } ': \\\\ n\" + \" \\\\ n\" . join ( error_msgs ) ) from e except Exception as e : # Catch other potential errors during instantiation raise StyleParsingError ( f \"Error processing style section ' { section_name } ': { e } \" ) from e return parsed_styles def get_element_styles ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parse and return the element styles defined in the TOML file. Returns: Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their parsed Pydantic style objects. Sections not found in the TOML file will be omitted from the dictionary. Raises: StyleValidationError: If validation of any section fails. StyleParsingError: For general parsing issues. \"\"\" try : return self . parse () except ( StyleValidationError , StyleParsingError ): # Re-raise exceptions from parse raise except Exception as e : # Catch unexpected errors during the overall process raise StyleParsingError ( f \"Failed to get element styles: { e } \" ) from e def get_raw_data ( self ) -> Dict [ str , Any ]: \"\"\"Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict containing the raw parsed TOML data. \"\"\" return self . raw_style_data","title":"Style Parser"},{"location":"api/io/#flatprot.io.styles.StyleParser.__init__","text":"Initialize the style parser. Parameters: file_path ( Union [ str , Path ] ) \u2013 Path to the TOML style file Raises: StyleFileNotFoundError \u2013 If the file doesn't exist InvalidTomlError \u2013 If the TOML is malformed Source code in src/flatprot/io/styles.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the style parser. Args: file_path: Path to the TOML style file Raises: StyleFileNotFoundError: If the file doesn't exist InvalidTomlError: If the TOML is malformed \"\"\" self . file_path = Path ( file_path ) if not self . file_path . exists (): raise StyleFileNotFoundError ( f \"Style file not found: { self . file_path } \" ) try : with open ( self . file_path , \"r\" ) as f : self . raw_style_data = toml . load ( f ) except toml . TomlDecodeError as e : raise InvalidTomlError ( f \"Invalid TOML format: { e } \" ) self . _validate_structure ()","title":"__init__"},{"location":"api/io/#flatprot.io.styles.StyleParser.get_element_styles","text":"Parse and return the element styles defined in the TOML file. Returns: Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 to their parsed Pydantic style objects. Sections not found in the TOML Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 file will be omitted from the dictionary. Raises: StyleValidationError \u2013 If validation of any section fails. StyleParsingError \u2013 For general parsing issues. Source code in src/flatprot/io/styles.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_element_styles ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parse and return the element styles defined in the TOML file. Returns: Dict mapping element type names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their parsed Pydantic style objects. Sections not found in the TOML file will be omitted from the dictionary. Raises: StyleValidationError: If validation of any section fails. StyleParsingError: For general parsing issues. \"\"\" try : return self . parse () except ( StyleValidationError , StyleParsingError ): # Re-raise exceptions from parse raise except Exception as e : # Catch unexpected errors during the overall process raise StyleParsingError ( f \"Failed to get element styles: { e } \" ) from e","title":"get_element_styles"},{"location":"api/io/#flatprot.io.styles.StyleParser.get_raw_data","text":"Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict [ str , Any ] \u2013 Dict containing the raw parsed TOML data. Source code in src/flatprot/io/styles.py 152 153 154 155 156 157 158 def get_raw_data ( self ) -> Dict [ str , Any ]: \"\"\"Return the raw, unprocessed style data loaded from the TOML file. Returns: Dict containing the raw parsed TOML data. \"\"\" return self . raw_style_data","title":"get_raw_data"},{"location":"api/io/#flatprot.io.styles.StyleParser.parse","text":"Parses the known sections from the TOML file into Pydantic style objects. Returns: Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]] \u2013 to their corresponding Pydantic style model instances. Raises: StyleValidationError \u2013 If any style section has invalid data according to its Pydantic model. StyleParsingError \u2013 For other general parsing issues. Source code in src/flatprot/io/styles.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def parse ( self , ) -> Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ]]: \"\"\"Parses the known sections from the TOML file into Pydantic style objects. Returns: A dictionary mapping section names ('helix', 'sheet', 'coil', 'connection', 'position_annotation') to their corresponding Pydantic style model instances. Raises: StyleValidationError: If any style section has invalid data according to its Pydantic model. StyleParsingError: For other general parsing issues. \"\"\" parsed_styles : Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , PositionAnnotationStyle ] ] = {} for section_name , StyleModelClass in self . KNOWN_SECTIONS . items (): section_data = self . raw_style_data . get ( section_name ) if section_data is None : # Section not present in the file, skip it (will use default later) continue if not isinstance ( section_data , dict ): raise StyleValidationError ( f \"Invalid format for section ' { section_name } '. Expected a table (dictionary), got { type ( section_data ) . __name__ } .\" ) try : # Pydantic handles validation and type conversion (including Color) style_instance = StyleModelClass ( ** section_data ) parsed_styles [ section_name ] = style_instance except ValidationError as e : # Provide more context for validation errors error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise StyleValidationError ( f \"Invalid style definition in section ' { section_name } ': \\\\ n\" + \" \\\\ n\" . join ( error_msgs ) ) from e except Exception as e : # Catch other potential errors during instantiation raise StyleParsingError ( f \"Error processing style section ' { section_name } ': { e } \" ) from e return parsed_styles options: show_root_heading: true members_order: source","title":"parse"},{"location":"api/io/#annotation-parser","text":"Parses TOML files defining annotations (points, lines, areas) and their inline styles. Parses annotation files in TOML format with optional inline styles. Creates fully initialized PointAnnotation, LineAnnotation, or AreaAnnotation objects from the flatprot.scene.annotations module. Source code in src/flatprot/io/annotations.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class AnnotationParser : \"\"\"Parses annotation files in TOML format with optional inline styles. Creates fully initialized PointAnnotation, LineAnnotation, or AreaAnnotation objects from the `flatprot.scene.annotations` module. \"\"\" def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the parser with the path to the annotation file. Args: file_path: Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError: If the file does not exist. \"\"\" self . file_path = Path ( file_path ) # Check file existence if not self . file_path . exists (): raise AnnotationFileNotFoundError ( str ( self . file_path )) # Map annotation type strings to their respective parsing methods self . _parsers : Dict [ str , Callable [[ Dict [ str , Any ], str , str ], AnnotationObjectType ] ] = { \"point\" : self . _parse_point_annotation , \"line\" : self . _parse_line_annotation , \"area\" : self . _parse_area_annotation , } def _parse_inline_style ( self , style_dict : Optional [ Dict [ str , Any ]], StyleModel : Type [ BaseAnnotationStyle ], context : str , ) -> Optional [ BaseAnnotationStyle ]: \"\"\"Parses the inline style dictionary using the provided Pydantic model.\"\"\" if style_dict is None : return None if not isinstance ( style_dict , dict ): raise MalformedAnnotationError ( context , f \"'style' entry must be a table (dictionary), got { type ( style_dict ) . __name__ } .\" , ) try : style_instance = StyleModel . model_validate ( style_dict ) return style_instance except ValidationError as e : error_details = e . errors () error_msgs = [ f \" - { err [ 'loc' ][ 0 ] } : { err [ 'msg' ] } \" for err in error_details ] raise MalformedAnnotationError ( context , \"Invalid style definition: \\n \" + \" \\n \" . join ( error_msgs ) ) from e except Exception as e : raise AnnotationError ( f \" { context } : Error creating style object: { e } \" ) from e def _parse_point_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> PointAnnotation : \"\"\"Parses a point annotation entry.\"\"\" label = anno_data . get ( \"label\" ) index_str = anno_data . get ( \"index\" ) style_dict = anno_data . get ( \"style\" ) if index_str is None : raise MalformedAnnotationError ( context , \"Missing 'index' field for 'point' annotation.\" ) target_coord = _parse_residue_coordinate ( index_str , context ) style_instance = self . _parse_inline_style ( style_dict , PointAnnotationStyle , context ) return PointAnnotation ( id = anno_id , target = target_coord , style = cast ( Optional [ PointAnnotationStyle ], style_instance ), label = label , ) def _parse_line_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> LineAnnotation : \"\"\"Parses a line annotation entry.\"\"\" label = anno_data . get ( \"label\" ) indices_list = anno_data . get ( \"indices\" ) style_dict = anno_data . get ( \"style\" ) if not isinstance ( indices_list , list ) or len ( indices_list ) != 2 : raise MalformedAnnotationError ( context , \"Field 'indices' for 'line' annotation must be a list of exactly two coordinate strings (e.g., ['A:10', 'A:20']).\" , ) target_coords = [ _parse_residue_coordinate ( s , f \" { context } , index { j + 1 } \" ) for j , s in enumerate ( indices_list ) ] style_instance = self . _parse_inline_style ( style_dict , LineAnnotationStyle , context ) return LineAnnotation ( id = anno_id , start_coordinate = target_coords [ 0 ], end_coordinate = target_coords [ 1 ], style = cast ( Optional [ LineAnnotationStyle ], style_instance ), # Cast for type checker label = label , ) def _parse_area_annotation ( self , anno_data : Dict [ str , Any ], anno_id : str , context : str ) -> AreaAnnotation : \"\"\"Parses an area annotation entry.\"\"\" label = anno_data . get ( \"label\" ) range_str = anno_data . get ( \"range\" ) style_dict = anno_data . get ( \"style\" ) # AreaAnnotation currently only supports range, not list of indices if range_str is None : raise MalformedAnnotationError ( context , \"Missing 'range' field for 'area' annotation.\" ) target_range = _parse_residue_range ( range_str , context ) target_range_set = ResidueRangeSet ([ target_range ]) style_instance = self . _parse_inline_style ( style_dict , AreaAnnotationStyle , context ) return AreaAnnotation ( id = anno_id , residue_range_set = target_range_set , style = cast ( Optional [ AreaAnnotationStyle ], style_instance ), # Cast for type checker label = label , ) def parse ( self ) -> List [ AnnotationObjectType ]: \"\"\"Parse the annotation file and create annotation objects. Returns: List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError: If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError: For other general parsing issues. \"\"\" try : # Parse TOML content raw_data = toml . load ( self . file_path ) except toml . TomlDecodeError as e : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , f \"Invalid TOML syntax: { str ( e ) } \" ) from e except Exception as e : raise AnnotationError ( f \"Error loading TOML file { self . file_path } : { e } \" ) from e if not isinstance ( raw_data , dict ) or \"annotations\" not in raw_data : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"Missing top-level 'annotations' list.\" ) if not isinstance ( raw_data [ \"annotations\" ], list ): raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"'annotations' key must contain a list.\" ) parsed_annotations : List [ AnnotationObjectType ] = [] for i , anno_data in enumerate ( raw_data [ \"annotations\" ]): context = f \"File: { self . file_path } , Annotation # { i + 1 } \" try : if not isinstance ( anno_data , dict ): raise MalformedAnnotationError ( context , \"Annotation entry must be a table (dictionary).\" ) anno_type = anno_data . get ( \"type\" ) if not isinstance ( anno_type , str ): raise MalformedAnnotationError ( context , f \"Missing or invalid 'type' field. Expected a string, got { type ( anno_type ) . __name__ } .\" , ) # Look up the parser function based on the type parser_func = self . _parsers . get ( anno_type ) if parser_func is None : raise MalformedAnnotationError ( context , f \"Unknown annotation 'type': ' { anno_type } '. Must be one of { list ( self . _parsers . keys ()) } .\" , ) # Check for optional user-provided ID provided_id = anno_data . get ( \"id\" ) if provided_id is not None : if isinstance ( provided_id , str ): anno_id = provided_id else : raise MalformedAnnotationError ( context , f \"Optional 'id' field must be a string, got { type ( provided_id ) . __name__ } .\" , ) else : # Generate ID if not provided anno_id = f \"annotation_ { self . file_path . stem } _ { i } _ { anno_type } \" # Call the specific parser method annotation_object = parser_func ( anno_data , anno_id , context ) parsed_annotations . append ( annotation_object ) except ( MalformedAnnotationError , AnnotationError ) as e : raise e except Exception as e : raise AnnotationError ( f \"Unexpected error processing annotation in { context } : { e } \" ) from e return parsed_annotations","title":"Annotation Parser"},{"location":"api/io/#flatprot.io.annotations.AnnotationParser.__init__","text":"Initialize the parser with the path to the annotation file. Parameters: file_path ( Union [ str , Path ] ) \u2013 Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError \u2013 If the file does not exist. Source code in src/flatprot/io/annotations.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , file_path : Union [ str , Path ]): \"\"\"Initialize the parser with the path to the annotation file. Args: file_path: Path to the TOML file containing annotations. Raises: AnnotationFileNotFoundError: If the file does not exist. \"\"\" self . file_path = Path ( file_path ) # Check file existence if not self . file_path . exists (): raise AnnotationFileNotFoundError ( str ( self . file_path )) # Map annotation type strings to their respective parsing methods self . _parsers : Dict [ str , Callable [[ Dict [ str , Any ], str , str ], AnnotationObjectType ] ] = { \"point\" : self . _parse_point_annotation , \"line\" : self . _parse_line_annotation , \"area\" : self . _parse_area_annotation , }","title":"__init__"},{"location":"api/io/#flatprot.io.annotations.AnnotationParser.parse","text":"Parse the annotation file and create annotation objects. Returns: List [ AnnotationObjectType ] \u2013 List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError \u2013 If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError \u2013 For other general parsing issues. Source code in src/flatprot/io/annotations.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def parse ( self ) -> List [ AnnotationObjectType ]: \"\"\"Parse the annotation file and create annotation objects. Returns: List of parsed annotation objects (PointAnnotation, LineAnnotation, AreaAnnotation). Raises: MalformedAnnotationError: If the TOML file is malformed, missing required structure, contains invalid formats, or style validation fails. AnnotationError: For other general parsing issues. \"\"\" try : # Parse TOML content raw_data = toml . load ( self . file_path ) except toml . TomlDecodeError as e : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , f \"Invalid TOML syntax: { str ( e ) } \" ) from e except Exception as e : raise AnnotationError ( f \"Error loading TOML file { self . file_path } : { e } \" ) from e if not isinstance ( raw_data , dict ) or \"annotations\" not in raw_data : raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"Missing top-level 'annotations' list.\" ) if not isinstance ( raw_data [ \"annotations\" ], list ): raise MalformedAnnotationError ( f \"File: { self . file_path } \" , \"'annotations' key must contain a list.\" ) parsed_annotations : List [ AnnotationObjectType ] = [] for i , anno_data in enumerate ( raw_data [ \"annotations\" ]): context = f \"File: { self . file_path } , Annotation # { i + 1 } \" try : if not isinstance ( anno_data , dict ): raise MalformedAnnotationError ( context , \"Annotation entry must be a table (dictionary).\" ) anno_type = anno_data . get ( \"type\" ) if not isinstance ( anno_type , str ): raise MalformedAnnotationError ( context , f \"Missing or invalid 'type' field. Expected a string, got { type ( anno_type ) . __name__ } .\" , ) # Look up the parser function based on the type parser_func = self . _parsers . get ( anno_type ) if parser_func is None : raise MalformedAnnotationError ( context , f \"Unknown annotation 'type': ' { anno_type } '. Must be one of { list ( self . _parsers . keys ()) } .\" , ) # Check for optional user-provided ID provided_id = anno_data . get ( \"id\" ) if provided_id is not None : if isinstance ( provided_id , str ): anno_id = provided_id else : raise MalformedAnnotationError ( context , f \"Optional 'id' field must be a string, got { type ( provided_id ) . __name__ } .\" , ) else : # Generate ID if not provided anno_id = f \"annotation_ { self . file_path . stem } _ { i } _ { anno_type } \" # Call the specific parser method annotation_object = parser_func ( anno_data , anno_id , context ) parsed_annotations . append ( annotation_object ) except ( MalformedAnnotationError , AnnotationError ) as e : raise e except Exception as e : raise AnnotationError ( f \"Unexpected error processing annotation in { context } : { e } \" ) from e return parsed_annotations options: show_root_heading: true members_order: source","title":"parse"},{"location":"api/io/#file-validation","text":"Utility functions for validating input files. Validate that the file exists and is a valid PDB or CIF format. Parameters: path ( Path ) \u2013 Path to the structure file Raises: StructureFileNotFoundError \u2013 If the file does not exist InvalidStructureError \u2013 If the file is not a valid PDB or CIF format Source code in src/flatprot/io/structure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def validate_structure_file ( path : Path ) -> None : \"\"\"Validate that the file exists and is a valid PDB or CIF format. Args: path: Path to the structure file Raises: StructureFileNotFoundError: If the file does not exist InvalidStructureError: If the file is not a valid PDB or CIF format \"\"\" # Check file existence if not path . exists (): raise StructureFileNotFoundError ( str ( path )) # Check file extension suffix = path . suffix . lower () if suffix not in [ \".pdb\" , \".cif\" , \".mmcif\" , \".ent\" ]: raise InvalidStructureError ( str ( path ), \"PDB or CIF\" , \"File does not have a recognized structure file extension (.pdb, .cif, .mmcif, .ent)\" , ) # Basic content validation try : with open ( path , \"r\" ) as f : content = f . read ( 1000 ) # Read first 1000 bytes for quick check # Basic check for PDB format if suffix in [ \".pdb\" , \".ent\" ]: if not ( \"ATOM\" in content or \"HETATM\" in content or \"HEADER\" in content ): raise InvalidStructureError ( str ( path ), \"PDB\" , \"File does not contain required PDB records (ATOM, HETATM, or HEADER)\" , ) # Basic check for mmCIF format if suffix in [ \".cif\" , \".mmcif\" ]: if not ( \"_atom_site.\" in content or \"loop_\" in content or \"data_\" in content ): raise InvalidStructureError ( str ( path ), \"CIF\" , \"File does not contain required CIF categories (_atom_site, loop_, or data_)\" , ) except UnicodeDecodeError : raise InvalidStructureError ( str ( path ), \"PDB or CIF\" , \"File contains invalid characters and is not a valid text file\" , ) options: show_root_heading: true Validate that optional files exist if specified. Parameters: file_paths ( List [ Optional [ Path ]] ) \u2013 List of file paths to check (can include None values) Raises: FileNotFoundError \u2013 If any specified file does not exist Source code in src/flatprot/io/__init__.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def validate_optional_files ( file_paths : List [ Optional [ Path ]], ) -> None : \"\"\"Validate that optional files exist if specified. Args: file_paths: List of file paths to check (can include None values) Raises: FileNotFoundError: If any specified file does not exist \"\"\" for path in file_paths : if path and not path . exists (): raise FileNotFoundError ( str ( path )) options: show_root_heading: true","title":"File Validation"},{"location":"api/io/#io-errors","text":"Exceptions specific to file input, output, parsing, and validation. Error classes for the FlatProt IO module.","title":"IO Errors"},{"location":"api/io/#flatprot.io.errors.AnnotationError","text":"Bases: IOError Base class for annotation-related errors. Source code in src/flatprot/io/errors.py 90 91 92 93 94 class AnnotationError ( IOError ): \"\"\"Base class for annotation-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Annotation error: { message } \" )","title":"AnnotationError"},{"location":"api/io/#flatprot.io.errors.AnnotationFileError","text":"Bases: AnnotationError Exception raised when there's an issue with an annotation file. Source code in src/flatprot/io/errors.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class AnnotationFileError ( AnnotationError ): \"\"\"Exception raised when there's an issue with an annotation file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid annotation file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = ( \" \\n Annotation files should be in TOML format with an 'annotations' list.\" ) suggestion += \" \\n Example annotation format: \\n \" suggestion += \"\"\" [[annotations]] type = \"point\" label = \"Active site\" chain = \"A\" indices = 123 color = \"#FF0000\" \"\"\" super () . __init__ ( f \" { message }{ suggestion } \" )","title":"AnnotationFileError"},{"location":"api/io/#flatprot.io.errors.AnnotationFileNotFoundError","text":"Bases: AnnotationError Exception raised when an annotation file is not found. Source code in src/flatprot/io/errors.py 97 98 99 100 101 102 class AnnotationFileNotFoundError ( AnnotationError ): \"\"\"Exception raised when an annotation file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Annotation file not found: { file_path } \" super () . __init__ ( message )","title":"AnnotationFileNotFoundError"},{"location":"api/io/#flatprot.io.errors.FileError","text":"Bases: IOError Base class for file-related errors. Source code in src/flatprot/io/errors.py 22 23 24 25 26 class FileError ( IOError ): \"\"\"Base class for file-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( message )","title":"FileError"},{"location":"api/io/#flatprot.io.errors.FileNotFoundError","text":"Bases: FileError Exception raised when a required file is not found. Source code in src/flatprot/io/errors.py 29 30 31 32 33 34 35 36 class FileNotFoundError ( FileError ): \"\"\"Exception raised when a required file is not found.\"\"\" def __init__ ( self , file_path : str ): self . file_path = file_path message = f \"File not found: { file_path } \" suggestion = \"Please check that the file exists and the path is correct.\" super () . __init__ ( f \" { message } \\n { suggestion } \" )","title":"FileNotFoundError"},{"location":"api/io/#flatprot.io.errors.IOError","text":"Bases: FlatProtError Base class for all IO-related errors in FlatProt. Source code in src/flatprot/io/errors.py 15 16 17 18 19 class IOError ( FlatProtError ): \"\"\"Base class for all IO-related errors in FlatProt.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"IO error: { message } \" )","title":"IOError"},{"location":"api/io/#flatprot.io.errors.InvalidColorError","text":"Bases: StyleError Exception raised when an invalid color is specified. Source code in src/flatprot/io/errors.py 236 237 238 239 240 241 242 243 244 245 246 class InvalidColorError ( StyleError ): \"\"\"Exception raised when an invalid color is specified.\"\"\" def __init__ ( self , color_value : str , element_type : str ): self . color_value = color_value self . element_type = element_type message = f \"Invalid color value ' { color_value } ' for { element_type } .\" suggestion = \" \\n Colors should be specified as hex (#RRGGBB), RGB (rgb(r,g,b)), or named colors.\" super () . __init__ ( f \" { message }{ suggestion } \" )","title":"InvalidColorError"},{"location":"api/io/#flatprot.io.errors.InvalidFieldTypeError","text":"Bases: AnnotationError Exception raised when a field has an invalid type. Source code in src/flatprot/io/errors.py 121 122 123 124 125 126 127 128 129 130 131 132 class InvalidFieldTypeError ( AnnotationError ): \"\"\"Exception raised when a field has an invalid type.\"\"\" def __init__ ( self , annotation_type : str , field_name : str , expected_type : str , annotation_index : int , ): message = f \"Invalid type for field ' { field_name } ' in { annotation_type } annotation at index { annotation_index } . Expected { expected_type } .\" super () . __init__ ( message )","title":"InvalidFieldTypeError"},{"location":"api/io/#flatprot.io.errors.InvalidFileFormatError","text":"Bases: FileError Exception raised when a file has an invalid format. Source code in src/flatprot/io/errors.py 39 40 41 42 43 44 45 46 class InvalidFileFormatError ( FileError ): \"\"\"Exception raised when a file has an invalid format.\"\"\" def __init__ ( self , file_path : str , expected_format : str ): self . file_path = file_path self . expected_format = expected_format message = f \"Invalid file format for { file_path } . Expected { expected_format } .\" super () . __init__ ( message )","title":"InvalidFileFormatError"},{"location":"api/io/#flatprot.io.errors.InvalidMatrixDimensionsError","text":"Bases: MatrixError Error raised when a matrix has invalid dimensions. Source code in src/flatprot/io/errors.py 265 266 267 268 class InvalidMatrixDimensionsError ( MatrixError ): \"\"\"Error raised when a matrix has invalid dimensions.\"\"\" pass","title":"InvalidMatrixDimensionsError"},{"location":"api/io/#flatprot.io.errors.InvalidMatrixError","text":"Bases: MatrixError Exception raised when a matrix file has an invalid format. Source code in src/flatprot/io/errors.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class InvalidMatrixError ( MatrixError ): \"\"\"Exception raised when a matrix file has an invalid format.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid matrix file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Matrix files should be NumPy .npy files containing a 4x4 transformation matrix.\" suggestion += \" \\n Alternatively, you can use separate .npy files for rotation (3x3) and translation (3x1).\" super () . __init__ ( f \" { message }{ suggestion } \" )","title":"InvalidMatrixError"},{"location":"api/io/#flatprot.io.errors.InvalidMatrixFormatError","text":"Bases: MatrixError Error raised when a matrix file has an invalid format. Source code in src/flatprot/io/errors.py 271 272 273 274 class InvalidMatrixFormatError ( MatrixError ): \"\"\"Error raised when a matrix file has an invalid format.\"\"\" pass","title":"InvalidMatrixFormatError"},{"location":"api/io/#flatprot.io.errors.InvalidReferenceError","text":"Bases: AnnotationError Exception raised when an annotation references a nonexistent chain or residue. Source code in src/flatprot/io/errors.py 135 136 137 138 139 140 141 142 143 144 145 146 class InvalidReferenceError ( AnnotationError ): \"\"\"Exception raised when an annotation references a nonexistent chain or residue.\"\"\" def __init__ ( self , annotation_type : str , reference_type : str , reference : str , annotation_index : int , ): message = f \"Invalid { reference_type } reference ' { reference } ' in { annotation_type } annotation at index { annotation_index } .\" super () . __init__ ( message )","title":"InvalidReferenceError"},{"location":"api/io/#flatprot.io.errors.InvalidStructureError","text":"Bases: StructureError Exception raised when a structure file has an invalid format. Source code in src/flatprot/io/errors.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class InvalidStructureError ( StructureError ): \"\"\"Exception raised when a structure file has an invalid format.\"\"\" def __init__ ( self , file_path : str , expected_format : str , details : Optional [ str ] = None ): self . file_path = file_path self . expected_format = expected_format self . details = details message = f \"Invalid { expected_format } file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = f \" \\n Please ensure the file is a valid { expected_format } format. \" if expected_format == \"PDB\" : suggestion += \"PDB files should contain ATOM, HETATM, or HEADER records.\" elif expected_format == \"CIF\" : suggestion += \"CIF files should contain _atom_site categories, loop_, or data_ sections.\" super () . __init__ ( f \" { message } \\n { suggestion } \" )","title":"InvalidStructureError"},{"location":"api/io/#flatprot.io.errors.InvalidTomlError","text":"Bases: StyleParsingError Error for malformed TOML files. Source code in src/flatprot/io/errors.py 198 199 200 201 class InvalidTomlError ( StyleParsingError ): \"\"\"Error for malformed TOML files.\"\"\" pass","title":"InvalidTomlError"},{"location":"api/io/#flatprot.io.errors.MalformedAnnotationError","text":"Bases: AnnotationError Exception raised when an annotation file has an invalid format. Source code in src/flatprot/io/errors.py 105 106 107 108 109 110 class MalformedAnnotationError ( AnnotationError ): \"\"\"Exception raised when an annotation file has an invalid format.\"\"\" def __init__ ( self , file_path : str , details : str ): message = f \"Malformed annotation file: { file_path } \\n { details } \" super () . __init__ ( message )","title":"MalformedAnnotationError"},{"location":"api/io/#flatprot.io.errors.MatrixError","text":"Bases: IOError Base class for matrix-related errors. Source code in src/flatprot/io/errors.py 250 251 252 253 254 class MatrixError ( IOError ): \"\"\"Base class for matrix-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Matrix error: { message } \" )","title":"MatrixError"},{"location":"api/io/#flatprot.io.errors.MatrixFileError","text":"Bases: MatrixError Error raised when a matrix file can't be read. Source code in src/flatprot/io/errors.py 277 278 279 280 class MatrixFileError ( MatrixError ): \"\"\"Error raised when a matrix file can't be read.\"\"\" pass","title":"MatrixFileError"},{"location":"api/io/#flatprot.io.errors.MatrixFileNotFoundError","text":"Bases: MatrixError Exception raised when a matrix file is not found. Source code in src/flatprot/io/errors.py 257 258 259 260 261 262 class MatrixFileNotFoundError ( MatrixError ): \"\"\"Exception raised when a matrix file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Matrix file not found: { file_path } \" super () . __init__ ( message )","title":"MatrixFileNotFoundError"},{"location":"api/io/#flatprot.io.errors.MissingRequiredFieldError","text":"Bases: AnnotationError Exception raised when a required field is missing from an annotation. Source code in src/flatprot/io/errors.py 113 114 115 116 117 118 class MissingRequiredFieldError ( AnnotationError ): \"\"\"Exception raised when a required field is missing from an annotation.\"\"\" def __init__ ( self , annotation_type : str , field_name : str , annotation_index : int ): message = f \"Missing required field ' { field_name } ' for { annotation_type } annotation at index { annotation_index } \" super () . __init__ ( message )","title":"MissingRequiredFieldError"},{"location":"api/io/#flatprot.io.errors.OutputError","text":"Bases: IOError Base class for output-related errors. Source code in src/flatprot/io/errors.py 301 302 303 304 305 class OutputError ( IOError ): \"\"\"Base class for output-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Output error: { message } \" )","title":"OutputError"},{"location":"api/io/#flatprot.io.errors.OutputFileError","text":"Bases: OutputError Exception raised when there's an issue with an output file. Source code in src/flatprot/io/errors.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class OutputFileError ( OutputError ): \"\"\"Exception raised when there's an issue with an output file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Error writing to output file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Please check that you have write permissions to the directory and sufficient disk space.\" super () . __init__ ( f \" { message }{ suggestion } \" )","title":"OutputFileError"},{"location":"api/io/#flatprot.io.errors.StructureError","text":"Bases: IOError Base class for structure-related errors. Source code in src/flatprot/io/errors.py 50 51 52 53 54 class StructureError ( IOError ): \"\"\"Base class for structure-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Structure error: { message } \" )","title":"StructureError"},{"location":"api/io/#flatprot.io.errors.StructureFileNotFoundError","text":"Bases: StructureError Exception raised when a structure file is not found. Source code in src/flatprot/io/errors.py 57 58 59 60 61 62 63 class StructureFileNotFoundError ( StructureError ): \"\"\"Exception raised when a structure file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Structure file not found: { file_path } \" suggestion = \"Please check that the file exists and the path is correct.\" super () . __init__ ( f \" { message } \\n { suggestion } \" )","title":"StructureFileNotFoundError"},{"location":"api/io/#flatprot.io.errors.StyleError","text":"Bases: IOError Base class for style-related errors. Source code in src/flatprot/io/errors.py 177 178 179 180 181 class StyleError ( IOError ): \"\"\"Base class for style-related errors.\"\"\" def __init__ ( self , message : str ): super () . __init__ ( f \"Style error: { message } \" )","title":"StyleError"},{"location":"api/io/#flatprot.io.errors.StyleFileError","text":"Bases: StyleError Exception raised when there's an issue with a style file. Source code in src/flatprot/io/errors.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class StyleFileError ( StyleError ): \"\"\"Exception raised when there's an issue with a style file.\"\"\" def __init__ ( self , file_path : str , details : Optional [ str ] = None ): self . file_path = file_path self . details = details message = f \"Invalid style file: { file_path } \" if details : message += f \" \\n { details } \" suggestion = \" \\n Style files should be in TOML format with sections for different elements.\" suggestion += \" \\n Example style format: \\n \" suggestion += \"\"\" [helix] fill_color = \"#FF0000\" stroke_color = \"#800000\" [sheet] fill_color = \"#00FF00\" stroke_color = \"#008000\" \"\"\" super () . __init__ ( f \" { message }{ suggestion } \" )","title":"StyleFileError"},{"location":"api/io/#flatprot.io.errors.StyleFileNotFoundError","text":"Bases: StyleError Exception raised when a style file is not found. Source code in src/flatprot/io/errors.py 184 185 186 187 188 189 class StyleFileNotFoundError ( StyleError ): \"\"\"Exception raised when a style file is not found.\"\"\" def __init__ ( self , file_path : str ): message = f \"Style file not found: { file_path } \" super () . __init__ ( message )","title":"StyleFileNotFoundError"},{"location":"api/io/#flatprot.io.errors.StyleParsingError","text":"Bases: StyleError Base error for style parsing issues. Source code in src/flatprot/io/errors.py 192 193 194 195 class StyleParsingError ( StyleError ): \"\"\"Base error for style parsing issues.\"\"\" pass","title":"StyleParsingError"},{"location":"api/io/#flatprot.io.errors.StyleValidationError","text":"Bases: StyleParsingError Error for invalid style field types or values. Source code in src/flatprot/io/errors.py 204 205 206 207 class StyleValidationError ( StyleParsingError ): \"\"\"Error for invalid style field types or values.\"\"\" pass options: show_root_heading: true","title":"StyleValidationError"},{"location":"api/rendering/","text":"Rendering API This section documents the rendering system in FlatProt, responsible for converting the abstract Scene object into a concrete visual output format, primarily SVG. Rendering Concept Renderers act as the final stage in the visualization pipeline. They take a populated Scene object, which contains various SceneElement instances (like HelixSceneElement , PointAnnotation , etc.) already projected into a 2D canvas space with associated depth (Z) information. The renderer iterates through the elements in the scene, translates their geometric data and style attributes into the target output format (e.g., SVG tags and attributes), and produces the final file or output string. Peculiarities and Design Choices Several aspects define how the FlatProt rendering system, particularly the SVGRenderer , operates: Depth Sorting (Z-Ordering): Before drawing, scene elements are typically sorted based on their calculated average depth (Z-coordinate). This ensures that elements closer to the viewer (lower Z, assuming standard projection) are drawn later, correctly occluding elements farther away. Annotation elements ( BaseAnnotationElement ) usually override the depth calculation to return a very high value (e.g., float('inf') ). This guarantees they are sorted last and therefore drawn on top of all structural elements. Scene Element to SVG Mapping: The renderer maps different SceneElement types to appropriate SVG tags: HelixSceneElement : Typically rendered as an SVG <path> or <polygon> representing the zigzag ribbon. SheetSceneElement : Rendered as an SVG <polygon> forming the arrowhead shape. CoilSceneElement : Rendered as an SVG <path> or <polyline> representing the smoothed line. PointAnnotation : Rendered as an SVG <circle> plus an SVG <text> element for the label. LineAnnotation : Rendered as an SVG <line> or <path> , potentially with <circle> elements for connectors and <polygon> for arrowheads, plus an SVG <text> element for the label. AreaAnnotation : Rendered as an SVG <path> or <polygon> representing the padded convex hull, plus an SVG <text> element for the label. Elements are often grouped within SVG <g> tags for organization, potentially grouped by type or parent element in the scene graph. Style Application: Style attributes defined in the BaseSceneStyle and its derivatives (e.g., HelixStyle , PointAnnotationStyle ) are translated into SVG presentation attributes. Examples: color or fill_color -> fill attribute. stroke_color or line_color -> stroke attribute. stroke_width -> stroke-width attribute. opacity or fill_opacity -> opacity or fill-opacity attributes. line_style or linestyle (tuple/array) -> stroke-dasharray attribute. Label styles ( label_color , label_font_size , etc.) -> corresponding attributes on the <text> element. Coordinate System & Canvas: The input Scene contains elements with coordinates already projected onto the 2D canvas (X, Y) plus depth (Z). The origin (0,0) is typically the top-left corner, consistent with SVG standards. The width and height provided to the renderer define the dimensions of the SVG canvas and its viewBox . These dimensions are controlled via CLI parameters (default: 1000x1000) and passed through the rendering pipeline. The project_structure_orthographically utility function handles the scaling and centering of the protein coordinates within this canvas space before they reach the scene/renderer. Focus on Static Output: The current implementation focuses on generating static SVG images. It generally does not utilize advanced SVG features like animations, complex gradients, filters, or embedded scripts. Renderer Classes Renders a Scene object to an SVG Drawing. Attributes: scene \u2013 The Scene object to render. width \u2013 The width of the SVG canvas. height \u2013 The height of the SVG canvas. background_color \u2013 Optional background color for the SVG. background_opacity \u2013 Opacity for the background color. padding \u2013 Padding around the content within the viewBox. Source code in src/flatprot/renderers/svg_renderer.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class SVGRenderer : \"\"\"Renders a Scene object to an SVG Drawing. Attributes: scene: The Scene object to render. width: The width of the SVG canvas. height: The height of the SVG canvas. background_color: Optional background color for the SVG. background_opacity: Opacity for the background color. padding: Padding around the content within the viewBox. \"\"\" DEFAULT_WIDTH = 600 DEFAULT_HEIGHT = 400 DEFAULT_BG_COLOR = \"#FFFFFF\" DEFAULT_BG_OPACITY = 1.0 DEFAULT_PADDING = 10 # Default padding in SVG units # Map element types to their drawing functions DRAW_MAP = { CoilSceneElement : _draw_coil , HelixSceneElement : _draw_helix , SheetSceneElement : _draw_sheet , # Annotations handled separately due to anchor calculation } ANNOTATION_DRAW_MAP = { PointAnnotation : _draw_point_annotation , LineAnnotation : _draw_line_annotation , AreaAnnotation : _draw_area_annotation , PositionAnnotation : _draw_position_annotation , } def __init__ ( self , scene : Scene , width : int = DEFAULT_WIDTH , height : int = DEFAULT_HEIGHT , background_color : Optional [ str ] = DEFAULT_BG_COLOR , background_opacity : float = DEFAULT_BG_OPACITY , padding : int = DEFAULT_PADDING , ): \"\"\"Initializes the SVGRenderer. Args: scene: The Scene object containing the elements to render. width: Desired width of the SVG canvas. height: Desired height of the SVG canvas. background_color: Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity: Background opacity (0.0 to 1.0). padding: Padding around the content within the viewBox. \"\"\" if not isinstance ( scene , Scene ): raise TypeError ( \"Renderer requires a valid Scene object.\" ) self . scene = scene self . width = width self . height = height self . background_color = background_color self . background_opacity = background_opacity self . padding = padding # Store padding self . _element_map : Dict [ str , BaseSceneElement ] = { e . id : e for e in self . scene . get_all_elements () } def _collect_and_sort_renderables ( self , ) -> Tuple [ List [ Tuple [ float , BaseStructureSceneElement ]], List [ Tuple [ float , BaseAnnotationElement ]], List [ Tuple [ float , Connection ]], ]: \"\"\"Traverses scene, collects renderable leaf nodes, sorts them by Z-depth.\"\"\" structure_elements : List [ Tuple [ float , BaseStructureSceneElement ]] = [] annotation_elements : List [ Tuple [ float , BaseAnnotationElement ]] = [] connection_elements : List [ Tuple [ float , Connection ]] = [] structure = self . scene . structure # Get structure once logger . debug ( \"--- Starting _collect_and_sort_renderables ---\" ) # DEBUG for element , hierarchy_depth in self . scene . traverse (): # Use scene traverse logger . debug ( f \"Traversing: { element . id } (Type: { type ( element ) . __name__ } , Depth: { hierarchy_depth } )\" ) # Skip invisible or group elements if not element . style . visibility : logger . debug ( f \"Skipping { element . id } : Invisible\" ) # DEBUG continue if isinstance ( element , SceneGroup ): logger . debug ( f \"Skipping { element . id } : Is SceneGroup\" ) # DEBUG continue render_depth = element . get_depth ( structure ) logger . debug ( f \"Calculated render_depth for { element . id } : { render_depth } \" ) # DEBUG if render_depth is None : logger . debug ( f \"Element { element . id } ( { type ( element ) . __name__ } ) has no rendering depth, skipping collection.\" ) # DEBUG: Changed message slightly continue # Categorize and collect if isinstance ( element , BaseStructureSceneElement ): logger . debug ( f \"Collecting Structure Element: { element . id } \" ) # DEBUG structure_elements . append (( render_depth , element )) elif isinstance ( element , BaseAnnotationElement ): # Depth is inf, but store it for consistency (sorting won't change) logger . debug ( f \"Collecting Annotation Element: { element . id } \" ) # DEBUG annotation_elements . append (( render_depth , element )) elif isinstance ( element , Connection ): logger . debug ( f \"Collecting Connection Element: { element . id } \" ) # DEBUG connection_elements . append (( render_depth , element )) # else: Ignore other potential non-group, non-renderable types logger . debug ( \"--- Finished _collect_and_sort_renderables ---\" ) # DEBUG # Sort structure elements by depth (ascending) structure_elements . sort ( key = lambda item : item [ 0 ]) # Annotations are naturally last due to depth=inf, but explicit sort doesn't hurt annotation_elements . sort ( key = lambda item : item [ 0 ]) # Sort connections by depth (ascending) - based on average of connected elements connection_elements . sort ( key = lambda item : item [ 0 ]) return structure_elements , annotation_elements , connection_elements def _build_svg_hierarchy ( self , element : BaseSceneElement , parent_svg_group : Group , svg_group_map : Dict [ str , Group ], ) -> None : \"\"\"Recursively builds SVG groups mirroring SceneGroups.\"\"\" if not isinstance ( element , SceneGroup ): return # Only process groups # Use group with transform svg_transform_str = str ( element . transforms ) current_svg_group = Group ( id = element . id , transform = svg_transform_str ) svg_group_map [ element . id ] = current_svg_group parent_svg_group . append ( current_svg_group ) # Recursively process children for child in element . children : self . _build_svg_hierarchy ( child , current_svg_group , svg_group_map ) def _prepare_render_data ( self , ) -> Tuple [ List [ BaseStructureSceneElement ], # Ordered structure elements Dict [ str , np . ndarray ], # Element ID -> coords_2d ]: \"\"\"Pre-calculates 2D coordinates and connection points for structure elements.\"\"\" # ordered_elements: List[BaseStructureSceneElement] = [] # Keep type hint element_coords_cache : Dict [ str , np . ndarray ] = {} structure = self . scene . structure # --- Get Sequentially Ordered Structure Elements --- # # Uses the new method in Scene to get elements sorted by chain and residue index try : ordered_elements = self . scene . get_sequential_structure_elements () # Filter for visibility *after* getting the ordered list ordered_elements = [ el for el in ordered_elements if el . style . visibility ] except Exception as e : logger . error ( f \"Error getting sequential structure elements: { e } \" , exc_info = True ) return [], {} # Return empty if fetching/sorting failed # --- Calculate Coordinates and Connection Points --- # for element in ordered_elements : element_id = element . id try : # CRITICAL ASSUMPTION: get_coordinates returns *final projected* 2D/3D coords. # If it returns raw 3D, projection needs to happen here. coords = element . get_coordinates ( structure ) if coords is None or coords . ndim != 2 or coords . shape [ 1 ] < 2 : logger . warning ( f \"Element { element_id } provided invalid coordinates shape: { coords . shape if coords is not None else 'None' } . Skipping.\" ) # Add placeholders to avoid key errors later if neighbors expect connections element_coords_cache [ element_id ] = np . empty (( 0 , 2 )) continue coords_2d = coords [:, : 2 ] # Ensure we only use X, Y element_coords_cache [ element_id ] = coords_2d except Exception as e : logger . error ( f \"Error preparing render data for element { element_id } : { e } \" , exc_info = True , ) # Add placeholders if preparation fails for an element element_coords_cache [ element_id ] = np . empty (( 0 , 2 )) continue return ordered_elements , element_coords_cache def render ( self ) -> Drawing : \"\"\"Renders the scene to a drawsvg.Drawing object.\"\"\" drawing = Drawing ( self . width , self . height ) svg_group_map : Dict [ str , Group ] = {} # 1. Add Background if self . background_color : drawing . append ( Rectangle ( 0 , 0 , self . width , self . height , fill = self . background_color , opacity = self . background_opacity , class_ = \"background\" , ) ) # 2. Build SVG Group Hierarchy root_group = Group ( id = \"flatprot-root\" ) drawing . append ( root_group ) svg_group_map [ \"flatprot-root\" ] = root_group # Register root for top_level_node in self . scene . top_level_nodes : self . _build_svg_hierarchy ( top_level_node , root_group , svg_group_map ) # 3. Prepare Render Data for Structure Elements try : ( _ , element_coords_cache , ) = self . _prepare_render_data () except Exception as e : logger . error ( f \"Failed to prepare render data: { e } \" , exc_info = True ) return drawing # 3.5 Collect and Sort All Renderable Elements try : ( sorted_structure_elements , sorted_annotations , sorted_connections , ) = self . _collect_and_sort_renderables () except Exception as e : logger . error ( f \"Failed to collect/sort renderables: { e } \" , exc_info = True ) return drawing # 4. Draw Structure Elements (sorted by depth) for depth , element in sorted_structure_elements : element_id = element . id element_type = type ( element ) # Get cached coordinates for the current element coords_2d = element_coords_cache . get ( element_id ) if coords_2d is None or coords_2d . size == 0 : logger . warning ( f \"Skipping draw for { element_id } : No valid cached 2D coordinates found.\" ) continue # Select and call the appropriate drawing function svg_shape : Optional [ Any ] = None try : if isinstance ( element , CoilSceneElement ): svg_shape = _draw_coil ( element , coords_2d ) elif isinstance ( element , HelixSceneElement ): svg_shape = _draw_helix ( element , coords_2d ) elif isinstance ( element , SheetSceneElement ): svg_shape = _draw_sheet ( element , coords_2d ) else : logger . warning ( f \"No specific draw function mapped for structure type: { element_type . __name__ } . Skipping { element_id } .\" ) continue except Exception as e : logger . error ( f \"Error calling draw function for { element_id } : { e } \" , exc_info = True ) continue # Append the generated shape to the correct SVG group if svg_shape : parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shape ) else : logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for element { element_id } \" ) # 5. Draw Connection Elements (sorted by depth) for _ , element in sorted_connections : connection_line_svg = _draw_connection_element ( element , self . scene . structure ) if connection_line_svg : # Determine the parent group for the connection parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( connection_line_svg ) else : # Log error if the parent group is not found in the map logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for connection element { element . id } \" ) # 6. Draw Annotation Elements (sorted by depth - effectively always last) for _ , element in sorted_annotations : element_type = type ( element ) draw_func = self . ANNOTATION_DRAW_MAP . get ( element_type ) if not draw_func : logger . warning ( f \"No drawing func for annotation type: { element_type . __name__ } \" ) continue try : # Calculate coordinates using the annotation's own method + resolver rendered_coords = element . get_coordinates ( self . scene . resolver ) except ( CoordinateCalculationError , SceneError , ValueError , TargetResidueNotFoundError , ) as e : # Catch expected errors during coordinate resolution/calculation logger . error ( f \"Could not get coordinates for annotation ' { element . id } ': { e } \" ) logger . exception ( e ) continue # Skip rendering this annotation except Exception as e : # Catch unexpected errors logger . error ( f \"Unexpected error getting coordinates for annotation ' { element . id } ': { e } \" , exc_info = True , ) logger . exception ( e ) continue # Skip rendering this annotation # Basic validation (redundant with Scene checks, but safe) if rendered_coords is None or rendered_coords . size == 0 : logger . debug ( f \"Skipping annotation { element . id } due to missing/empty resolved coordinates.\" ) continue # Call the drawing function with the resolved coordinates try : svg_shapes = draw_func ( element , rendered_coords ) if svg_shapes : # Determine the parent group for the annotation parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shapes ) else : # Log error if the parent group is not found logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for annotation element { element . id } \" ) except Exception as e : logger . error ( f \"Error drawing annotation ' { element . id } ' (type { element_type . __name__ } ): { e } \" , exc_info = True , ) drawing . view_box = ( 0 , 0 , self . width , self . height ) return drawing def save_svg ( self , filename : str ) -> None : \"\"\"Renders the scene and saves it to an SVG file. Args: filename: The path to the output SVG file. \"\"\" drawing = self . render () drawing . save_svg ( filename ) logger . info ( f \"SVG saved to { filename } \" ) def get_svg_string ( self ) -> str : \"\"\"Renders the scene and returns the SVG content as a string. Returns: The SVG content as a string. \"\"\" drawing = self . render () return drawing . as_svg () __init__ ( scene , width = DEFAULT_WIDTH , height = DEFAULT_HEIGHT , background_color = DEFAULT_BG_COLOR , background_opacity = DEFAULT_BG_OPACITY , padding = DEFAULT_PADDING ) Initializes the SVGRenderer. Parameters: scene ( Scene ) \u2013 The Scene object containing the elements to render. width ( int , default: DEFAULT_WIDTH ) \u2013 Desired width of the SVG canvas. height ( int , default: DEFAULT_HEIGHT ) \u2013 Desired height of the SVG canvas. background_color ( Optional [ str ] , default: DEFAULT_BG_COLOR ) \u2013 Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity ( float , default: DEFAULT_BG_OPACITY ) \u2013 Background opacity (0.0 to 1.0). padding ( int , default: DEFAULT_PADDING ) \u2013 Padding around the content within the viewBox. Source code in src/flatprot/renderers/svg_renderer.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , scene : Scene , width : int = DEFAULT_WIDTH , height : int = DEFAULT_HEIGHT , background_color : Optional [ str ] = DEFAULT_BG_COLOR , background_opacity : float = DEFAULT_BG_OPACITY , padding : int = DEFAULT_PADDING , ): \"\"\"Initializes the SVGRenderer. Args: scene: The Scene object containing the elements to render. width: Desired width of the SVG canvas. height: Desired height of the SVG canvas. background_color: Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity: Background opacity (0.0 to 1.0). padding: Padding around the content within the viewBox. \"\"\" if not isinstance ( scene , Scene ): raise TypeError ( \"Renderer requires a valid Scene object.\" ) self . scene = scene self . width = width self . height = height self . background_color = background_color self . background_opacity = background_opacity self . padding = padding # Store padding self . _element_map : Dict [ str , BaseSceneElement ] = { e . id : e for e in self . scene . get_all_elements () } get_svg_string () Renders the scene and returns the SVG content as a string. Returns: str \u2013 The SVG content as a string. Source code in src/flatprot/renderers/svg_renderer.py 473 474 475 476 477 478 479 480 def get_svg_string ( self ) -> str : \"\"\"Renders the scene and returns the SVG content as a string. Returns: The SVG content as a string. \"\"\" drawing = self . render () return drawing . as_svg () render () Renders the scene to a drawsvg.Drawing object. Source code in src/flatprot/renderers/svg_renderer.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def render ( self ) -> Drawing : \"\"\"Renders the scene to a drawsvg.Drawing object.\"\"\" drawing = Drawing ( self . width , self . height ) svg_group_map : Dict [ str , Group ] = {} # 1. Add Background if self . background_color : drawing . append ( Rectangle ( 0 , 0 , self . width , self . height , fill = self . background_color , opacity = self . background_opacity , class_ = \"background\" , ) ) # 2. Build SVG Group Hierarchy root_group = Group ( id = \"flatprot-root\" ) drawing . append ( root_group ) svg_group_map [ \"flatprot-root\" ] = root_group # Register root for top_level_node in self . scene . top_level_nodes : self . _build_svg_hierarchy ( top_level_node , root_group , svg_group_map ) # 3. Prepare Render Data for Structure Elements try : ( _ , element_coords_cache , ) = self . _prepare_render_data () except Exception as e : logger . error ( f \"Failed to prepare render data: { e } \" , exc_info = True ) return drawing # 3.5 Collect and Sort All Renderable Elements try : ( sorted_structure_elements , sorted_annotations , sorted_connections , ) = self . _collect_and_sort_renderables () except Exception as e : logger . error ( f \"Failed to collect/sort renderables: { e } \" , exc_info = True ) return drawing # 4. Draw Structure Elements (sorted by depth) for depth , element in sorted_structure_elements : element_id = element . id element_type = type ( element ) # Get cached coordinates for the current element coords_2d = element_coords_cache . get ( element_id ) if coords_2d is None or coords_2d . size == 0 : logger . warning ( f \"Skipping draw for { element_id } : No valid cached 2D coordinates found.\" ) continue # Select and call the appropriate drawing function svg_shape : Optional [ Any ] = None try : if isinstance ( element , CoilSceneElement ): svg_shape = _draw_coil ( element , coords_2d ) elif isinstance ( element , HelixSceneElement ): svg_shape = _draw_helix ( element , coords_2d ) elif isinstance ( element , SheetSceneElement ): svg_shape = _draw_sheet ( element , coords_2d ) else : logger . warning ( f \"No specific draw function mapped for structure type: { element_type . __name__ } . Skipping { element_id } .\" ) continue except Exception as e : logger . error ( f \"Error calling draw function for { element_id } : { e } \" , exc_info = True ) continue # Append the generated shape to the correct SVG group if svg_shape : parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shape ) else : logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for element { element_id } \" ) # 5. Draw Connection Elements (sorted by depth) for _ , element in sorted_connections : connection_line_svg = _draw_connection_element ( element , self . scene . structure ) if connection_line_svg : # Determine the parent group for the connection parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( connection_line_svg ) else : # Log error if the parent group is not found in the map logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for connection element { element . id } \" ) # 6. Draw Annotation Elements (sorted by depth - effectively always last) for _ , element in sorted_annotations : element_type = type ( element ) draw_func = self . ANNOTATION_DRAW_MAP . get ( element_type ) if not draw_func : logger . warning ( f \"No drawing func for annotation type: { element_type . __name__ } \" ) continue try : # Calculate coordinates using the annotation's own method + resolver rendered_coords = element . get_coordinates ( self . scene . resolver ) except ( CoordinateCalculationError , SceneError , ValueError , TargetResidueNotFoundError , ) as e : # Catch expected errors during coordinate resolution/calculation logger . error ( f \"Could not get coordinates for annotation ' { element . id } ': { e } \" ) logger . exception ( e ) continue # Skip rendering this annotation except Exception as e : # Catch unexpected errors logger . error ( f \"Unexpected error getting coordinates for annotation ' { element . id } ': { e } \" , exc_info = True , ) logger . exception ( e ) continue # Skip rendering this annotation # Basic validation (redundant with Scene checks, but safe) if rendered_coords is None or rendered_coords . size == 0 : logger . debug ( f \"Skipping annotation { element . id } due to missing/empty resolved coordinates.\" ) continue # Call the drawing function with the resolved coordinates try : svg_shapes = draw_func ( element , rendered_coords ) if svg_shapes : # Determine the parent group for the annotation parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shapes ) else : # Log error if the parent group is not found logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for annotation element { element . id } \" ) except Exception as e : logger . error ( f \"Error drawing annotation ' { element . id } ' (type { element_type . __name__ } ): { e } \" , exc_info = True , ) drawing . view_box = ( 0 , 0 , self . width , self . height ) return drawing save_svg ( filename ) Renders the scene and saves it to an SVG file. Parameters: filename ( str ) \u2013 The path to the output SVG file. Source code in src/flatprot/renderers/svg_renderer.py 463 464 465 466 467 468 469 470 471 def save_svg ( self , filename : str ) -> None : \"\"\"Renders the scene and saves it to an SVG file. Args: filename: The path to the output SVG file. \"\"\" drawing = self . render () drawing . save_svg ( filename ) logger . info ( f \"SVG saved to { filename } \" ) options: show_root_heading: true members_order: source","title":"Rendering"},{"location":"api/rendering/#rendering-api","text":"This section documents the rendering system in FlatProt, responsible for converting the abstract Scene object into a concrete visual output format, primarily SVG.","title":"Rendering API"},{"location":"api/rendering/#rendering-concept","text":"Renderers act as the final stage in the visualization pipeline. They take a populated Scene object, which contains various SceneElement instances (like HelixSceneElement , PointAnnotation , etc.) already projected into a 2D canvas space with associated depth (Z) information. The renderer iterates through the elements in the scene, translates their geometric data and style attributes into the target output format (e.g., SVG tags and attributes), and produces the final file or output string.","title":"Rendering Concept"},{"location":"api/rendering/#peculiarities-and-design-choices","text":"Several aspects define how the FlatProt rendering system, particularly the SVGRenderer , operates: Depth Sorting (Z-Ordering): Before drawing, scene elements are typically sorted based on their calculated average depth (Z-coordinate). This ensures that elements closer to the viewer (lower Z, assuming standard projection) are drawn later, correctly occluding elements farther away. Annotation elements ( BaseAnnotationElement ) usually override the depth calculation to return a very high value (e.g., float('inf') ). This guarantees they are sorted last and therefore drawn on top of all structural elements. Scene Element to SVG Mapping: The renderer maps different SceneElement types to appropriate SVG tags: HelixSceneElement : Typically rendered as an SVG <path> or <polygon> representing the zigzag ribbon. SheetSceneElement : Rendered as an SVG <polygon> forming the arrowhead shape. CoilSceneElement : Rendered as an SVG <path> or <polyline> representing the smoothed line. PointAnnotation : Rendered as an SVG <circle> plus an SVG <text> element for the label. LineAnnotation : Rendered as an SVG <line> or <path> , potentially with <circle> elements for connectors and <polygon> for arrowheads, plus an SVG <text> element for the label. AreaAnnotation : Rendered as an SVG <path> or <polygon> representing the padded convex hull, plus an SVG <text> element for the label. Elements are often grouped within SVG <g> tags for organization, potentially grouped by type or parent element in the scene graph. Style Application: Style attributes defined in the BaseSceneStyle and its derivatives (e.g., HelixStyle , PointAnnotationStyle ) are translated into SVG presentation attributes. Examples: color or fill_color -> fill attribute. stroke_color or line_color -> stroke attribute. stroke_width -> stroke-width attribute. opacity or fill_opacity -> opacity or fill-opacity attributes. line_style or linestyle (tuple/array) -> stroke-dasharray attribute. Label styles ( label_color , label_font_size , etc.) -> corresponding attributes on the <text> element. Coordinate System & Canvas: The input Scene contains elements with coordinates already projected onto the 2D canvas (X, Y) plus depth (Z). The origin (0,0) is typically the top-left corner, consistent with SVG standards. The width and height provided to the renderer define the dimensions of the SVG canvas and its viewBox . These dimensions are controlled via CLI parameters (default: 1000x1000) and passed through the rendering pipeline. The project_structure_orthographically utility function handles the scaling and centering of the protein coordinates within this canvas space before they reach the scene/renderer. Focus on Static Output: The current implementation focuses on generating static SVG images. It generally does not utilize advanced SVG features like animations, complex gradients, filters, or embedded scripts.","title":"Peculiarities and Design Choices"},{"location":"api/rendering/#renderer-classes","text":"Renders a Scene object to an SVG Drawing. Attributes: scene \u2013 The Scene object to render. width \u2013 The width of the SVG canvas. height \u2013 The height of the SVG canvas. background_color \u2013 Optional background color for the SVG. background_opacity \u2013 Opacity for the background color. padding \u2013 Padding around the content within the viewBox. Source code in src/flatprot/renderers/svg_renderer.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 class SVGRenderer : \"\"\"Renders a Scene object to an SVG Drawing. Attributes: scene: The Scene object to render. width: The width of the SVG canvas. height: The height of the SVG canvas. background_color: Optional background color for the SVG. background_opacity: Opacity for the background color. padding: Padding around the content within the viewBox. \"\"\" DEFAULT_WIDTH = 600 DEFAULT_HEIGHT = 400 DEFAULT_BG_COLOR = \"#FFFFFF\" DEFAULT_BG_OPACITY = 1.0 DEFAULT_PADDING = 10 # Default padding in SVG units # Map element types to their drawing functions DRAW_MAP = { CoilSceneElement : _draw_coil , HelixSceneElement : _draw_helix , SheetSceneElement : _draw_sheet , # Annotations handled separately due to anchor calculation } ANNOTATION_DRAW_MAP = { PointAnnotation : _draw_point_annotation , LineAnnotation : _draw_line_annotation , AreaAnnotation : _draw_area_annotation , PositionAnnotation : _draw_position_annotation , } def __init__ ( self , scene : Scene , width : int = DEFAULT_WIDTH , height : int = DEFAULT_HEIGHT , background_color : Optional [ str ] = DEFAULT_BG_COLOR , background_opacity : float = DEFAULT_BG_OPACITY , padding : int = DEFAULT_PADDING , ): \"\"\"Initializes the SVGRenderer. Args: scene: The Scene object containing the elements to render. width: Desired width of the SVG canvas. height: Desired height of the SVG canvas. background_color: Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity: Background opacity (0.0 to 1.0). padding: Padding around the content within the viewBox. \"\"\" if not isinstance ( scene , Scene ): raise TypeError ( \"Renderer requires a valid Scene object.\" ) self . scene = scene self . width = width self . height = height self . background_color = background_color self . background_opacity = background_opacity self . padding = padding # Store padding self . _element_map : Dict [ str , BaseSceneElement ] = { e . id : e for e in self . scene . get_all_elements () } def _collect_and_sort_renderables ( self , ) -> Tuple [ List [ Tuple [ float , BaseStructureSceneElement ]], List [ Tuple [ float , BaseAnnotationElement ]], List [ Tuple [ float , Connection ]], ]: \"\"\"Traverses scene, collects renderable leaf nodes, sorts them by Z-depth.\"\"\" structure_elements : List [ Tuple [ float , BaseStructureSceneElement ]] = [] annotation_elements : List [ Tuple [ float , BaseAnnotationElement ]] = [] connection_elements : List [ Tuple [ float , Connection ]] = [] structure = self . scene . structure # Get structure once logger . debug ( \"--- Starting _collect_and_sort_renderables ---\" ) # DEBUG for element , hierarchy_depth in self . scene . traverse (): # Use scene traverse logger . debug ( f \"Traversing: { element . id } (Type: { type ( element ) . __name__ } , Depth: { hierarchy_depth } )\" ) # Skip invisible or group elements if not element . style . visibility : logger . debug ( f \"Skipping { element . id } : Invisible\" ) # DEBUG continue if isinstance ( element , SceneGroup ): logger . debug ( f \"Skipping { element . id } : Is SceneGroup\" ) # DEBUG continue render_depth = element . get_depth ( structure ) logger . debug ( f \"Calculated render_depth for { element . id } : { render_depth } \" ) # DEBUG if render_depth is None : logger . debug ( f \"Element { element . id } ( { type ( element ) . __name__ } ) has no rendering depth, skipping collection.\" ) # DEBUG: Changed message slightly continue # Categorize and collect if isinstance ( element , BaseStructureSceneElement ): logger . debug ( f \"Collecting Structure Element: { element . id } \" ) # DEBUG structure_elements . append (( render_depth , element )) elif isinstance ( element , BaseAnnotationElement ): # Depth is inf, but store it for consistency (sorting won't change) logger . debug ( f \"Collecting Annotation Element: { element . id } \" ) # DEBUG annotation_elements . append (( render_depth , element )) elif isinstance ( element , Connection ): logger . debug ( f \"Collecting Connection Element: { element . id } \" ) # DEBUG connection_elements . append (( render_depth , element )) # else: Ignore other potential non-group, non-renderable types logger . debug ( \"--- Finished _collect_and_sort_renderables ---\" ) # DEBUG # Sort structure elements by depth (ascending) structure_elements . sort ( key = lambda item : item [ 0 ]) # Annotations are naturally last due to depth=inf, but explicit sort doesn't hurt annotation_elements . sort ( key = lambda item : item [ 0 ]) # Sort connections by depth (ascending) - based on average of connected elements connection_elements . sort ( key = lambda item : item [ 0 ]) return structure_elements , annotation_elements , connection_elements def _build_svg_hierarchy ( self , element : BaseSceneElement , parent_svg_group : Group , svg_group_map : Dict [ str , Group ], ) -> None : \"\"\"Recursively builds SVG groups mirroring SceneGroups.\"\"\" if not isinstance ( element , SceneGroup ): return # Only process groups # Use group with transform svg_transform_str = str ( element . transforms ) current_svg_group = Group ( id = element . id , transform = svg_transform_str ) svg_group_map [ element . id ] = current_svg_group parent_svg_group . append ( current_svg_group ) # Recursively process children for child in element . children : self . _build_svg_hierarchy ( child , current_svg_group , svg_group_map ) def _prepare_render_data ( self , ) -> Tuple [ List [ BaseStructureSceneElement ], # Ordered structure elements Dict [ str , np . ndarray ], # Element ID -> coords_2d ]: \"\"\"Pre-calculates 2D coordinates and connection points for structure elements.\"\"\" # ordered_elements: List[BaseStructureSceneElement] = [] # Keep type hint element_coords_cache : Dict [ str , np . ndarray ] = {} structure = self . scene . structure # --- Get Sequentially Ordered Structure Elements --- # # Uses the new method in Scene to get elements sorted by chain and residue index try : ordered_elements = self . scene . get_sequential_structure_elements () # Filter for visibility *after* getting the ordered list ordered_elements = [ el for el in ordered_elements if el . style . visibility ] except Exception as e : logger . error ( f \"Error getting sequential structure elements: { e } \" , exc_info = True ) return [], {} # Return empty if fetching/sorting failed # --- Calculate Coordinates and Connection Points --- # for element in ordered_elements : element_id = element . id try : # CRITICAL ASSUMPTION: get_coordinates returns *final projected* 2D/3D coords. # If it returns raw 3D, projection needs to happen here. coords = element . get_coordinates ( structure ) if coords is None or coords . ndim != 2 or coords . shape [ 1 ] < 2 : logger . warning ( f \"Element { element_id } provided invalid coordinates shape: { coords . shape if coords is not None else 'None' } . Skipping.\" ) # Add placeholders to avoid key errors later if neighbors expect connections element_coords_cache [ element_id ] = np . empty (( 0 , 2 )) continue coords_2d = coords [:, : 2 ] # Ensure we only use X, Y element_coords_cache [ element_id ] = coords_2d except Exception as e : logger . error ( f \"Error preparing render data for element { element_id } : { e } \" , exc_info = True , ) # Add placeholders if preparation fails for an element element_coords_cache [ element_id ] = np . empty (( 0 , 2 )) continue return ordered_elements , element_coords_cache def render ( self ) -> Drawing : \"\"\"Renders the scene to a drawsvg.Drawing object.\"\"\" drawing = Drawing ( self . width , self . height ) svg_group_map : Dict [ str , Group ] = {} # 1. Add Background if self . background_color : drawing . append ( Rectangle ( 0 , 0 , self . width , self . height , fill = self . background_color , opacity = self . background_opacity , class_ = \"background\" , ) ) # 2. Build SVG Group Hierarchy root_group = Group ( id = \"flatprot-root\" ) drawing . append ( root_group ) svg_group_map [ \"flatprot-root\" ] = root_group # Register root for top_level_node in self . scene . top_level_nodes : self . _build_svg_hierarchy ( top_level_node , root_group , svg_group_map ) # 3. Prepare Render Data for Structure Elements try : ( _ , element_coords_cache , ) = self . _prepare_render_data () except Exception as e : logger . error ( f \"Failed to prepare render data: { e } \" , exc_info = True ) return drawing # 3.5 Collect and Sort All Renderable Elements try : ( sorted_structure_elements , sorted_annotations , sorted_connections , ) = self . _collect_and_sort_renderables () except Exception as e : logger . error ( f \"Failed to collect/sort renderables: { e } \" , exc_info = True ) return drawing # 4. Draw Structure Elements (sorted by depth) for depth , element in sorted_structure_elements : element_id = element . id element_type = type ( element ) # Get cached coordinates for the current element coords_2d = element_coords_cache . get ( element_id ) if coords_2d is None or coords_2d . size == 0 : logger . warning ( f \"Skipping draw for { element_id } : No valid cached 2D coordinates found.\" ) continue # Select and call the appropriate drawing function svg_shape : Optional [ Any ] = None try : if isinstance ( element , CoilSceneElement ): svg_shape = _draw_coil ( element , coords_2d ) elif isinstance ( element , HelixSceneElement ): svg_shape = _draw_helix ( element , coords_2d ) elif isinstance ( element , SheetSceneElement ): svg_shape = _draw_sheet ( element , coords_2d ) else : logger . warning ( f \"No specific draw function mapped for structure type: { element_type . __name__ } . Skipping { element_id } .\" ) continue except Exception as e : logger . error ( f \"Error calling draw function for { element_id } : { e } \" , exc_info = True ) continue # Append the generated shape to the correct SVG group if svg_shape : parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shape ) else : logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for element { element_id } \" ) # 5. Draw Connection Elements (sorted by depth) for _ , element in sorted_connections : connection_line_svg = _draw_connection_element ( element , self . scene . structure ) if connection_line_svg : # Determine the parent group for the connection parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( connection_line_svg ) else : # Log error if the parent group is not found in the map logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for connection element { element . id } \" ) # 6. Draw Annotation Elements (sorted by depth - effectively always last) for _ , element in sorted_annotations : element_type = type ( element ) draw_func = self . ANNOTATION_DRAW_MAP . get ( element_type ) if not draw_func : logger . warning ( f \"No drawing func for annotation type: { element_type . __name__ } \" ) continue try : # Calculate coordinates using the annotation's own method + resolver rendered_coords = element . get_coordinates ( self . scene . resolver ) except ( CoordinateCalculationError , SceneError , ValueError , TargetResidueNotFoundError , ) as e : # Catch expected errors during coordinate resolution/calculation logger . error ( f \"Could not get coordinates for annotation ' { element . id } ': { e } \" ) logger . exception ( e ) continue # Skip rendering this annotation except Exception as e : # Catch unexpected errors logger . error ( f \"Unexpected error getting coordinates for annotation ' { element . id } ': { e } \" , exc_info = True , ) logger . exception ( e ) continue # Skip rendering this annotation # Basic validation (redundant with Scene checks, but safe) if rendered_coords is None or rendered_coords . size == 0 : logger . debug ( f \"Skipping annotation { element . id } due to missing/empty resolved coordinates.\" ) continue # Call the drawing function with the resolved coordinates try : svg_shapes = draw_func ( element , rendered_coords ) if svg_shapes : # Determine the parent group for the annotation parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shapes ) else : # Log error if the parent group is not found logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for annotation element { element . id } \" ) except Exception as e : logger . error ( f \"Error drawing annotation ' { element . id } ' (type { element_type . __name__ } ): { e } \" , exc_info = True , ) drawing . view_box = ( 0 , 0 , self . width , self . height ) return drawing def save_svg ( self , filename : str ) -> None : \"\"\"Renders the scene and saves it to an SVG file. Args: filename: The path to the output SVG file. \"\"\" drawing = self . render () drawing . save_svg ( filename ) logger . info ( f \"SVG saved to { filename } \" ) def get_svg_string ( self ) -> str : \"\"\"Renders the scene and returns the SVG content as a string. Returns: The SVG content as a string. \"\"\" drawing = self . render () return drawing . as_svg ()","title":"Renderer Classes"},{"location":"api/rendering/#flatprot.renderers.svg_renderer.SVGRenderer.__init__","text":"Initializes the SVGRenderer. Parameters: scene ( Scene ) \u2013 The Scene object containing the elements to render. width ( int , default: DEFAULT_WIDTH ) \u2013 Desired width of the SVG canvas. height ( int , default: DEFAULT_HEIGHT ) \u2013 Desired height of the SVG canvas. background_color ( Optional [ str ] , default: DEFAULT_BG_COLOR ) \u2013 Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity ( float , default: DEFAULT_BG_OPACITY ) \u2013 Background opacity (0.0 to 1.0). padding ( int , default: DEFAULT_PADDING ) \u2013 Padding around the content within the viewBox. Source code in src/flatprot/renderers/svg_renderer.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , scene : Scene , width : int = DEFAULT_WIDTH , height : int = DEFAULT_HEIGHT , background_color : Optional [ str ] = DEFAULT_BG_COLOR , background_opacity : float = DEFAULT_BG_OPACITY , padding : int = DEFAULT_PADDING , ): \"\"\"Initializes the SVGRenderer. Args: scene: The Scene object containing the elements to render. width: Desired width of the SVG canvas. height: Desired height of the SVG canvas. background_color: Background color (CSS string, e.g., '#FFFFFF' or 'white'). None for transparent. background_opacity: Background opacity (0.0 to 1.0). padding: Padding around the content within the viewBox. \"\"\" if not isinstance ( scene , Scene ): raise TypeError ( \"Renderer requires a valid Scene object.\" ) self . scene = scene self . width = width self . height = height self . background_color = background_color self . background_opacity = background_opacity self . padding = padding # Store padding self . _element_map : Dict [ str , BaseSceneElement ] = { e . id : e for e in self . scene . get_all_elements () }","title":"__init__"},{"location":"api/rendering/#flatprot.renderers.svg_renderer.SVGRenderer.get_svg_string","text":"Renders the scene and returns the SVG content as a string. Returns: str \u2013 The SVG content as a string. Source code in src/flatprot/renderers/svg_renderer.py 473 474 475 476 477 478 479 480 def get_svg_string ( self ) -> str : \"\"\"Renders the scene and returns the SVG content as a string. Returns: The SVG content as a string. \"\"\" drawing = self . render () return drawing . as_svg ()","title":"get_svg_string"},{"location":"api/rendering/#flatprot.renderers.svg_renderer.SVGRenderer.render","text":"Renders the scene to a drawsvg.Drawing object. Source code in src/flatprot/renderers/svg_renderer.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def render ( self ) -> Drawing : \"\"\"Renders the scene to a drawsvg.Drawing object.\"\"\" drawing = Drawing ( self . width , self . height ) svg_group_map : Dict [ str , Group ] = {} # 1. Add Background if self . background_color : drawing . append ( Rectangle ( 0 , 0 , self . width , self . height , fill = self . background_color , opacity = self . background_opacity , class_ = \"background\" , ) ) # 2. Build SVG Group Hierarchy root_group = Group ( id = \"flatprot-root\" ) drawing . append ( root_group ) svg_group_map [ \"flatprot-root\" ] = root_group # Register root for top_level_node in self . scene . top_level_nodes : self . _build_svg_hierarchy ( top_level_node , root_group , svg_group_map ) # 3. Prepare Render Data for Structure Elements try : ( _ , element_coords_cache , ) = self . _prepare_render_data () except Exception as e : logger . error ( f \"Failed to prepare render data: { e } \" , exc_info = True ) return drawing # 3.5 Collect and Sort All Renderable Elements try : ( sorted_structure_elements , sorted_annotations , sorted_connections , ) = self . _collect_and_sort_renderables () except Exception as e : logger . error ( f \"Failed to collect/sort renderables: { e } \" , exc_info = True ) return drawing # 4. Draw Structure Elements (sorted by depth) for depth , element in sorted_structure_elements : element_id = element . id element_type = type ( element ) # Get cached coordinates for the current element coords_2d = element_coords_cache . get ( element_id ) if coords_2d is None or coords_2d . size == 0 : logger . warning ( f \"Skipping draw for { element_id } : No valid cached 2D coordinates found.\" ) continue # Select and call the appropriate drawing function svg_shape : Optional [ Any ] = None try : if isinstance ( element , CoilSceneElement ): svg_shape = _draw_coil ( element , coords_2d ) elif isinstance ( element , HelixSceneElement ): svg_shape = _draw_helix ( element , coords_2d ) elif isinstance ( element , SheetSceneElement ): svg_shape = _draw_sheet ( element , coords_2d ) else : logger . warning ( f \"No specific draw function mapped for structure type: { element_type . __name__ } . Skipping { element_id } .\" ) continue except Exception as e : logger . error ( f \"Error calling draw function for { element_id } : { e } \" , exc_info = True ) continue # Append the generated shape to the correct SVG group if svg_shape : parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shape ) else : logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for element { element_id } \" ) # 5. Draw Connection Elements (sorted by depth) for _ , element in sorted_connections : connection_line_svg = _draw_connection_element ( element , self . scene . structure ) if connection_line_svg : # Determine the parent group for the connection parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( connection_line_svg ) else : # Log error if the parent group is not found in the map logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for connection element { element . id } \" ) # 6. Draw Annotation Elements (sorted by depth - effectively always last) for _ , element in sorted_annotations : element_type = type ( element ) draw_func = self . ANNOTATION_DRAW_MAP . get ( element_type ) if not draw_func : logger . warning ( f \"No drawing func for annotation type: { element_type . __name__ } \" ) continue try : # Calculate coordinates using the annotation's own method + resolver rendered_coords = element . get_coordinates ( self . scene . resolver ) except ( CoordinateCalculationError , SceneError , ValueError , TargetResidueNotFoundError , ) as e : # Catch expected errors during coordinate resolution/calculation logger . error ( f \"Could not get coordinates for annotation ' { element . id } ': { e } \" ) logger . exception ( e ) continue # Skip rendering this annotation except Exception as e : # Catch unexpected errors logger . error ( f \"Unexpected error getting coordinates for annotation ' { element . id } ': { e } \" , exc_info = True , ) logger . exception ( e ) continue # Skip rendering this annotation # Basic validation (redundant with Scene checks, but safe) if rendered_coords is None or rendered_coords . size == 0 : logger . debug ( f \"Skipping annotation { element . id } due to missing/empty resolved coordinates.\" ) continue # Call the drawing function with the resolved coordinates try : svg_shapes = draw_func ( element , rendered_coords ) if svg_shapes : # Determine the parent group for the annotation parent_group_id = ( element . parent . id if element . parent else \"flatprot-root\" ) target_svg_group = svg_group_map . get ( parent_group_id ) if target_svg_group : target_svg_group . append ( svg_shapes ) else : # Log error if the parent group is not found logger . error ( f \"Could not find target SVG group ' { parent_group_id } ' for annotation element { element . id } \" ) except Exception as e : logger . error ( f \"Error drawing annotation ' { element . id } ' (type { element_type . __name__ } ): { e } \" , exc_info = True , ) drawing . view_box = ( 0 , 0 , self . width , self . height ) return drawing","title":"render"},{"location":"api/rendering/#flatprot.renderers.svg_renderer.SVGRenderer.save_svg","text":"Renders the scene and saves it to an SVG file. Parameters: filename ( str ) \u2013 The path to the output SVG file. Source code in src/flatprot/renderers/svg_renderer.py 463 464 465 466 467 468 469 470 471 def save_svg ( self , filename : str ) -> None : \"\"\"Renders the scene and saves it to an SVG file. Args: filename: The path to the output SVG file. \"\"\" drawing = self . render () drawing . save_svg ( filename ) logger . info ( f \"SVG saved to { filename } \" ) options: show_root_heading: true members_order: source","title":"save_svg"},{"location":"api/scene/","text":"Scene API This section documents the components related to the FlatProt Scene, which acts as a container for projected visual elements before rendering. Scene Concept The \"Scene\" in FlatProt acts as a container that holds all the elements to be visualized after they have been projected into 2D space (plus depth information). It's the bridge between the processed structural data and the final rendering step (e.g., SVG generation). Key concepts: Container: The Scene object holds a collection of SceneElement objects (like helices, sheets, coils, annotations). Coordinate Space: Elements within the scene typically exist in a 2D coordinate system (X, Y) representing the canvas, but they retain a Z-coordinate representing their depth relative to the viewer. Resolution: It often works with a CoordinateResolver to map abstract residue identifiers (like ChainID:ResidueIndex ) to the actual 2D+Depth coordinates within the scene's context. Z-Ordering: The depth information (Z-coordinate) associated with elements allows renderers to draw them in the correct order, ensuring closer elements obscure farther ones. Annotations are typically given a very high depth value to ensure they are drawn on top. Rendering: The Scene object, along with its elements and their associated styles, provides all the necessary information for a Renderer (like SVGRenderer ) to draw the final visualization. Main Scene Class The central container for all scene elements. Manages the scene graph for a protein structure visualization. The Scene holds the core protein structure data and a hierarchical tree of SceneElements (nodes), including SceneGroups. It provides methods to build and manipulate this tree, and to query elements based on residue information. Source code in src/flatprot/scene/scene.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 class Scene : \"\"\"Manages the scene graph for a protein structure visualization. The Scene holds the core protein structure data and a hierarchical tree of SceneElements (nodes), including SceneGroups. It provides methods to build and manipulate this tree, and to query elements based on residue information. \"\"\" def __init__ ( self , structure : Structure ): \"\"\"Initializes the Scene with a core Structure object. Args: structure: The core biological structure data. \"\"\" if not isinstance ( structure , Structure ): raise TypeError ( \"Scene must be initialized with a Structure object.\" ) self . _structure : Structure = structure # List of top-level nodes (elements with no parent) # The order here determines the base rendering order of top-level items. self . _nodes : List [ BaseSceneElement ] = [] # For quick lookups by ID self . _element_registry : Dict [ str , BaseSceneElement ] = {} # Create the coordinate resolver instance self . _resolver : Optional [ CoordinateResolver ] = None # Initialize as None @property def structure ( self ) -> Structure : \"\"\"Get the core Structure object associated with this scene.\"\"\" return self . _structure @property def top_level_nodes ( self ) -> List [ BaseSceneElement ]: \"\"\"Get the list of top-level nodes in the scene graph.\"\"\" return self . _nodes def get_element_by_id ( self , id : str ) -> Optional [ BaseSceneElement ]: \"\"\"Retrieve a scene element by its unique ID. Args: id: The ID of the element to find. Returns: The found BaseSceneElement or None if no element has that ID. \"\"\" return self . _element_registry . get ( id ) def _register_element ( self , element : BaseSceneElement ) -> None : \"\"\"Internal method to add an element to the ID registry.\"\"\" if element . id in self . _element_registry : # Raise specific error for duplicate IDs raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) self . _element_registry [ element . id ] = element def _unregister_element ( self , element : BaseSceneElement ) -> None : \"\"\"Internal method to remove an element from the ID registry.\"\"\" if element . id in self . _element_registry : del self . _element_registry [ element . id ] # Invalidate resolver cache if element affecting it is removed self . _resolver = None def add_element ( self , element : BaseSceneElement , parent_id : Optional [ str ] = None ) -> None : \"\"\"Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Args: element: The SceneElement to add. parent_id: The ID of the parent SceneGroup, or None for top-level. Raises: ValueError: If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError: If the element is not a BaseSceneElement. \"\"\" if not isinstance ( element , BaseSceneElement ): # Raise specific type error raise ElementTypeError ( f \"Object to add is not a BaseSceneElement subclass (got { type ( element ) . __name__ } ).\" ) # Check for existing element using ID registry (more reliable) if element . id in self . _element_registry : raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) # Check if element object seems already attached (should have parent=None) # This prevents adding the same *object* instance twice if somehow unregistered but still linked if element . parent is not None : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' already has a parent (' { element . parent . id } ') and cannot be added directly.\" ) # Check if it's already a top-level node (should not happen if parent is None check passes, but belt-and-suspenders) if element in self . _nodes : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' is already a top-level node.\" ) self . _register_element ( element ) # Register first parent : Optional [ SceneGroup ] = None if parent_id is not None : potential_parent = self . get_element_by_id ( parent_id ) if potential_parent is None : self . _unregister_element ( element ) # Rollback # Raise specific error for parent not found raise ParentNotFoundError ( f \"Parent group with ID ' { parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): self . _unregister_element ( element ) # Rollback # Raise specific type error for parent raise ElementTypeError ( f \"Specified parent ' { parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) parent = potential_parent try : if parent : # Let add_child raise its specific errors (e.g., ValueError for circular) parent . add_child ( element ) else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # Catch potential errors from add_child or _set_parent self . _unregister_element ( element ) # Rollback registration (also invalidates resolver) if parent is None and element in self . _nodes : self . _nodes . remove ( element ) # Rollback adding to top-level # Re-raise the original specific error, don't wrap raise e # Invalidate resolver cache if element affecting it is added self . _resolver = None def remove_element ( self , element_id : str ) -> None : \"\"\"Removes a SceneElement and its descendants from the scene graph by ID. Args: element_id: The ID of the SceneElement to remove. Raises: ValueError: If the element with the given ID is not found in the scene. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : # Raise specific error raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) # --- Collect nodes to remove --- (No change needed here) nodes_to_unregister : List [ BaseSceneElement ] = [] nodes_to_process : List [ BaseSceneElement ] = [ element ] while nodes_to_process : node = nodes_to_process . pop ( 0 ) # Check if already unregistered (in case of complex graph manipulations, though ideally not needed) if node . id not in self . _element_registry : continue nodes_to_unregister . append ( node ) if isinstance ( node , SceneGroup ): # Add children to process queue (create copy for safe iteration) nodes_to_process . extend ( list ( node . children )) for node in nodes_to_unregister : self . _unregister_element ( node ) # --- Detach the root element --- # parent = element . parent element_was_top_level = element in self . _nodes if parent : if parent . id in self . _element_registry and isinstance ( parent , SceneGroup ): try : parent . remove_child ( element ) except ValueError : # This *shouldn't* happen if graph is consistent. Treat as inconsistency. # Log it, but also raise a specific error. element . _set_parent ( None ) # Raise inconsistency error instead of just warning raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' not found in supposed parent ' { parent . id } ' children list during removal.\" ) else : # Parent reference exists but parent is invalid/unregistered. element . _set_parent ( None ) # This is also an inconsistency raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Parent ' { parent . id if parent else 'None' } ' of element ' { element . id } ' is invalid or unregistered during removal.\" ) elif element_was_top_level : # If it was supposed to be top-level, remove it self . _nodes . remove ( element ) element . _set_parent ( None ) else : # Element was registered, had no parent, but wasn't in top-level nodes. # This indicates an inconsistency. element . _set_parent ( None ) raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' was registered but not found in the scene graph structure (neither parented nor top-level).\" ) # Invalidate resolver cache since elements were removed self . _resolver = None def move_element ( self , element_id : str , new_parent_id : Optional [ str ] = None ) -> None : \"\"\"Moves a SceneElement identified by its ID to a new parent. Args: element_id: The ID of the SceneElement to move. new_parent_id: The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError: If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError: If the target parent is not a SceneGroup. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) current_parent = element . parent new_parent : Optional [ SceneGroup ] = None if new_parent_id is not None : potential_parent = self . get_element_by_id ( new_parent_id ) if potential_parent is None : raise ParentNotFoundError ( f \"New parent group with ID ' { new_parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): raise ElementTypeError ( f \"Target parent ' { new_parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) new_parent = potential_parent # Prevent circular dependency temp_check : Optional [ BaseSceneElement ] = new_parent while temp_check is not None : if temp_check is element : raise CircularDependencyError ( f \"Cannot move element ' { element_id } ' under ' { new_parent_id } ' - would create circular dependency.\" ) temp_check = temp_check . parent if current_parent is new_parent : return # --- Detach Phase --- # element_was_in_nodes = element in self . _nodes try : if current_parent : current_parent . remove_child ( element ) # Let SceneGroup handle internal parent update elif element_was_in_nodes : self . _nodes . remove ( element ) element . _set_parent ( None ) elif ( element . parent is None ): # Already detached, potentially inconsistent state raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' was already detached before move operation.\" ) else : # Should not be reachable if graph is consistent raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' in inconsistent state during detach phase of move.\" ) except ValueError as e : # If remove_child fails unexpectedly (e.g., element not found when it should be) element . _set_parent ( None ) # Force detachment raise SceneGraphInconsistencyError ( \"Scene Graph Inconsistency: \" + f \"Error detaching ' { element_id } ' from current parent ' { current_parent . id if current_parent else 'None' } ': { e } \" ) from e # Raise inconsistency # --- Attach Phase --- # try : if new_parent : new_parent . add_child ( element ) # Let add_child handle parent update & checks else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # If attaching fails, attempt rollback (reattach to original parent/location) rollback_msg = f \"Failed to attach element ' { element_id } ' to new parent ' { new_parent_id } ': { e } . Attempting rollback.\" try : if current_parent : current_parent . add_child ( element ) # Try adding back to original parent elif element_was_in_nodes : # If it was originally top-level element . _set_parent ( None ) self . _nodes . append ( element ) # If originally detached, leave it detached except Exception as rollback_e : # Rollback failed, graph is likely inconsistent msg = f \"Rollback failed after attach error for element ' { element . id } '. Scene graph may be inconsistent. Rollback error: { rollback_e } \" raise SceneGraphInconsistencyError ( msg ) from e # Raise inconsistency, chaining original error raise InvalidSceneOperationError ( rollback_msg ) from e # Invalidate resolver cache since element position changed self . _resolver = None def traverse ( self ) -> Generator [ Tuple [ BaseSceneElement , int ], None , None ]: \"\"\"Performs a depth-first traversal of the scene graph. Yields: Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). \"\"\" nodes_to_visit : List [ Tuple [ BaseSceneElement , int ]] = [ ( node , 0 ) for node in reversed ( self . _nodes ) ] visited_ids : Set [ str ] = set () while nodes_to_visit : element , depth = nodes_to_visit . pop () # Check registry in case node was removed during traversal (unlikely but possible) if element . id not in self . _element_registry or element . id in visited_ids : continue visited_ids . add ( element . id ) yield element , depth if isinstance ( element , SceneGroup ): # Add children to the stack in reverse order to maintain visit order # Ensure children are also still registered before adding children_to_add = [ ( child , depth + 1 ) for child in reversed ( element . children ) if child . id in self . _element_registry ] nodes_to_visit . extend ( children_to_add ) def get_all_elements ( self ) -> List [ BaseSceneElement ]: \"\"\"Returns a flat list of all elements in the scene graph. Returns: A list containing all BaseSceneElement objects registered in the scene. \"\"\" return list ( self . _element_registry . values ()) def get_sequential_structure_elements ( self ) -> List [ BaseStructureSceneElement ]: \"\"\" Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List[BaseStructureSceneElement]: Sorted list of structure elements. \"\"\" structure_elements : List [ BaseStructureSceneElement ] = [] for element in self . _element_registry . values (): if isinstance ( element , BaseStructureSceneElement ): structure_elements . append ( element ) def sort_key ( element : BaseStructureSceneElement ) -> Tuple [ str , int ]: primary_chain = \"~\" # Use ~ to sort after standard chain IDs start_residue = float ( \"inf\" ) # Sort elements without range last if element . residue_range_set and element . residue_range_set . ranges : # Use the first range (min start residue) for sorting key try : first_range = min ( element . residue_range_set . ranges , key = lambda r : ( r . chain_id , r . start ), ) primary_chain = first_range . chain_id start_residue = first_range . start except ( ValueError , TypeError ) as e : logger . warning ( f \"Could not determine sort key for element { element . id } due to range issue: { e } \" ) else : logger . debug ( f \"Structure element { element . id } has no residue range for sorting.\" ) # Return a tuple for multi-level sorting return ( primary_chain , start_residue ) try : structure_elements . sort ( key = sort_key ) except Exception as e : logger . error ( f \"Error sorting structure elements: { e } \" , exc_info = True ) # Return unsorted list in case of unexpected sorting error return structure_elements def __iter__ ( self ) -> Iterator [ BaseSceneElement ]: \"\"\"Iterate over the top-level nodes of the scene graph.\"\"\" return iter ( self . _nodes ) def __len__ ( self ) -> int : \"\"\"Return the total number of elements currently registered in the scene.\"\"\" return len ( self . _element_registry ) def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene.\"\"\" structure_id = getattr ( self . structure , \"id\" , \"N/A\" ) # Safely get structure ID return ( f \"<Scene structure_id=' { structure_id } ' \" f \"top_level_nodes= { len ( self . _nodes ) } total_elements= { len ( self ) } >\" ) # Lazily create resolver only when needed to avoid issues during Scene init @property def resolver ( self ) -> CoordinateResolver : \"\"\"Get the CoordinateResolver instance for this scene.\"\"\" if self . _resolver is None : # Pass the current element registry self . _resolver = CoordinateResolver ( self . _structure , self . _element_registry ) return self . _resolver resolver property Get the CoordinateResolver instance for this scene. structure property Get the core Structure object associated with this scene. top_level_nodes property Get the list of top-level nodes in the scene graph. __init__ ( structure ) Initializes the Scene with a core Structure object. Parameters: structure ( Structure ) \u2013 The core biological structure data. Source code in src/flatprot/scene/scene.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , structure : Structure ): \"\"\"Initializes the Scene with a core Structure object. Args: structure: The core biological structure data. \"\"\" if not isinstance ( structure , Structure ): raise TypeError ( \"Scene must be initialized with a Structure object.\" ) self . _structure : Structure = structure # List of top-level nodes (elements with no parent) # The order here determines the base rendering order of top-level items. self . _nodes : List [ BaseSceneElement ] = [] # For quick lookups by ID self . _element_registry : Dict [ str , BaseSceneElement ] = {} # Create the coordinate resolver instance self . _resolver : Optional [ CoordinateResolver ] = None # Initialize as None __iter__ () Iterate over the top-level nodes of the scene graph. Source code in src/flatprot/scene/scene.py 441 442 443 def __iter__ ( self ) -> Iterator [ BaseSceneElement ]: \"\"\"Iterate over the top-level nodes of the scene graph.\"\"\" return iter ( self . _nodes ) __len__ () Return the total number of elements currently registered in the scene. Source code in src/flatprot/scene/scene.py 445 446 447 def __len__ ( self ) -> int : \"\"\"Return the total number of elements currently registered in the scene.\"\"\" return len ( self . _element_registry ) __repr__ () Provide a string representation of the scene. Source code in src/flatprot/scene/scene.py 449 450 451 452 453 454 455 def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene.\"\"\" structure_id = getattr ( self . structure , \"id\" , \"N/A\" ) # Safely get structure ID return ( f \"<Scene structure_id=' { structure_id } ' \" f \"top_level_nodes= { len ( self . _nodes ) } total_elements= { len ( self ) } >\" ) add_element ( element , parent_id = None ) Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Parameters: element ( BaseSceneElement ) \u2013 The SceneElement to add. parent_id ( Optional [ str ] , default: None ) \u2013 The ID of the parent SceneGroup, or None for top-level. Raises: ValueError \u2013 If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError \u2013 If the element is not a BaseSceneElement. Source code in src/flatprot/scene/scene.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def add_element ( self , element : BaseSceneElement , parent_id : Optional [ str ] = None ) -> None : \"\"\"Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Args: element: The SceneElement to add. parent_id: The ID of the parent SceneGroup, or None for top-level. Raises: ValueError: If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError: If the element is not a BaseSceneElement. \"\"\" if not isinstance ( element , BaseSceneElement ): # Raise specific type error raise ElementTypeError ( f \"Object to add is not a BaseSceneElement subclass (got { type ( element ) . __name__ } ).\" ) # Check for existing element using ID registry (more reliable) if element . id in self . _element_registry : raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) # Check if element object seems already attached (should have parent=None) # This prevents adding the same *object* instance twice if somehow unregistered but still linked if element . parent is not None : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' already has a parent (' { element . parent . id } ') and cannot be added directly.\" ) # Check if it's already a top-level node (should not happen if parent is None check passes, but belt-and-suspenders) if element in self . _nodes : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' is already a top-level node.\" ) self . _register_element ( element ) # Register first parent : Optional [ SceneGroup ] = None if parent_id is not None : potential_parent = self . get_element_by_id ( parent_id ) if potential_parent is None : self . _unregister_element ( element ) # Rollback # Raise specific error for parent not found raise ParentNotFoundError ( f \"Parent group with ID ' { parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): self . _unregister_element ( element ) # Rollback # Raise specific type error for parent raise ElementTypeError ( f \"Specified parent ' { parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) parent = potential_parent try : if parent : # Let add_child raise its specific errors (e.g., ValueError for circular) parent . add_child ( element ) else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # Catch potential errors from add_child or _set_parent self . _unregister_element ( element ) # Rollback registration (also invalidates resolver) if parent is None and element in self . _nodes : self . _nodes . remove ( element ) # Rollback adding to top-level # Re-raise the original specific error, don't wrap raise e # Invalidate resolver cache if element affecting it is added self . _resolver = None get_all_elements () Returns a flat list of all elements in the scene graph. Returns: List [ BaseSceneElement ] \u2013 A list containing all BaseSceneElement objects registered in the scene. Source code in src/flatprot/scene/scene.py 384 385 386 387 388 389 390 def get_all_elements ( self ) -> List [ BaseSceneElement ]: \"\"\"Returns a flat list of all elements in the scene graph. Returns: A list containing all BaseSceneElement objects registered in the scene. \"\"\" return list ( self . _element_registry . values ()) get_element_by_id ( id ) Retrieve a scene element by its unique ID. Parameters: id ( str ) \u2013 The ID of the element to find. Returns: Optional [ BaseSceneElement ] \u2013 The found BaseSceneElement or None if no element has that ID. Source code in src/flatprot/scene/scene.py 67 68 69 70 71 72 73 74 75 76 def get_element_by_id ( self , id : str ) -> Optional [ BaseSceneElement ]: \"\"\"Retrieve a scene element by its unique ID. Args: id: The ID of the element to find. Returns: The found BaseSceneElement or None if no element has that ID. \"\"\" return self . _element_registry . get ( id ) get_sequential_structure_elements () Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List [ BaseStructureSceneElement ] \u2013 List[BaseStructureSceneElement]: Sorted list of structure elements. Source code in src/flatprot/scene/scene.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def get_sequential_structure_elements ( self ) -> List [ BaseStructureSceneElement ]: \"\"\" Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List[BaseStructureSceneElement]: Sorted list of structure elements. \"\"\" structure_elements : List [ BaseStructureSceneElement ] = [] for element in self . _element_registry . values (): if isinstance ( element , BaseStructureSceneElement ): structure_elements . append ( element ) def sort_key ( element : BaseStructureSceneElement ) -> Tuple [ str , int ]: primary_chain = \"~\" # Use ~ to sort after standard chain IDs start_residue = float ( \"inf\" ) # Sort elements without range last if element . residue_range_set and element . residue_range_set . ranges : # Use the first range (min start residue) for sorting key try : first_range = min ( element . residue_range_set . ranges , key = lambda r : ( r . chain_id , r . start ), ) primary_chain = first_range . chain_id start_residue = first_range . start except ( ValueError , TypeError ) as e : logger . warning ( f \"Could not determine sort key for element { element . id } due to range issue: { e } \" ) else : logger . debug ( f \"Structure element { element . id } has no residue range for sorting.\" ) # Return a tuple for multi-level sorting return ( primary_chain , start_residue ) try : structure_elements . sort ( key = sort_key ) except Exception as e : logger . error ( f \"Error sorting structure elements: { e } \" , exc_info = True ) # Return unsorted list in case of unexpected sorting error return structure_elements move_element ( element_id , new_parent_id = None ) Moves a SceneElement identified by its ID to a new parent. Parameters: element_id ( str ) \u2013 The ID of the SceneElement to move. new_parent_id ( Optional [ str ] , default: None ) \u2013 The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError \u2013 If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError \u2013 If the target parent is not a SceneGroup. Source code in src/flatprot/scene/scene.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def move_element ( self , element_id : str , new_parent_id : Optional [ str ] = None ) -> None : \"\"\"Moves a SceneElement identified by its ID to a new parent. Args: element_id: The ID of the SceneElement to move. new_parent_id: The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError: If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError: If the target parent is not a SceneGroup. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) current_parent = element . parent new_parent : Optional [ SceneGroup ] = None if new_parent_id is not None : potential_parent = self . get_element_by_id ( new_parent_id ) if potential_parent is None : raise ParentNotFoundError ( f \"New parent group with ID ' { new_parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): raise ElementTypeError ( f \"Target parent ' { new_parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) new_parent = potential_parent # Prevent circular dependency temp_check : Optional [ BaseSceneElement ] = new_parent while temp_check is not None : if temp_check is element : raise CircularDependencyError ( f \"Cannot move element ' { element_id } ' under ' { new_parent_id } ' - would create circular dependency.\" ) temp_check = temp_check . parent if current_parent is new_parent : return # --- Detach Phase --- # element_was_in_nodes = element in self . _nodes try : if current_parent : current_parent . remove_child ( element ) # Let SceneGroup handle internal parent update elif element_was_in_nodes : self . _nodes . remove ( element ) element . _set_parent ( None ) elif ( element . parent is None ): # Already detached, potentially inconsistent state raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' was already detached before move operation.\" ) else : # Should not be reachable if graph is consistent raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' in inconsistent state during detach phase of move.\" ) except ValueError as e : # If remove_child fails unexpectedly (e.g., element not found when it should be) element . _set_parent ( None ) # Force detachment raise SceneGraphInconsistencyError ( \"Scene Graph Inconsistency: \" + f \"Error detaching ' { element_id } ' from current parent ' { current_parent . id if current_parent else 'None' } ': { e } \" ) from e # Raise inconsistency # --- Attach Phase --- # try : if new_parent : new_parent . add_child ( element ) # Let add_child handle parent update & checks else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # If attaching fails, attempt rollback (reattach to original parent/location) rollback_msg = f \"Failed to attach element ' { element_id } ' to new parent ' { new_parent_id } ': { e } . Attempting rollback.\" try : if current_parent : current_parent . add_child ( element ) # Try adding back to original parent elif element_was_in_nodes : # If it was originally top-level element . _set_parent ( None ) self . _nodes . append ( element ) # If originally detached, leave it detached except Exception as rollback_e : # Rollback failed, graph is likely inconsistent msg = f \"Rollback failed after attach error for element ' { element . id } '. Scene graph may be inconsistent. Rollback error: { rollback_e } \" raise SceneGraphInconsistencyError ( msg ) from e # Raise inconsistency, chaining original error raise InvalidSceneOperationError ( rollback_msg ) from e # Invalidate resolver cache since element position changed self . _resolver = None remove_element ( element_id ) Removes a SceneElement and its descendants from the scene graph by ID. Parameters: element_id ( str ) \u2013 The ID of the SceneElement to remove. Raises: ValueError \u2013 If the element with the given ID is not found in the scene. Source code in src/flatprot/scene/scene.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def remove_element ( self , element_id : str ) -> None : \"\"\"Removes a SceneElement and its descendants from the scene graph by ID. Args: element_id: The ID of the SceneElement to remove. Raises: ValueError: If the element with the given ID is not found in the scene. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : # Raise specific error raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) # --- Collect nodes to remove --- (No change needed here) nodes_to_unregister : List [ BaseSceneElement ] = [] nodes_to_process : List [ BaseSceneElement ] = [ element ] while nodes_to_process : node = nodes_to_process . pop ( 0 ) # Check if already unregistered (in case of complex graph manipulations, though ideally not needed) if node . id not in self . _element_registry : continue nodes_to_unregister . append ( node ) if isinstance ( node , SceneGroup ): # Add children to process queue (create copy for safe iteration) nodes_to_process . extend ( list ( node . children )) for node in nodes_to_unregister : self . _unregister_element ( node ) # --- Detach the root element --- # parent = element . parent element_was_top_level = element in self . _nodes if parent : if parent . id in self . _element_registry and isinstance ( parent , SceneGroup ): try : parent . remove_child ( element ) except ValueError : # This *shouldn't* happen if graph is consistent. Treat as inconsistency. # Log it, but also raise a specific error. element . _set_parent ( None ) # Raise inconsistency error instead of just warning raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' not found in supposed parent ' { parent . id } ' children list during removal.\" ) else : # Parent reference exists but parent is invalid/unregistered. element . _set_parent ( None ) # This is also an inconsistency raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Parent ' { parent . id if parent else 'None' } ' of element ' { element . id } ' is invalid or unregistered during removal.\" ) elif element_was_top_level : # If it was supposed to be top-level, remove it self . _nodes . remove ( element ) element . _set_parent ( None ) else : # Element was registered, had no parent, but wasn't in top-level nodes. # This indicates an inconsistency. element . _set_parent ( None ) raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' was registered but not found in the scene graph structure (neither parented nor top-level).\" ) # Invalidate resolver cache since elements were removed self . _resolver = None traverse () Performs a depth-first traversal of the scene graph. Yields: Tuple [ BaseSceneElement , int ] \u2013 Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). Source code in src/flatprot/scene/scene.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def traverse ( self ) -> Generator [ Tuple [ BaseSceneElement , int ], None , None ]: \"\"\"Performs a depth-first traversal of the scene graph. Yields: Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). \"\"\" nodes_to_visit : List [ Tuple [ BaseSceneElement , int ]] = [ ( node , 0 ) for node in reversed ( self . _nodes ) ] visited_ids : Set [ str ] = set () while nodes_to_visit : element , depth = nodes_to_visit . pop () # Check registry in case node was removed during traversal (unlikely but possible) if element . id not in self . _element_registry or element . id in visited_ids : continue visited_ids . add ( element . id ) yield element , depth if isinstance ( element , SceneGroup ): # Add children to the stack in reverse order to maintain visit order # Ensure children are also still registered before adding children_to_add = [ ( child , depth + 1 ) for child in reversed ( element . children ) if child . id in self . _element_registry ] nodes_to_visit . extend ( children_to_add ) options: show_root_heading: true members_order: source Base Classes Abstract base classes for elements and styles within the scene. Bases: ABC , Generic [ StyleType ] Abstract base class for all elements within a scene graph. This class is generic and requires a specific StyleType that inherits from BaseSceneStyle. Source code in src/flatprot/scene/base_element.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class BaseSceneElement ( ABC , Generic [ StyleType ]): \"\"\"Abstract base class for all elements within a scene graph. This class is generic and requires a specific StyleType that inherits from BaseSceneStyle. \"\"\" def __init__ ( self , id : str , style : Optional [ StyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseSceneElement. Args: id: A unique identifier for this scene element. style: A style instance for this element. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( id , str ) or not id : raise ValueError ( \"SceneElement ID must be a non-empty string.\" ) self . id : str = id self . _style : Optional [ StyleType ] = style or self . default_style self . _parent : Optional [ SceneGroupType ] = parent @property def parent ( self ) -> Optional [ SceneGroupType ]: \"\"\"Get the parent group of this element.\"\"\" return self . _parent # Keep internal setter for parent relationship management by Scene/SceneGroup def _set_parent ( self , value : Optional [ SceneGroupType ]) -> None : \"\"\"Internal method to set the parent group. Should be called by Scene/SceneGroup.\"\"\" # Basic type check, assumes SceneGroup will inherit from BaseSceneElement if value is not None and not isinstance ( value , BaseSceneElement ): # A more specific check like isinstance(value, SceneGroup) would be ideal # but causes circular dependency issues without careful structuring or protocols. # This provides a basic safeguard. We expect SceneGroup to inherit BaseSceneElement. raise TypeError ( \"Parent must be a SceneGroup (subclass of BaseSceneElement).\" ) self . _parent = value @property @abstractmethod def default_style ( self ) -> StyleType : \"\"\"Provides the default style instance for this element type. Subclasses must implement this property. Returns: An instance of the specific StyleType for this element. \"\"\" raise NotImplementedError @property def style ( self ) -> StyleType : \"\"\"Get the effective style for this element (instance-specific or default).\"\"\" return self . _style if self . _style is not None else self . default_style () def update_style ( self , new_style : StyleType ) -> None : \"\"\"Update the instance-specific style of this element. Args: new_style: The new style object to apply. \"\"\" # Ensure the provided style is compatible # Note: isinstance check might be too strict if subclasses of the style are allowed. # Adjust check if necessary based on desired style inheritance behavior. expected_style_type = self . default_style () . __class__ if not isinstance ( new_style , expected_style_type ): raise TypeError ( f \"Invalid style type. Expected { expected_style_type . __name__ } , \" f \"got { type ( new_style ) . __name__ } .\" ) self . _style = new_style @abstractmethod def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A float representing the depth, or None if depth cannot be determined or is not applicable (e.g., for groups). \"\"\" raise NotImplementedError def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene element.\"\"\" parent_id = f \"' { self . _parent . id } '\" if self . _parent else None style_source = \"default\" if self . _style is None else \"instance\" # Safely get range representation, default to 'N/A' if not present range_repr = str ( getattr ( self , \"residue_range_set\" , \"N/A\" )) range_str = f \" range=' { range_repr } '\" if range_repr != \"N/A\" else \"\" target_repr = str ( getattr ( self , \"target\" , \"N/A\" )) target_str = f \" target=' { target_repr } '\" if target_repr != \"N/A\" else \"\" return ( f \"< { self . __class__ . __name__ } id=' { self . id } ' { range_str }{ target_str } \" f \"parent= { parent_id } style_source= { style_source } >\" ) default_style abstractmethod property Provides the default style instance for this element type. Subclasses must implement this property. Returns: StyleType \u2013 An instance of the specific StyleType for this element. parent property Get the parent group of this element. style property Get the effective style for this element (instance-specific or default). __init__ ( id , style = None , parent = None ) Initializes a BaseSceneElement. Parameters: id ( str ) \u2013 A unique identifier for this scene element. style ( Optional [ StyleType ] , default: None ) \u2013 A style instance for this element. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/base_element.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , id : str , style : Optional [ StyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseSceneElement. Args: id: A unique identifier for this scene element. style: A style instance for this element. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( id , str ) or not id : raise ValueError ( \"SceneElement ID must be a non-empty string.\" ) self . id : str = id self . _style : Optional [ StyleType ] = style or self . default_style self . _parent : Optional [ SceneGroupType ] = parent __repr__ () Provide a string representation of the scene element. Source code in src/flatprot/scene/base_element.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene element.\"\"\" parent_id = f \"' { self . _parent . id } '\" if self . _parent else None style_source = \"default\" if self . _style is None else \"instance\" # Safely get range representation, default to 'N/A' if not present range_repr = str ( getattr ( self , \"residue_range_set\" , \"N/A\" )) range_str = f \" range=' { range_repr } '\" if range_repr != \"N/A\" else \"\" target_repr = str ( getattr ( self , \"target\" , \"N/A\" )) target_str = f \" target=' { target_repr } '\" if target_repr != \"N/A\" else \"\" return ( f \"< { self . __class__ . __name__ } id=' { self . id } ' { range_str }{ target_str } \" f \"parent= { parent_id } style_source= { style_source } >\" ) get_depth ( structure ) abstractmethod Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ float ] \u2013 A float representing the depth, or None if depth cannot be determined Optional [ float ] \u2013 or is not applicable (e.g., for groups). Source code in src/flatprot/scene/base_element.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A float representing the depth, or None if depth cannot be determined or is not applicable (e.g., for groups). \"\"\" raise NotImplementedError update_style ( new_style ) Update the instance-specific style of this element. Parameters: new_style ( StyleType ) \u2013 The new style object to apply. Source code in src/flatprot/scene/base_element.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def update_style ( self , new_style : StyleType ) -> None : \"\"\"Update the instance-specific style of this element. Args: new_style: The new style object to apply. \"\"\" # Ensure the provided style is compatible # Note: isinstance check might be too strict if subclasses of the style are allowed. # Adjust check if necessary based on desired style inheritance behavior. expected_style_type = self . default_style () . __class__ if not isinstance ( new_style , expected_style_type ): raise TypeError ( f \"Invalid style type. Expected { expected_style_type . __name__ } , \" f \"got { type ( new_style ) . __name__ } .\" ) self . _style = new_style options: show_root_heading: true members_order: source Bases: BaseModel Base class for all scene element style definitions using Pydantic. Source code in src/flatprot/scene/base_element.py 19 20 21 22 23 24 25 26 27 28 29 30 class BaseSceneStyle ( BaseModel ): \"\"\"Base class for all scene element style definitions using Pydantic.\"\"\" visibility : bool = Field ( default = True , description = \"Whether the element is visible.\" ) opacity : float = Field ( default = 1.0 , ge = 0.0 , le = 1.0 , description = \"Opacity of the element (0.0 to 1.0).\" ) # Add other common style attributes here if needed later model_config = { \"extra\" : \"forbid\" } # Forbid extra fields options: show_root_heading: true members_order: source Structure Elements Classes representing secondary structure elements within the scene. Bases: BaseSceneElement [ StructureStyleType ] , ABC , Generic [ StructureStyleType ] Abstract base class for scene elements representing structural components. Automatically generates an ID based on the subclass type and residue range. Requires a concrete style type inheriting from BaseStructureStyle. Source code in src/flatprot/scene/structure/base_structure.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class BaseStructureSceneElement ( BaseSceneElement [ StructureStyleType ], ABC , Generic [ StructureStyleType ] ): \"\"\"Abstract base class for scene elements representing structural components. Automatically generates an ID based on the subclass type and residue range. Requires a concrete style type inheriting from BaseStructureStyle. \"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ StructureStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Args: residue_range_set: The set of residue ranges this element represents. style: An optional specific style instance for this element. If None, the default style defined by the subclass's `default_style` property will be used at access time. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" # Generate the ID *before* calling super().__init__ # Uses the concrete class's name (e.g., \"Helix\") generated_id = self . _generate_id ( self . __class__ , residue_range_set ) self . residue_range_set = residue_range_set # Pass the potentially None style to the BaseSceneElement constructor. # BaseSceneElement's `style` property handles returning the default # style if the instance's `_style` attribute is None. super () . __init__ ( id = generated_id , style = style , # Pass the direct input style (can be None) parent = parent , ) @staticmethod def _generate_id ( cls : type , residue_range_set : ResidueRangeSet ) -> str : \"\"\"Generates a unique ID based on class name and residue range set.\"\"\" # Ensure the string representation of the range set is canonical and ID-friendly # Replace spaces, commas, and colons to create a valid identifier part. # Sorting ranges within the set ensures canonical representation if order matters. # Assuming ResidueRangeSet.__str__ provides a consistent, sorted representation. range_repr = ( str ( residue_range_set ) . replace ( \" \" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \":\" , \"-\" ) ) return f \" { cls . __name__ } - { range_repr } \" @abstractmethod def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's `residue_range_set` to query the provided `structure` object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) suitable for rendering (X, Y, Depth). \"\"\" raise NotImplementedError # Concrete subclasses (Helix, Sheet, etc.) MUST implement default_style @property @abstractmethod def default_style ( self ) -> StructureStyleType : \"\"\"Provides the default style instance for this specific element type. Concrete subclasses (e.g., Helix, Sheet) must implement this property. Returns: An instance of the specific StyleType (e.g., HelixStyle) for this element. \"\"\" raise NotImplementedError def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their `get_coordinates` method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), or None if the residue is not found or its coordinate cannot be determined. \"\"\" try : # Check if the residue belongs to the range represented by this element if residue not in self . residue_range_set : logger . debug ( f \"Residue { residue } not in range set { self . residue_range_set } for element ' { self . id } '\" ) return None chain = structure [ residue . chain_id ] # Check if the residue index exists in this chain's mapping if residue . residue_index not in chain : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None coord_index = chain . coordinate_index ( residue . residue_index ) if not ( 0 <= coord_index < len ( structure . coordinates )): struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Coordinate index { coord_index } out of bounds for residue { residue } in structure ' { struct_id } ' (element ' { self . id } ').\" ) return structure . coordinates [ coord_index ] except KeyError : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None except ( IndexError , AttributeError ) as e : struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Error retrieving coordinate for { residue } in structure ' { struct_id } ' (element ' { self . id } '): { e } \" ) from e def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: The mean depth as a float, or None if no coordinates are found. \"\"\" # Get coordinates directly from the element's get_coordinates method # which handles different element types appropriately coords = self . get_coordinates ( structure ) if coords is None or len ( coords ) == 0 : return None # Extract depth values (Z-coordinate) from the coordinates depths = coords [:, 2 ] if len ( depths ) == 0 : return None return float ( np . mean ( depths )) def is_adjacent_to ( self , other : \"BaseStructureSceneElement\" ) -> bool : \"\"\"Check if this element is adjacent to another element. Args: other: The other element to check adjacency with. Returns: True if the elements are adjacent, False otherwise. \"\"\" if not isinstance ( other , BaseStructureSceneElement ): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return self . residue_range_set . is_adjacent_to ( other . residue_range_set ) @abstractmethod def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError @abstractmethod def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError default_style abstractmethod property Provides the default style instance for this specific element type. Concrete subclasses (e.g., Helix, Sheet) must implement this property. Returns: StructureStyleType \u2013 An instance of the specific StyleType (e.g., HelixStyle) for this element. __init__ ( residue_range_set , style = None , parent = None ) Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Parameters: residue_range_set ( ResidueRangeSet ) \u2013 The set of residue ranges this element represents. style ( Optional [ StructureStyleType ] , default: None ) \u2013 An optional specific style instance for this element. If None, the default style defined by the subclass's default_style property will be used at access time. metadata \u2013 Optional dictionary for storing arbitrary metadata. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/structure/base_structure.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ StructureStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Args: residue_range_set: The set of residue ranges this element represents. style: An optional specific style instance for this element. If None, the default style defined by the subclass's `default_style` property will be used at access time. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" # Generate the ID *before* calling super().__init__ # Uses the concrete class's name (e.g., \"Helix\") generated_id = self . _generate_id ( self . __class__ , residue_range_set ) self . residue_range_set = residue_range_set # Pass the potentially None style to the BaseSceneElement constructor. # BaseSceneElement's `style` property handles returning the default # style if the instance's `_style` attribute is None. super () . __init__ ( id = generated_id , style = style , # Pass the direct input style (can be None) parent = parent , ) get_coordinate_at_residue ( residue , structure ) Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their get_coordinates method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the 2D point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth data. Returns: Optional [ ndarray ] \u2013 A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), Optional [ ndarray ] \u2013 or None if the residue is not found or its coordinate cannot be determined. Source code in src/flatprot/scene/structure/base_structure.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their `get_coordinates` method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), or None if the residue is not found or its coordinate cannot be determined. \"\"\" try : # Check if the residue belongs to the range represented by this element if residue not in self . residue_range_set : logger . debug ( f \"Residue { residue } not in range set { self . residue_range_set } for element ' { self . id } '\" ) return None chain = structure [ residue . chain_id ] # Check if the residue index exists in this chain's mapping if residue . residue_index not in chain : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None coord_index = chain . coordinate_index ( residue . residue_index ) if not ( 0 <= coord_index < len ( structure . coordinates )): struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Coordinate index { coord_index } out of bounds for residue { residue } in structure ' { struct_id } ' (element ' { self . id } ').\" ) return structure . coordinates [ coord_index ] except KeyError : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None except ( IndexError , AttributeError ) as e : struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Error retrieving coordinate for { residue } in structure ' { struct_id } ' (element ' { self . id } '): { e } \" ) from e get_coordinates ( structure ) abstractmethod Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's residue_range_set to query the provided structure object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ ndarray ] \u2013 A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) Optional [ ndarray ] \u2013 suitable for rendering (X, Y, Depth). Source code in src/flatprot/scene/structure/base_structure.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @abstractmethod def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's `residue_range_set` to query the provided `structure` object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) suitable for rendering (X, Y, Depth). \"\"\" raise NotImplementedError get_depth ( structure ) Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ float ] \u2013 The mean depth as a float, or None if no coordinates are found. Source code in src/flatprot/scene/structure/base_structure.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: The mean depth as a float, or None if no coordinates are found. \"\"\" # Get coordinates directly from the element's get_coordinates method # which handles different element types appropriately coords = self . get_coordinates ( structure ) if coords is None or len ( coords ) == 0 : return None # Extract depth values (Z-coordinate) from the coordinates depths = coords [:, 2 ] if len ( depths ) == 0 : return None return float ( np . mean ( depths )) get_end_connection_point ( structure ) abstractmethod Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Parameters: structure ( Structure ) \u2013 The core Structure object with pre-projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if not applicable/determinable. Source code in src/flatprot/scene/structure/base_structure.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @abstractmethod def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError get_start_connection_point ( structure ) abstractmethod Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Parameters: structure ( Structure ) \u2013 The core Structure object with pre-projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if not applicable/determinable. Source code in src/flatprot/scene/structure/base_structure.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 @abstractmethod def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError is_adjacent_to ( other ) Check if this element is adjacent to another element. Parameters: other ( BaseStructureSceneElement ) \u2013 The other element to check adjacency with. Returns: bool \u2013 True if the elements are adjacent, False otherwise. Source code in src/flatprot/scene/structure/base_structure.py 218 219 220 221 222 223 224 225 226 227 228 229 230 def is_adjacent_to ( self , other : \"BaseStructureSceneElement\" ) -> bool : \"\"\"Check if this element is adjacent to another element. Args: other: The other element to check adjacency with. Returns: True if the elements are adjacent, False otherwise. \"\"\" if not isinstance ( other , BaseStructureSceneElement ): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return self . residue_range_set . is_adjacent_to ( other . residue_range_set ) options: show_root_heading: true Bases: BaseSceneStyle Base style for elements representing parts of the protein structure. Source code in src/flatprot/scene/structure/base_structure.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class BaseStructureStyle ( BaseSceneStyle ): \"\"\"Base style for elements representing parts of the protein structure.\"\"\" color : Color = Field ( default = Color (( 0.5 , 0.5 , 0.5 )), description = \"Default color for the element (hex string). Grey.\" , ) stroke_color : Color = Field ( default = Color (( 0.0 , 0.0 , 0.0 )), description = \"Color for the stroke (hex string). Black.\" , ) stroke_width : float = Field ( default = 1.0 , ge = 0.0 , description = \"Line width for stroke.\" ) opacity : float = Field ( default = 1.0 , ge = 0.0 , le = 1.0 , description = \"Opacity for the element.\" ) options: show_root_heading: true Bases: BaseStructureSceneElement [ HelixStyle ] Represents an Alpha Helix segment, visualized as a zigzag ribbon. Source code in src/flatprot/scene/structure/helix.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 class HelixSceneElement ( BaseStructureSceneElement [ HelixStyle ]): \"\"\"Represents an Alpha Helix segment, visualized as a zigzag ribbon.\"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ HelixStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the HelixSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated zigzag coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> HelixStyle : \"\"\"Provides the default style for Helix elements.\"\"\" return HelixStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this helix.\"\"\" coords_list = [] if not self . residue_range_set . ranges : # Cannot get coordinates if no ranges are defined. raise CoordinateCalculationError ( f \"Cannot get coordinates for Helix ' { self . id } ': no residue ranges defined.\" ) helix_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ helix_range . chain_id ] for res_idx in range ( helix_range . start , helix_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : # Coordinate index out of bounds. raise CoordinateCalculationError ( f \"Coordinate index { coord_idx } out of bounds for residue { helix_range . chain_id } : { res_idx } in structure.\" ) else : # Residue not found in chain coordinate map. raise CoordinateCalculationError ( f \"Residue { helix_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : # Error fetching coordinates raise CoordinateCalculationError ( f \"Error fetching coordinates for helix ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the ribbon outline coordinates [X, Y, Depth], or a simple line [start, end] if below min_helix_length. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) if self . _original_coords_len < 2 : # If only one residue, return just that point self . _cached_display_coords = np . array ([ original_coords [ 0 ]]) return self . _cached_display_coords # If too short, return a simple line (start and end points) if self . _original_coords_len < self . style . min_helix_length : self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Calculate zigzag points start_point_3d = original_coords [ 0 ] end_point_3d = original_coords [ - 1 ] zigzag_coords = calculate_zigzag_points ( start_point_3d , end_point_3d , self . style . ribbon_thickness , self . style . wavelength , self . style . amplitude , ) if ( zigzag_coords is None and self . _original_coords_len >= 2 ): # Log only if zigzag expected but failed raise CoordinateCalculationError ( f \"Could not generate zigzag points for helix ' { self . id } ' (length= { self . _original_coords_len } ), likely zero length between endpoints.\" ) self . _cached_display_coords = zigzag_coords return self . _cached_display_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] corresponding to the residue's position. \"\"\" # 1. Ensure display coordinates are calculated display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None element_range = self . residue_range_set . ranges [ 0 ] # Assuming single range if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None except Exception : return None # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Should be shape (1, 3) # 4. Handle the case where a simple line was drawn if len ( display_coords ) == 2 : # Linear interpolation along the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Handle the zigzag ribbon case # display_coords contains top points then bottom points reversed num_wave_points = len ( display_coords ) // 2 # Number of points along one edge if num_wave_points < 1 : raise CoordinateCalculationError ( f \"Invalid number of wave points ( { num_wave_points } ) for helix { self . id } \" ) # Map original sequence index to fractional position along the wave points (0 to num_wave_points-1) mapped_wave_frac = ( original_sequence_index * ( num_wave_points - 1 )) / ( self . _original_coords_len - 1 ) # Find the indices in the display_coords array idx_low = int ( np . floor ( mapped_wave_frac )) idx_high = min ( idx_low + 1 , num_wave_points - 1 ) idx_low = min ( idx_low , num_wave_points - 1 ) # Clamp low index too frac = mapped_wave_frac - idx_low # Get corresponding points on top and bottom edges top_low = display_coords [ idx_low ] top_high = display_coords [ idx_high ] # Bottom indices are reversed: num_total - 1 - index bottom_low = display_coords [ len ( display_coords ) - 1 - idx_low ] bottom_high = display_coords [ len ( display_coords ) - 1 - idx_high ] # Interpolate along top and bottom edges interp_top = top_low * ( 1 - frac ) + top_high * frac interp_bottom = bottom_low * ( 1 - frac ) + bottom_high * frac # Return the midpoint between the interpolated top and bottom points return ( interp_top + interp_bottom ) / 2.0 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 0 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the starting edge # First point (top edge start) = coords_2d[0] # Corresponding bottom point (bottom edge start) = coords_2d[-1] return ( coords_2d [ 0 ] + coords_2d [ - 1 ]) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ 0 ] # Return the first point def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 1 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the ending edge # Last point of top edge = coords_2d[num_edge_points - 1] # Corresponding last point of bottom edge = coords_2d[num_edge_points] num_edge_points = len ( coords_2d ) // 2 last_top_point = coords_2d [ num_edge_points - 1 ] last_bottom_point = coords_2d [ num_edge_points ] return ( last_top_point + last_bottom_point ) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ - 1 ] # Return the last point default_style property Provides the default style for Helix elements. __init__ ( residue_range_set , style = None , parent = None ) Initializes the HelixSceneElement. Source code in src/flatprot/scene/structure/helix.py 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ HelixStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the HelixSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated zigzag coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None get_coordinate_at_residue ( residue , structure ) Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] corresponding to the residue's position. Source code in src/flatprot/scene/structure/helix.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] corresponding to the residue's position. \"\"\" # 1. Ensure display coordinates are calculated display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None element_range = self . residue_range_set . ranges [ 0 ] # Assuming single range if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None except Exception : return None # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Should be shape (1, 3) # 4. Handle the case where a simple line was drawn if len ( display_coords ) == 2 : # Linear interpolation along the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Handle the zigzag ribbon case # display_coords contains top points then bottom points reversed num_wave_points = len ( display_coords ) // 2 # Number of points along one edge if num_wave_points < 1 : raise CoordinateCalculationError ( f \"Invalid number of wave points ( { num_wave_points } ) for helix { self . id } \" ) # Map original sequence index to fractional position along the wave points (0 to num_wave_points-1) mapped_wave_frac = ( original_sequence_index * ( num_wave_points - 1 )) / ( self . _original_coords_len - 1 ) # Find the indices in the display_coords array idx_low = int ( np . floor ( mapped_wave_frac )) idx_high = min ( idx_low + 1 , num_wave_points - 1 ) idx_low = min ( idx_low , num_wave_points - 1 ) # Clamp low index too frac = mapped_wave_frac - idx_low # Get corresponding points on top and bottom edges top_low = display_coords [ idx_low ] top_high = display_coords [ idx_high ] # Bottom indices are reversed: num_total - 1 - index bottom_low = display_coords [ len ( display_coords ) - 1 - idx_low ] bottom_high = display_coords [ len ( display_coords ) - 1 - idx_high ] # Interpolate along top and bottom edges interp_top = top_low * ( 1 - frac ) + top_high * frac interp_bottom = bottom_low * ( 1 - frac ) + bottom_high * frac # Return the midpoint between the interpolated top and bottom points return ( interp_top + interp_bottom ) / 2.0 get_coordinates ( structure ) Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of the ribbon outline coordinates [X, Y, Depth], Optional [ ndarray ] \u2013 or a simple line [start, end] if below min_helix_length. Source code in src/flatprot/scene/structure/helix.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the ribbon outline coordinates [X, Y, Depth], or a simple line [start, end] if below min_helix_length. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) if self . _original_coords_len < 2 : # If only one residue, return just that point self . _cached_display_coords = np . array ([ original_coords [ 0 ]]) return self . _cached_display_coords # If too short, return a simple line (start and end points) if self . _original_coords_len < self . style . min_helix_length : self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Calculate zigzag points start_point_3d = original_coords [ 0 ] end_point_3d = original_coords [ - 1 ] zigzag_coords = calculate_zigzag_points ( start_point_3d , end_point_3d , self . style . ribbon_thickness , self . style . wavelength , self . style . amplitude , ) if ( zigzag_coords is None and self . _original_coords_len >= 2 ): # Log only if zigzag expected but failed raise CoordinateCalculationError ( f \"Could not generate zigzag points for helix ' { self . id } ' (length= { self . _original_coords_len } ), likely zero length between endpoints.\" ) self . _cached_display_coords = zigzag_coords return self . _cached_display_coords get_end_connection_point ( structure ) Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/helix.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 1 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the ending edge # Last point of top edge = coords_2d[num_edge_points - 1] # Corresponding last point of bottom edge = coords_2d[num_edge_points] num_edge_points = len ( coords_2d ) // 2 last_top_point = coords_2d [ num_edge_points - 1 ] last_bottom_point = coords_2d [ num_edge_points ] return ( last_top_point + last_bottom_point ) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ - 1 ] # Return the last point get_start_connection_point ( structure ) Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/helix.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 0 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the starting edge # First point (top edge start) = coords_2d[0] # Corresponding bottom point (bottom edge start) = coords_2d[-1] return ( coords_2d [ 0 ] + coords_2d [ - 1 ]) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ 0 ] # Return the first point options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Helix elements. Defines properties for rendering helices as zigzag ribbons. Source code in src/flatprot/scene/structure/helix.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class HelixStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Helix elements. Defines properties for rendering helices as zigzag ribbons. \"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#ff0000\" ), description = \"Default color for helix (red).\" ) stroke_width : float = Field ( default = 1 , description = \"Reference width for calculating helix dimensions.\" ) simplified_width : float = Field ( default = 2 , description = \"Width to use for simplified helix rendering (line only).\" , ) # Helix-specific attributes ribbon_thickness : float = Field ( default = 8 , description = \"Factor to multiply linewidth by for the ribbon thickness.\" , ) wavelength : float = Field ( default = 10.0 , description = \"Factor to multiply linewidth by for the zigzag wavelength.\" , ) amplitude : float = Field ( default = 3.0 , description = \"Factor to multiply linewidth by for the zigzag amplitude.\" , ) min_helix_length : int = Field ( default = 4 , ge = 2 , description = \"Minimum number of residues required to draw a zigzag shape instead of a line.\" , ) options: show_root_heading: true Bases: BaseStructureSceneElement [ SheetStyle ] Represents a Beta Sheet segment, visualized as a triangular arrow. Source code in src/flatprot/scene/structure/sheet.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class SheetSceneElement ( BaseStructureSceneElement [ SheetStyle ]): \"\"\"Represents a Beta Sheet segment, visualized as a triangular arrow.\"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ SheetStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the SheetSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated arrow coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> SheetStyle : \"\"\"Provides the default style for Sheet elements.\"\"\" return SheetStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this sheet.\"\"\" coords_list = [] if not self . residue_range_set . ranges : raise CoordinateCalculationError ( f \"Cannot get coordinates for Sheet ' { self . id } ': no residue ranges defined.\" ) sheet_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ sheet_range . chain_id ] for res_idx in range ( sheet_range . start , sheet_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : raise CoordinateCalculationError ( f \"Sheet ' { self . id } ': Coordinate index { coord_idx } out of bounds for residue { sheet_range . chain_id } : { res_idx } .\" ) else : raise CoordinateCalculationError ( f \"Sheet ' { self . id } ': Residue { sheet_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : raise CoordinateCalculationError ( f \"Error fetching coordinates for sheet ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) containing [X, Y, Depth] for each point. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # If only one point, cannot draw line or arrow if self . _original_coords_len == 1 : self . _cached_display_coords = np . array ( [ original_coords [ 0 ]] ) # Return the single point return self . _cached_display_coords # Use only X, Y for shape calculation, keep Z (depth) start_point_xy = original_coords [ 0 , : 2 ] end_point_xy = original_coords [ - 1 , : 2 ] # Use average depth of start/end for the base, end depth for tip start_depth = original_coords [ 0 , 2 ] end_depth = original_coords [ - 1 , 2 ] avg_base_depth = ( start_depth + end_depth ) / 2.0 direction = end_point_xy - start_point_xy length = np . linalg . norm ( direction ) # If too short or degenerate, return a simple line (start and end points) if length < 1e-6 or self . _original_coords_len < self . style . min_sheet_length : # Return original start and end points (X, Y, Depth) self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Normalize direction vector (only need X, Y) direction /= length # Calculate perpendicular vector in 2D perp = np . array ([ - direction [ 1 ], direction [ 0 ]]) arrow_base_half_width = self . style . arrow_width / 2.0 # Calculate arrow base points (X, Y) left_point_xy = start_point_xy + perp * arrow_base_half_width right_point_xy = start_point_xy - perp * arrow_base_half_width # Combine XY with Depth left_point = np . append ( left_point_xy , avg_base_depth ) right_point = np . append ( right_point_xy , avg_base_depth ) tip_point = np . append ( end_point_xy , end_depth ) # Tip uses depth of last residue self . _cached_display_coords = np . array ([ left_point , right_point , tip_point ]) return self . _cached_display_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] interpolated along the sheet axis. \"\"\" # 1. Ensure display coordinates are calculated and length is known display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single continuous range for sheet element representation element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start # Validate index against the original length before simplification/arrow calc if not ( 0 <= original_sequence_index < self . _original_coords_len ): raise CoordinateCalculationError ( f \"Residue index { original_sequence_index } derived from { residue } is out of original bounds [0, { self . _original_coords_len } ) for element { self . id } .\" ) except Exception as e : raise CoordinateCalculationError ( f \"Error calculating original sequence index for { residue } in element { self . id } : { e } \" ) from e # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Return the single point calculated by get_coordinates # 4. Handle the case where a line was drawn (display_coords has 2 points) if len ( display_coords ) == 2 : # Simple linear interpolation between the start and end points of the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Interpolate along the arrow axis (base midpoint to tip) # display_coords has shape [3, 3]: [left_base, right_base, tip] base_midpoint = ( display_coords [ 0 ] + display_coords [ 1 ]) / 2.0 tip_point = display_coords [ 2 ] # Calculate fraction along the length (0 = base midpoint, 1 = tip) # Based on position within the *original* sequence length frac = original_sequence_index / ( self . _original_coords_len - 1 ) # Linear interpolation between base midpoint and tip point interpolated_coord = base_midpoint * ( 1 - frac ) + tip_point * frac return interpolated_coord def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None if len ( coords_2d ) < 3 : return coords_2d [ 0 , : 2 ] return ( coords_2d [ 0 , : 2 ] + coords_2d [ 1 , : 2 ]) / 2 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ] default_style property Provides the default style for Sheet elements. __init__ ( residue_range_set , style = None , parent = None ) Initializes the SheetSceneElement. Source code in src/flatprot/scene/structure/sheet.py 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ SheetStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the SheetSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated arrow coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None get_coordinate_at_residue ( residue , structure ) Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] interpolated along the sheet axis. Source code in src/flatprot/scene/structure/sheet.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] interpolated along the sheet axis. \"\"\" # 1. Ensure display coordinates are calculated and length is known display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single continuous range for sheet element representation element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start # Validate index against the original length before simplification/arrow calc if not ( 0 <= original_sequence_index < self . _original_coords_len ): raise CoordinateCalculationError ( f \"Residue index { original_sequence_index } derived from { residue } is out of original bounds [0, { self . _original_coords_len } ) for element { self . id } .\" ) except Exception as e : raise CoordinateCalculationError ( f \"Error calculating original sequence index for { residue } in element { self . id } : { e } \" ) from e # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Return the single point calculated by get_coordinates # 4. Handle the case where a line was drawn (display_coords has 2 points) if len ( display_coords ) == 2 : # Simple linear interpolation between the start and end points of the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Interpolate along the arrow axis (base midpoint to tip) # display_coords has shape [3, 3]: [left_base, right_base, tip] base_midpoint = ( display_coords [ 0 ] + display_coords [ 1 ]) / 2.0 tip_point = display_coords [ 2 ] # Calculate fraction along the length (0 = base midpoint, 1 = tip) # Based on position within the *original* sequence length frac = original_sequence_index / ( self . _original_coords_len - 1 ) # Linear interpolation between base midpoint and tip point interpolated_coord = base_midpoint * ( 1 - frac ) + tip_point * frac return interpolated_coord get_coordinates ( structure ) Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) Optional [ ndarray ] \u2013 containing [X, Y, Depth] for each point. Source code in src/flatprot/scene/structure/sheet.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) containing [X, Y, Depth] for each point. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # If only one point, cannot draw line or arrow if self . _original_coords_len == 1 : self . _cached_display_coords = np . array ( [ original_coords [ 0 ]] ) # Return the single point return self . _cached_display_coords # Use only X, Y for shape calculation, keep Z (depth) start_point_xy = original_coords [ 0 , : 2 ] end_point_xy = original_coords [ - 1 , : 2 ] # Use average depth of start/end for the base, end depth for tip start_depth = original_coords [ 0 , 2 ] end_depth = original_coords [ - 1 , 2 ] avg_base_depth = ( start_depth + end_depth ) / 2.0 direction = end_point_xy - start_point_xy length = np . linalg . norm ( direction ) # If too short or degenerate, return a simple line (start and end points) if length < 1e-6 or self . _original_coords_len < self . style . min_sheet_length : # Return original start and end points (X, Y, Depth) self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Normalize direction vector (only need X, Y) direction /= length # Calculate perpendicular vector in 2D perp = np . array ([ - direction [ 1 ], direction [ 0 ]]) arrow_base_half_width = self . style . arrow_width / 2.0 # Calculate arrow base points (X, Y) left_point_xy = start_point_xy + perp * arrow_base_half_width right_point_xy = start_point_xy - perp * arrow_base_half_width # Combine XY with Depth left_point = np . append ( left_point_xy , avg_base_depth ) right_point = np . append ( right_point_xy , avg_base_depth ) tip_point = np . append ( end_point_xy , end_depth ) # Tip uses depth of last residue self . _cached_display_coords = np . array ([ left_point , right_point , tip_point ]) return self . _cached_display_coords get_end_connection_point ( structure ) Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/sheet.py 268 269 270 271 272 273 274 275 276 277 278 279 280 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ] get_start_connection_point ( structure ) Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/sheet.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None if len ( coords_2d ) < 3 : return coords_2d [ 0 , : 2 ] return ( coords_2d [ 0 , : 2 ] + coords_2d [ 1 , : 2 ]) / 2 options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Sheet elements. Defines properties for rendering beta sheets as triangular arrows. Source code in src/flatprot/scene/structure/sheet.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SheetStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Sheet elements. Defines properties for rendering beta sheets as triangular arrows. \"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#0000ff\" ), description = \"Default color for sheet (blue).\" ) stroke_width : float = Field ( default = 1.0 , description = \"Base width of the sheet arrow.\" ) simplified_width : float = Field ( default = 2 , description = \"Width to use for simplified sheet rendering (line only).\" , ) # Sheet-specific attributes arrow_width : float = Field ( default = 8.0 , description = \"Factor to multiply linewidth by for the arrowhead base width.\" , ) min_sheet_length : int = Field ( default = 3 , ge = 1 , description = \"Minimum number of residues required to draw an arrow shape instead of a line.\" , ) options: show_root_heading: true Bases: BaseStructureSceneElement [ CoilStyle ] Represents a Coil segment of a protein structure. Renders as a smoothed line based on the pre-projected coordinates. Source code in src/flatprot/scene/structure/coil.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CoilSceneElement ( BaseStructureSceneElement [ CoilStyle ]): \"\"\"Represents a Coil segment of a protein structure. Renders as a smoothed line based on the pre-projected coordinates. \"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ CoilStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the CoilSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated smoothed coordinates and original indices self . _cached_smoothed_coords : Optional [ np . ndarray ] = None self . _original_indices : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> CoilStyle : \"\"\"Provides the default style for Coil elements.\"\"\" return CoilStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this coil.\"\"\" coords_list = [] if not self . residue_range_set . ranges : raise CoordinateCalculationError ( f \"Cannot get coordinates for Coil ' { self . id } ': no residue ranges defined.\" ) coil_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ coil_range . chain_id ] for res_idx in range ( coil_range . start , coil_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : raise CoordinateCalculationError ( f \"Coil ' { self . id } ': Coordinate index { coord_idx } out of bounds for residue { coil_range . chain_id } : { res_idx } .\" ) else : raise CoordinateCalculationError ( f \"Coil ' { self . id } ': Residue { coil_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : raise CoordinateCalculationError ( f \"Error getting original coordinates for Coil ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). \"\"\" # Return cached result if available if self . _cached_smoothed_coords is not None : return self . _cached_smoothed_coords # 1. Get the original (pre-projected) coordinates slice for this element original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None : self . _cached_smoothed_coords = None self . _original_indices = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # Handle single-point coils separately if self . _original_coords_len == 1 : self . _cached_smoothed_coords = original_coords self . _original_indices = np . array ([ 0 ]) # Index of the single point return self . _cached_smoothed_coords # 2. Apply smoothing based on style (only if >= 2 points) smoothing_factor = self . style . smoothing_factor smoothed_coords , used_indices = smooth_coordinates ( original_coords , smoothing_factor ) # 3. Cache and return self . _cached_smoothed_coords = smoothed_coords # Map the indices from smooth_coordinates (relative to the slice) back to the # original residue indices or coordinate indices if needed elsewhere, but # for get_2d_coordinate_at_residue, we primarily need the mapping *between* # original sequence index and smoothed sequence index. # We store the indices *within the original slice* that were kept. self . _original_indices = used_indices return self . _cached_smoothed_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. \"\"\" # 1. Ensure smoothed coordinates are calculated and cached # This call populates self._cached_smoothed_coords, self._original_coords_len, etc. smoothed_coords = self . get_coordinates ( structure ) if smoothed_coords is None or self . _original_coords_len is None : return None # Cannot determine coordinate if smoothing failed # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single range for simplicity element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Map residue index to the 0-based index within the *original* sequence of this coil # This index represents the position *before* smoothing. try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None # Residue index is outside the valid range for this element except Exception : return None # Should not happen if residue is in range set, but defensive check # 4. Map the original sequence index to the fractional index within the *smoothed* sequence # This tells us where the original residue falls along the smoothed line. orig_len = self . _original_coords_len smooth_len = len ( smoothed_coords ) # Avoid division by zero if original length was 1 (although checked earlier) if orig_len <= 1 : return smoothed_coords [ 0 ] if smooth_len > 0 else None # Calculate fractional position along the smoothed line mapped_idx_frac = ( original_sequence_index * ( smooth_len - 1 )) / ( orig_len - 1 ) # 5. Linear interpolation between adjacent smoothed points idx_low = int ( np . floor ( mapped_idx_frac )) # Clamp idx_high to the last valid index of the smoothed array idx_high = min ( idx_low + 1 , smooth_len - 1 ) # Ensure idx_low is also within bounds (handles edge case where mapped_idx_frac might be exactly smooth_len-1) idx_low = min ( idx_low , smooth_len - 1 ) # Calculate interpolation fraction frac = mapped_idx_frac - idx_low # Interpolate X, Y, and Depth coord_low = smoothed_coords [ idx_low ] coord_high = smoothed_coords [ idx_high ] interpolated_coord = coord_low * ( 1 - frac ) + coord_high * frac return interpolated_coord def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ 0 , : 2 ] def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ] default_style property Provides the default style for Coil elements. __init__ ( residue_range_set , style = None , parent = None ) Initializes the CoilSceneElement. Source code in src/flatprot/scene/structure/coil.py 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ CoilStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the CoilSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated smoothed coordinates and original indices self . _cached_smoothed_coords : Optional [ np . ndarray ] = None self . _original_indices : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None get_coordinate_at_residue ( residue , structure ) Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the 2D point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. Source code in src/flatprot/scene/structure/coil.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. \"\"\" # 1. Ensure smoothed coordinates are calculated and cached # This call populates self._cached_smoothed_coords, self._original_coords_len, etc. smoothed_coords = self . get_coordinates ( structure ) if smoothed_coords is None or self . _original_coords_len is None : return None # Cannot determine coordinate if smoothing failed # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single range for simplicity element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Map residue index to the 0-based index within the *original* sequence of this coil # This index represents the position *before* smoothing. try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None # Residue index is outside the valid range for this element except Exception : return None # Should not happen if residue is in range set, but defensive check # 4. Map the original sequence index to the fractional index within the *smoothed* sequence # This tells us where the original residue falls along the smoothed line. orig_len = self . _original_coords_len smooth_len = len ( smoothed_coords ) # Avoid division by zero if original length was 1 (although checked earlier) if orig_len <= 1 : return smoothed_coords [ 0 ] if smooth_len > 0 else None # Calculate fractional position along the smoothed line mapped_idx_frac = ( original_sequence_index * ( smooth_len - 1 )) / ( orig_len - 1 ) # 5. Linear interpolation between adjacent smoothed points idx_low = int ( np . floor ( mapped_idx_frac )) # Clamp idx_high to the last valid index of the smoothed array idx_high = min ( idx_low + 1 , smooth_len - 1 ) # Ensure idx_low is also within bounds (handles edge case where mapped_idx_frac might be exactly smooth_len-1) idx_low = min ( idx_low , smooth_len - 1 ) # Calculate interpolation fraction frac = mapped_idx_frac - idx_low # Interpolate X, Y, and Depth coord_low = smoothed_coords [ idx_low ] coord_high = smoothed_coords [ idx_high ] interpolated_coord = coord_low * ( 1 - frac ) + coord_high * frac return interpolated_coord get_coordinates ( structure ) Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). Source code in src/flatprot/scene/structure/coil.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). \"\"\" # Return cached result if available if self . _cached_smoothed_coords is not None : return self . _cached_smoothed_coords # 1. Get the original (pre-projected) coordinates slice for this element original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None : self . _cached_smoothed_coords = None self . _original_indices = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # Handle single-point coils separately if self . _original_coords_len == 1 : self . _cached_smoothed_coords = original_coords self . _original_indices = np . array ([ 0 ]) # Index of the single point return self . _cached_smoothed_coords # 2. Apply smoothing based on style (only if >= 2 points) smoothing_factor = self . style . smoothing_factor smoothed_coords , used_indices = smooth_coordinates ( original_coords , smoothing_factor ) # 3. Cache and return self . _cached_smoothed_coords = smoothed_coords # Map the indices from smooth_coordinates (relative to the slice) back to the # original residue indices or coordinate indices if needed elsewhere, but # for get_2d_coordinate_at_residue, we primarily need the mapping *between* # original sequence index and smoothed sequence index. # We store the indices *within the original slice* that were kept. self . _original_indices = used_indices return self . _cached_smoothed_coords get_end_connection_point ( structure ) Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/coil.py 260 261 262 263 264 265 266 267 268 269 270 271 272 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ] get_start_connection_point ( structure ) Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/coil.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ 0 , : 2 ] options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Coil elements. Source code in src/flatprot/scene/structure/coil.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class CoilStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Coil elements.\"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#5b5859\" ), description = \"Default color for coil (light grey).\" , ) stroke_width : float = Field ( default = 1.0 , description = \"Line width for coil.\" ) # Coil-specific attribute smoothing_factor : float = Field ( default = 0.1 , ge = 0.0 , le = 1.0 , description = \"Fraction of points to keep during smoothing (0.0 to 1.0).\" \"Higher value means less smoothing.\" , ) options: show_root_heading: true Annotation Elements Classes representing annotation elements within the scene. Bases: BaseSceneElement [ AnnotationStyleType ] , ABC , Generic [ AnnotationStyleType ] Abstract base class for scene elements representing annotations. Stores the original target specification (coordinates, range, or range set) and requires the corresponding ResidueRangeSet for the base scene element. Requires a concrete style type inheriting from BaseAnnotationStyle. Source code in src/flatprot/scene/annotation/base_annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 class BaseAnnotationElement ( BaseSceneElement [ AnnotationStyleType ], ABC , Generic [ AnnotationStyleType ] ): \"\"\"Abstract base class for scene elements representing annotations. Stores the original target specification (coordinates, range, or range set) and requires the corresponding ResidueRangeSet for the base scene element. Requires a concrete style type inheriting from BaseAnnotationStyle. \"\"\" def __init__ ( self , id : str , # ID is required for annotations target : Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ], label : Optional [ str ] = None , style : Optional [ AnnotationStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate `residue_range_set` based on their specific `target` type before calling this initializer. Args: id: A unique identifier for this annotation element. target: The original target specification (list of coordinates, range, or set). Stored for use by subclasses in `get_coordinates`. residue_range_set: The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label: The label for the annotation. style: An optional specific style instance for this annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: TypeError: If the target type is not one of the allowed types. ValueError: If residue_range_set is empty. \"\"\" # Validate the target type if not isinstance ( target , ( ResidueCoordinate , list , ResidueRange , ResidueRangeSet ) ) or ( isinstance ( target , list ) and not all ( isinstance ( item , ResidueCoordinate ) for item in target ) ): raise ValueError ( f \"Unsupported target type for annotation: { type ( target ) } . \" f \"Expected List[ResidueCoordinate], ResidueRange, or ResidueRangeSet.\" ) self . label = label self . _target = target # Store the original target # Pass the explicitly provided residue_range_set to the BaseSceneElement constructor super () . __init__ ( id = id , style = style , parent = parent , ) @property def target ( self ) -> Union [ List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ]: \"\"\"Get the target specification provided during initialization.\"\"\" return self . _target @property def targets_specific_coordinates ( self ) -> bool : \"\"\"Check if this annotation targets a list of specific coordinates.\"\"\" return isinstance ( self . _target , list ) @abstractmethod def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. # Other specific exceptions possible depending on implementation \"\"\" raise NotImplementedError # Concrete subclasses (Marker, Line, Area) MUST implement default_style @property @abstractmethod def default_style ( self ) -> AnnotationStyleType : \"\"\"Provides the default style instance for this specific annotation type. Concrete subclasses must implement this property. Returns: An instance of the specific AnnotationStyleType for this element. \"\"\" raise NotImplementedError def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Args: structure: The core Structure object (unused). Returns: A very large float value (infinity). \"\"\" # Return positive infinity to ensure annotations are sorted last (drawn on top) # when using ascending sort order for depth. Adjust if sort order is descending. return float ( \"inf\" ) default_style abstractmethod property Provides the default style instance for this specific annotation type. Concrete subclasses must implement this property. Returns: AnnotationStyleType \u2013 An instance of the specific AnnotationStyleType for this element. target property Get the target specification provided during initialization. targets_specific_coordinates property Check if this annotation targets a list of specific coordinates. __init__ ( id , target , label = None , style = None , parent = None ) Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate residue_range_set based on their specific target type before calling this initializer. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target ( Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ] ) \u2013 The original target specification (list of coordinates, range, or set). Stored for use by subclasses in get_coordinates . residue_range_set \u2013 The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label ( Optional [ str ] , default: None ) \u2013 The label for the annotation. style ( Optional [ AnnotationStyleType ] , default: None ) \u2013 An optional specific style instance for this annotation. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: TypeError \u2013 If the target type is not one of the allowed types. ValueError \u2013 If residue_range_set is empty. Source code in src/flatprot/scene/annotation/base_annotation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , id : str , # ID is required for annotations target : Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ], label : Optional [ str ] = None , style : Optional [ AnnotationStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate `residue_range_set` based on their specific `target` type before calling this initializer. Args: id: A unique identifier for this annotation element. target: The original target specification (list of coordinates, range, or set). Stored for use by subclasses in `get_coordinates`. residue_range_set: The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label: The label for the annotation. style: An optional specific style instance for this annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: TypeError: If the target type is not one of the allowed types. ValueError: If residue_range_set is empty. \"\"\" # Validate the target type if not isinstance ( target , ( ResidueCoordinate , list , ResidueRange , ResidueRangeSet ) ) or ( isinstance ( target , list ) and not all ( isinstance ( item , ResidueCoordinate ) for item in target ) ): raise ValueError ( f \"Unsupported target type for annotation: { type ( target ) } . \" f \"Expected List[ResidueCoordinate], ResidueRange, or ResidueRangeSet.\" ) self . label = label self . _target = target # Store the original target # Pass the explicitly provided residue_range_set to the BaseSceneElement constructor super () . __init__ ( id = id , style = style , parent = parent , ) get_coordinates ( resolver ) abstractmethod Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError \u2013 If coordinates cannot be resolved. TargetResidueNotFoundError \u2013 If a target residue is not found. Source code in src/flatprot/scene/annotation/base_annotation.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @abstractmethod def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. # Other specific exceptions possible depending on implementation \"\"\" raise NotImplementedError get_depth ( structure ) Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Parameters: structure ( Structure ) \u2013 The core Structure object (unused). Returns: Optional [ float ] \u2013 A very large float value (infinity). Source code in src/flatprot/scene/annotation/base_annotation.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Args: structure: The core Structure object (unused). Returns: A very large float value (infinity). \"\"\" # Return positive infinity to ensure annotations are sorted last (drawn on top) # when using ascending sort order for depth. Adjust if sort order is descending. return float ( \"inf\" ) options: show_root_heading: true Bases: BaseSceneStyle Base style for annotation elements. Source code in src/flatprot/scene/annotation/base_annotation.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class BaseAnnotationStyle ( BaseSceneStyle ): \"\"\"Base style for annotation elements.\"\"\" color : Color = Field ( default = Color (( 1.0 , 0.0 , 0.0 )), description = \"Default color for the annotation (hex string). Red.\" , ) offset : Tuple [ float , float ] = Field ( default = ( 0.0 , 0.0 ), description = \"2D offset (x, y) from the anchor point in canvas units.\" , ) label_offset : Tuple [ float , float ] = Field ( default = ( 0.0 , 0.0 ), description = \"2D offset (x, y) from the label anchor point in canvas units.\" , ) label_color : Color = Field ( default = Color (( 0.0 , 0.0 , 0.0 )), description = \"Default color for the label (hex string). Black.\" , ) label_font_size : float = Field ( default = 12.0 , description = \"Font size for the label.\" , ) label_font_weight : str = Field ( default = \"normal\" , description = \"Font weight for the label.\" , ) label_font_family : str = Field ( default = \"Arial\" , description = \"Font family for the label.\" , ) label : Optional [ str ] = Field ( default = None , description = \"Optional text label for the annotation.\" ) options: show_root_heading: true Bases: BaseAnnotationElement [ PointAnnotationStyle ] Represents an annotation marking a single residue coordinate. Source code in src/flatprot/scene/annotation/point.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PointAnnotation ( BaseAnnotationElement [ PointAnnotationStyle ]): \"\"\"Represents an annotation marking a single residue coordinate.\"\"\" def __init__ ( self , id : str , target : ResidueCoordinate , # Expects a single coordinate label : Optional [ str ] = None , style : Optional [ PointAnnotationStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a PointAnnotation. Args: id: A unique identifier for this annotation element. target_coordinate: The specific residue coordinate this annotation targets. style: An optional specific style instance for this annotation. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( target , ResidueCoordinate ): raise TypeError ( \"target_coordinate must be a single ResidueCoordinate instance.\" ) # Call superclass init, passing the single coordinate in a list super () . __init__ ( id = id , target = target , # Base class expects a list style = style , label = label , parent = parent , ) @property def target_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the specific target coordinate for this point annotation.\"\"\" # target_coordinates is guaranteed to be a list with one element by __init__ return self . target @property def default_style ( self ) -> PointAnnotationStyle : \"\"\"Provides the default style for PointAnnotation elements.\"\"\" return PointAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates of the target point. Raises: CoordinateCalculationError: If the coordinate cannot be resolved. TargetResidueNotFoundError: If the target residue is not found. \"\"\" target_res = self . target_coordinate # Delegate resolution to the resolver point = resolver . resolve ( target_res ) # Resolver handles errors, so point should be valid if no exception was raised return np . array ([ point ]) default_style property Provides the default style for PointAnnotation elements. target_coordinate property Get the specific target coordinate for this point annotation. __init__ ( id , target , label = None , style = None , parent = None ) Initializes a PointAnnotation. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target_coordinate \u2013 The specific residue coordinate this annotation targets. style ( Optional [ PointAnnotationStyle ] , default: None ) \u2013 An optional specific style instance for this annotation. metadata \u2013 Optional dictionary for storing arbitrary metadata. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/annotation/point.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , id : str , target : ResidueCoordinate , # Expects a single coordinate label : Optional [ str ] = None , style : Optional [ PointAnnotationStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a PointAnnotation. Args: id: A unique identifier for this annotation element. target_coordinate: The specific residue coordinate this annotation targets. style: An optional specific style instance for this annotation. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( target , ResidueCoordinate ): raise TypeError ( \"target_coordinate must be a single ResidueCoordinate instance.\" ) # Call superclass init, passing the single coordinate in a list super () . __init__ ( id = id , target = target , # Base class expects a list style = style , label = label , parent = parent , ) get_coordinates ( resolver ) Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates ndarray \u2013 of the target point. Raises: CoordinateCalculationError \u2013 If the coordinate cannot be resolved. TargetResidueNotFoundError \u2013 If the target residue is not found. Source code in src/flatprot/scene/annotation/point.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates of the target point. Raises: CoordinateCalculationError: If the coordinate cannot be resolved. TargetResidueNotFoundError: If the target residue is not found. \"\"\" target_res = self . target_coordinate # Delegate resolution to the resolver point = resolver . resolve ( target_res ) # Resolver handles errors, so point should be valid if no exception was raised return np . array ([ point ]) options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to PointAnnotation elements. Source code in src/flatprot/scene/annotation/point.py 25 26 27 28 29 30 31 32 class PointAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to PointAnnotation elements.\"\"\" marker_radius : float = Field ( default = 5.0 , ge = 0 , description = \"Radius of the point marker.\" , ) options: show_root_heading: true Bases: BaseAnnotationElement [ LineAnnotationStyle ] Represents an annotation connecting two specific residue coordinates with a line. Source code in src/flatprot/scene/annotation/line.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class LineAnnotation ( BaseAnnotationElement [ LineAnnotationStyle ]): \"\"\"Represents an annotation connecting two specific residue coordinates with a line.\"\"\" def __init__ ( self , id : str , start_coordinate : ResidueCoordinate , end_coordinate : ResidueCoordinate , style : Optional [ LineAnnotationStyle ] = None , label : Optional [ str ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a LineAnnotation. Args: id: A unique identifier for this annotation element. target_coordinates: A list containing exactly two ResidueCoordinates defining the start and end points of the line. style: The specific style instance for this line annotation. label: The label for the annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If `target_coordinates` does not contain exactly two elements. TypeError: If elements in `target_coordinates` are not ResidueCoordinate instances. \"\"\" if not isinstance ( start_coordinate , ResidueCoordinate ) or not isinstance ( end_coordinate , ResidueCoordinate ): raise ValueError ( \"LineAnnotation must be initialized with two ResidueCoordinate instances.\" ) # Call superclass init super () . __init__ ( id = id , target = [ start_coordinate , end_coordinate ], style = style , label = label , parent = parent , ) @property def start_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the start target coordinate for the line.\"\"\" return self . target [ 0 ] @property def end_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the end target coordinate for the line.\"\"\" return self . target [ 1 ] @property def default_style ( self ) -> LineAnnotationStyle : \"\"\"Provides the default style for LineAnnotation elements.\"\"\" return LineAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates of the start and end points. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. \"\"\" start_res = self . start_coordinate end_res = self . end_coordinate start_point = resolver . resolve ( start_res ) end_point = resolver . resolve ( end_res ) # Return as a [2, 3] array return np . array ([ start_point , end_point ]) default_style property Provides the default style for LineAnnotation elements. end_coordinate property Get the end target coordinate for the line. start_coordinate property Get the start target coordinate for the line. __init__ ( id , start_coordinate , end_coordinate , style = None , label = None , parent = None ) Initializes a LineAnnotation. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target_coordinates \u2013 A list containing exactly two ResidueCoordinates defining the start and end points of the line. style ( Optional [ LineAnnotationStyle ] , default: None ) \u2013 The specific style instance for this line annotation. label ( Optional [ str ] , default: None ) \u2013 The label for the annotation. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: ValueError \u2013 If target_coordinates does not contain exactly two elements. TypeError \u2013 If elements in target_coordinates are not ResidueCoordinate instances. Source code in src/flatprot/scene/annotation/line.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , id : str , start_coordinate : ResidueCoordinate , end_coordinate : ResidueCoordinate , style : Optional [ LineAnnotationStyle ] = None , label : Optional [ str ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a LineAnnotation. Args: id: A unique identifier for this annotation element. target_coordinates: A list containing exactly two ResidueCoordinates defining the start and end points of the line. style: The specific style instance for this line annotation. label: The label for the annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If `target_coordinates` does not contain exactly two elements. TypeError: If elements in `target_coordinates` are not ResidueCoordinate instances. \"\"\" if not isinstance ( start_coordinate , ResidueCoordinate ) or not isinstance ( end_coordinate , ResidueCoordinate ): raise ValueError ( \"LineAnnotation must be initialized with two ResidueCoordinate instances.\" ) # Call superclass init super () . __init__ ( id = id , target = [ start_coordinate , end_coordinate ], style = style , label = label , parent = parent , ) get_coordinates ( resolver ) Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates ndarray \u2013 of the start and end points. Raises: CoordinateCalculationError \u2013 If coordinates cannot be resolved. TargetResidueNotFoundError \u2013 If a target residue is not found. Source code in src/flatprot/scene/annotation/line.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates of the start and end points. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. \"\"\" start_res = self . start_coordinate end_res = self . end_coordinate start_point = resolver . resolve ( start_res ) end_point = resolver . resolve ( end_res ) # Return as a [2, 3] array return np . array ([ start_point , end_point ]) options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to LineAnnotation elements. Source code in src/flatprot/scene/annotation/line.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class LineAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to LineAnnotation elements.\"\"\" stroke_width : float = Field ( default = 1.0 , ge = 0 , description = \"Width of the annotation line.\" ) line_style : Tuple [ float , ... ] = Field ( default = ( 5 , 5 ), description = \"Dash pattern for the line (e.g., (5, 5) for dashed). Empty tuple means solid.\" , ) connector_color : Color = Field ( default = Color ( \"#000000\" ), description = \"Color of the connector circles at the start and end of the line.\" , ) line_color : Color = Field ( default = Color ( \"#000000\" ), description = \"Color of the line.\" , ) arrowhead_start : bool = Field ( default = False , description = \"Whether to draw an arrowhead at the start of the line.\" , ) arrowhead_end : bool = Field ( default = False , description = \"Whether to draw an arrowhead at the end of the line.\" , ) connector_radius : float = Field ( default = 2.0 , ge = 0 , description = \"Radius of the connector circles at the start and end of the line.\" , ) options: show_root_heading: true Bases: BaseAnnotationElement [ AreaAnnotationStyle ] Represents an annotation highlighting an area encompassing specific residues or ranges. Source code in src/flatprot/scene/annotation/area.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class AreaAnnotation ( BaseAnnotationElement [ AreaAnnotationStyle ]): \"\"\"Represents an annotation highlighting an area encompassing specific residues or ranges.\"\"\" def __init__ ( self , id : str , style : Optional [ AreaAnnotationStyle ] = None , label : Optional [ str ] = None , residue_range_set : Optional [ ResidueRangeSet ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes an AreaAnnotation. Exactly one of `residue_range_set` or `target_coordinates` must be provided to define the residues encompassed by the area. Args: id: A unique identifier for this annotation element. style: The specific style instance for this area annotation. label: Optional text label for the annotation. residue_range_set: The set of residue ranges this annotation targets. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If neither or both targeting arguments are provided. \"\"\" # Metadata argument removed, using label directly super () . __init__ ( id = id , target = residue_range_set , style = style , label = label , parent = parent , ) self . _cached_outline_coords : Optional [ np . ndarray ] = None @property def default_style ( self ) -> AreaAnnotationStyle : \"\"\"Provides the default style for AreaAnnotation elements.\"\"\" return AreaAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError: If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. \"\"\" logger . debug ( f \"Calculating area coordinates for ' { self . id } ' using resolver\" ) if self . target is None : raise ValueError ( f \"AreaAnnotation ' { self . id } ' has no target defined.\" ) # 1. Collect all available target 3D coordinates using the resolver target_coords_3d_list : List [ np . ndarray ] = [] for res_coord in self . target : try : point = resolver . resolve ( res_coord ) target_coords_3d_list . append ( point ) except ( CoordinateCalculationError , TargetResidueNotFoundError ) as e : logger . warning ( f \"Could not resolve coordinate for { res_coord } in AreaAnnotation ' { self . id } ': { e } . Skipping point.\" ) # Let unexpected errors propagate if len ( target_coords_3d_list ) < 3 : raise CoordinateCalculationError ( f \"Need at least 3 resolvable points to calculate area for annotation ' { self . id } ', found { len ( target_coords_3d_list ) } within its range set.\" ) # Convert list to numpy array for calculations target_coords_3d = np . array ( target_coords_3d_list ) target_coords_2d = target_coords_3d [:, : 2 ] # Use only XY for shape calculation avg_depth = float ( np . mean ( target_coords_3d [:, 2 ])) # Calculate average depth # 2. Compute the convex hull using Andrew's monotone chain algorithm hull_points_2d = _convex_hull ( target_coords_2d ) # 3. Apply padding by offsetting the vertices of the convex hull padding = self . style . padding if padding > 0 and len ( hull_points_2d ) > 0 : # Add check for non-empty hull padded_points_2d = _apply_padding ( hull_points_2d , padding ) else : padded_points_2d = hull_points_2d # 4. Combine XY with the calculated average depth if len ( padded_points_2d ) == 0 : # This could happen if input points were collinear/identical and hull failed raise CoordinateCalculationError ( f \"Could not compute valid outline for AreaAnnotation ' { self . id } ' after padding. This is a calculation issue, please check the residue range set.\" ) num_outline_points = len ( padded_points_2d ) depth_column = np . full (( num_outline_points , 1 ), avg_depth ) outline_coords_3d = np . hstack (( padded_points_2d , depth_column )) # self._cached_outline_coords = outline_coords_3d # Removed caching logger . debug ( f \"Successfully calculated area coordinates for ' { self . id } '\" ) return outline_coords_3d default_style property Provides the default style for AreaAnnotation elements. __init__ ( id , style = None , label = None , residue_range_set = None , parent = None ) Initializes an AreaAnnotation. Exactly one of residue_range_set or target_coordinates must be provided to define the residues encompassed by the area. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. style ( Optional [ AreaAnnotationStyle ] , default: None ) \u2013 The specific style instance for this area annotation. label ( Optional [ str ] , default: None ) \u2013 Optional text label for the annotation. residue_range_set ( Optional [ ResidueRangeSet ] , default: None ) \u2013 The set of residue ranges this annotation targets. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: ValueError \u2013 If neither or both targeting arguments are provided. Source code in src/flatprot/scene/annotation/area.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def __init__ ( self , id : str , style : Optional [ AreaAnnotationStyle ] = None , label : Optional [ str ] = None , residue_range_set : Optional [ ResidueRangeSet ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes an AreaAnnotation. Exactly one of `residue_range_set` or `target_coordinates` must be provided to define the residues encompassed by the area. Args: id: A unique identifier for this annotation element. style: The specific style instance for this area annotation. label: Optional text label for the annotation. residue_range_set: The set of residue ranges this annotation targets. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If neither or both targeting arguments are provided. \"\"\" # Metadata argument removed, using label directly super () . __init__ ( id = id , target = residue_range_set , style = style , label = label , parent = parent , ) self . _cached_outline_coords : Optional [ np . ndarray ] = None get_coordinates ( resolver ) Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing ndarray \u2013 the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError \u2013 If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. Source code in src/flatprot/scene/annotation/area.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError: If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. \"\"\" logger . debug ( f \"Calculating area coordinates for ' { self . id } ' using resolver\" ) if self . target is None : raise ValueError ( f \"AreaAnnotation ' { self . id } ' has no target defined.\" ) # 1. Collect all available target 3D coordinates using the resolver target_coords_3d_list : List [ np . ndarray ] = [] for res_coord in self . target : try : point = resolver . resolve ( res_coord ) target_coords_3d_list . append ( point ) except ( CoordinateCalculationError , TargetResidueNotFoundError ) as e : logger . warning ( f \"Could not resolve coordinate for { res_coord } in AreaAnnotation ' { self . id } ': { e } . Skipping point.\" ) # Let unexpected errors propagate if len ( target_coords_3d_list ) < 3 : raise CoordinateCalculationError ( f \"Need at least 3 resolvable points to calculate area for annotation ' { self . id } ', found { len ( target_coords_3d_list ) } within its range set.\" ) # Convert list to numpy array for calculations target_coords_3d = np . array ( target_coords_3d_list ) target_coords_2d = target_coords_3d [:, : 2 ] # Use only XY for shape calculation avg_depth = float ( np . mean ( target_coords_3d [:, 2 ])) # Calculate average depth # 2. Compute the convex hull using Andrew's monotone chain algorithm hull_points_2d = _convex_hull ( target_coords_2d ) # 3. Apply padding by offsetting the vertices of the convex hull padding = self . style . padding if padding > 0 and len ( hull_points_2d ) > 0 : # Add check for non-empty hull padded_points_2d = _apply_padding ( hull_points_2d , padding ) else : padded_points_2d = hull_points_2d # 4. Combine XY with the calculated average depth if len ( padded_points_2d ) == 0 : # This could happen if input points were collinear/identical and hull failed raise CoordinateCalculationError ( f \"Could not compute valid outline for AreaAnnotation ' { self . id } ' after padding. This is a calculation issue, please check the residue range set.\" ) num_outline_points = len ( padded_points_2d ) depth_column = np . full (( num_outline_points , 1 ), avg_depth ) outline_coords_3d = np . hstack (( padded_points_2d , depth_column )) # self._cached_outline_coords = outline_coords_3d # Removed caching logger . debug ( f \"Successfully calculated area coordinates for ' { self . id } '\" ) return outline_coords_3d options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to AreaAnnotation elements. Source code in src/flatprot/scene/annotation/area.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class AreaAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to AreaAnnotation elements.\"\"\" fill_color : Optional [ Color ] = Field ( default = Color (( 0 , 0 , 0 , 0 )), description = \"Optional fill color (hex string). If None, uses 'color' with reduced opacity.\" , ) fill_opacity : float = Field ( default = 0.3 , ge = 0.0 , le = 1.0 , description = \"Opacity for the fill color.\" ) stroke_width : float = Field ( default = 1.0 , ge = 0 , description = \"Width of the area outline stroke.\" ) line_style : Tuple [ float , ... ] = Field ( default = (), description = \"Dash pattern for the outline (e.g., (5, 5) for dashed). Empty tuple means solid.\" , ) padding : float = Field ( default = 20.0 , ge = 0 , description = \"Padding pixels added outside the convex hull.\" , ) interpolation_points : int = Field ( default = 3 , ge = 3 , description = \"Number of points to generate along the hull outline before smoothing.\" , ) smoothing_window : int = Field ( default = 1 , ge = 1 , description = \"Window size for rolling average smoothing (odd number recommended).\" , ) options: show_root_heading: true Coordinate Resolver Handles the mapping between residue identifiers and scene coordinates. Resolves ResidueCoordinates to their final rendered coordinates. This class iterates through relevant scene elements to find the one covering the target residue and asks that element for the coordinate in its specific rendered space. Source code in src/flatprot/scene/resolver.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class CoordinateResolver : \"\"\" Resolves ResidueCoordinates to their final rendered coordinates. This class iterates through relevant scene elements to find the one covering the target residue and asks that element for the coordinate in its specific rendered space. \"\"\" def __init__ ( self , structure : Structure , element_registry : Dict [ str , BaseSceneElement ] ): \"\"\" Initializes the CoordinateResolver. Args: structure: The core Structure object. element_registry: The Scene's dictionary mapping element IDs to elements. \"\"\" self . _structure = structure # Filter the registry to only contain structure elements for efficiency self . _structure_elements = [ element for element in element_registry . values () if isinstance ( element , BaseStructureSceneElement ) ] def resolve ( self , target_residue : ResidueCoordinate ) -> np . ndarray : \"\"\" Finds the covering structure element and gets the rendered coordinate. Args: target_residue: The ResidueCoordinate to resolve. Returns: A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError: If the residue is not found within any covering structure element's range. CoordinateCalculationError: If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. \"\"\" covering_element : Optional [ BaseStructureSceneElement ] = None for element in self . _structure_elements : # Check if the element's range set exists and contains the target if ( element . residue_range_set and target_residue in element . residue_range_set ): covering_element = element break # Use the first one found if covering_element is None : logger . warning ( f \"No structure element found covering target residue { target_residue } .\" ) # Raise specific error indicating no element coverage raise CoordinateCalculationError ( f \"Target residue { target_residue } is not covered by any structure element in the scene.\" ) # Ask the covering element for the coordinate try : resolved_coord = covering_element . get_coordinate_at_residue ( target_residue , self . _structure ) if resolved_coord is None : # Element covered the range but couldn't resolve the specific point logger . warning ( f \"Element ' { covering_element . id } ' could not provide coordinate for { target_residue } .\" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' failed to resolve coordinate for { target_residue } .\" ) # Validate shape if not isinstance ( resolved_coord , np . ndarray ) or resolved_coord . shape != ( 3 , ): logger . error ( f \"Element ' { covering_element . id } ' returned invalid coordinate shape for { target_residue } : { type ( resolved_coord ) } shape { getattr ( resolved_coord , 'shape' , 'N/A' ) } \" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' returned invalid coordinate data for { target_residue } .\" ) return resolved_coord except TargetResidueNotFoundError as e : # This can happen if the element's internal lookup fails logger . warning ( f \"Element ' { covering_element . id } ' could not find { target_residue } internally: { e } \" ) raise # Re-raise the specific error except CoordinateCalculationError as e : logger . error ( f \"Coordinate calculation error within element ' { covering_element . id } ' for { target_residue } : { e } \" , exc_info = True , ) raise # Re-raise calculation errors from the element except Exception as e : # Catch unexpected errors from the element's method logger . error ( f \"Unexpected error in get_coordinate_at_residue for element ' { covering_element . id } ' and { target_residue } : { e } \" , exc_info = True , ) raise CoordinateCalculationError ( f \"Unexpected error resolving coordinate for { target_residue } via element ' { covering_element . id } '.\" ) from e __init__ ( structure , element_registry ) Initializes the CoordinateResolver. Parameters: structure ( Structure ) \u2013 The core Structure object. element_registry ( Dict [ str , BaseSceneElement ] ) \u2013 The Scene's dictionary mapping element IDs to elements. Source code in src/flatprot/scene/resolver.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , structure : Structure , element_registry : Dict [ str , BaseSceneElement ] ): \"\"\" Initializes the CoordinateResolver. Args: structure: The core Structure object. element_registry: The Scene's dictionary mapping element IDs to elements. \"\"\" self . _structure = structure # Filter the registry to only contain structure elements for efficiency self . _structure_elements = [ element for element in element_registry . values () if isinstance ( element , BaseStructureSceneElement ) ] resolve ( target_residue ) Finds the covering structure element and gets the rendered coordinate. Parameters: target_residue ( ResidueCoordinate ) \u2013 The ResidueCoordinate to resolve. Returns: ndarray \u2013 A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError \u2013 If the residue is not found within any covering structure element's range. CoordinateCalculationError \u2013 If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. Source code in src/flatprot/scene/resolver.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def resolve ( self , target_residue : ResidueCoordinate ) -> np . ndarray : \"\"\" Finds the covering structure element and gets the rendered coordinate. Args: target_residue: The ResidueCoordinate to resolve. Returns: A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError: If the residue is not found within any covering structure element's range. CoordinateCalculationError: If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. \"\"\" covering_element : Optional [ BaseStructureSceneElement ] = None for element in self . _structure_elements : # Check if the element's range set exists and contains the target if ( element . residue_range_set and target_residue in element . residue_range_set ): covering_element = element break # Use the first one found if covering_element is None : logger . warning ( f \"No structure element found covering target residue { target_residue } .\" ) # Raise specific error indicating no element coverage raise CoordinateCalculationError ( f \"Target residue { target_residue } is not covered by any structure element in the scene.\" ) # Ask the covering element for the coordinate try : resolved_coord = covering_element . get_coordinate_at_residue ( target_residue , self . _structure ) if resolved_coord is None : # Element covered the range but couldn't resolve the specific point logger . warning ( f \"Element ' { covering_element . id } ' could not provide coordinate for { target_residue } .\" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' failed to resolve coordinate for { target_residue } .\" ) # Validate shape if not isinstance ( resolved_coord , np . ndarray ) or resolved_coord . shape != ( 3 , ): logger . error ( f \"Element ' { covering_element . id } ' returned invalid coordinate shape for { target_residue } : { type ( resolved_coord ) } shape { getattr ( resolved_coord , 'shape' , 'N/A' ) } \" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' returned invalid coordinate data for { target_residue } .\" ) return resolved_coord except TargetResidueNotFoundError as e : # This can happen if the element's internal lookup fails logger . warning ( f \"Element ' { covering_element . id } ' could not find { target_residue } internally: { e } \" ) raise # Re-raise the specific error except CoordinateCalculationError as e : logger . error ( f \"Coordinate calculation error within element ' { covering_element . id } ' for { target_residue } : { e } \" , exc_info = True , ) raise # Re-raise calculation errors from the element except Exception as e : # Catch unexpected errors from the element's method logger . error ( f \"Unexpected error in get_coordinate_at_residue for element ' { covering_element . id } ' and { target_residue } : { e } \" , exc_info = True , ) raise CoordinateCalculationError ( f \"Unexpected error resolving coordinate for { target_residue } via element ' { covering_element . id } '.\" ) from e options: show_root_heading: true members_order: source Scene Utilities Helper functions for creating and modifying scenes. Creates a Scene object populated with elements derived from a Structure. Iterates through chains and secondary structure elements within the provided Structure object, creating corresponding SceneGroup and structure-specific SceneElements (Helix, Sheet, Coil). Elements within each chain group are sorted by their mean depth based on the pre-calculated coordinates in the Structure object. Parameters: structure ( Structure ) \u2013 The core Structure object containing chain, secondary structure, and pre-projected coordinate data (X, Y, Depth). default_styles ( Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle ]]] , default: None ) \u2013 An optional dictionary mapping lowercase element type names ('helix', 'sheet', 'coil', 'connection') to specific style instances to be used as defaults. If not provided or a type is missing, the element's own default style will be used. Returns: Scene \u2013 A Scene object representing the structure. Raises: SceneCreationError \u2013 If Structure has no coordinates or other critical errors occur. CoordinateCalculationError \u2013 If depth calculation fails for an element. Source code in src/flatprot/utils/scene_utils.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def create_scene_from_structure ( structure : Structure , default_styles : Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle ]] ] = None , ) -> Scene : \"\"\"Creates a Scene object populated with elements derived from a Structure. Iterates through chains and secondary structure elements within the provided Structure object, creating corresponding SceneGroup and structure-specific SceneElements (Helix, Sheet, Coil). Elements within each chain group are sorted by their mean depth based on the pre-calculated coordinates in the Structure object. Args: structure: The core Structure object containing chain, secondary structure, and pre-projected coordinate data (X, Y, Depth). default_styles: An optional dictionary mapping lowercase element type names ('helix', 'sheet', 'coil', 'connection') to specific style instances to be used as defaults. If not provided or a type is missing, the element's own default style will be used. Returns: A Scene object representing the structure. Raises: SceneCreationError: If Structure has no coordinates or other critical errors occur. CoordinateCalculationError: If depth calculation fails for an element. \"\"\" if structure . coordinates is None or len ( structure . coordinates ) == 0 : raise SceneCreationError ( f \"Structure ' { structure . id } ' has no coordinates.\" ) scene = Scene ( structure = structure ) styles = default_styles or {} for chain_id , chain in structure : chain_group = SceneGroup ( id = f \" { structure . id } _ { chain_id } \" ) scene . add_element ( chain_group ) logger . debug ( f \" \\t >Adding chain group { chain_group . id } to scene\" ) elements_with_depth = [] chain_elements_in_order : List [ BaseStructureSceneElement ] = [] for ss_element in chain . secondary_structure : ss_type = ss_element . secondary_structure_type element_info = STRUCTURE_ELEMENT_MAP . get ( ss_type ) if not element_info : logger . warning ( f \"Unsupported secondary structure type: { ss_type . value } \" ) continue ElementClass , DefaultStyleClass = element_info # Ensure ss_element start/end are valid ints start_idx = int ( ss_element . start ) end_idx = int ( ss_element . end ) ss_range_set = ResidueRangeSet ( [ ResidueRange ( chain_id = chain_id , start = start_idx , end = end_idx )] ) # Determine the style: Use provided default or element's default element_type_key = ss_type . name . lower () style_instance = styles . get ( element_type_key , None ) try : viz_element = ElementClass ( residue_range_set = ss_range_set , style = style_instance , # Pass the specific instance or None ) # Calculate depth based on *pre-projected* coords in structure depth = viz_element . get_depth ( structure ) if depth is None : # Raise or warn if depth calculation fails raise CoordinateCalculationError ( f \"Could not calculate depth for element { viz_element . id } \" ) elements_with_depth . append (( viz_element , depth )) chain_elements_in_order . append ( viz_element ) # <-- Add element to ordered list except CoordinateCalculationError as e : # Log or handle coordinate/depth errors # For now, re-raise to indicate a problem raise SceneCreationError ( f \"Error processing element { ss_type . value } { ss_range_set } in chain { chain_id } : { e } \" ) from e except Exception as e : # Catch unexpected errors during element creation raise SceneCreationError ( f \"Unexpected error creating element { ss_type . value } { ss_range_set } in chain { chain_id } : { e } \" ) from e # Sort elements by depth (farthest first) elements_with_depth . sort ( key = lambda x : x [ 1 ], reverse = True ) # Add Connections between adjacent elements in the original structural order for i in range ( len ( chain_elements_in_order ) - 1 ): element_i = chain_elements_in_order [ i ] element_i_plus_1 = chain_elements_in_order [ i + 1 ] if element_i . is_adjacent_to ( element_i_plus_1 ): # Get the default connection style if provided conn_style = styles . get ( \"connection\" , None ) # Ensure it's a ConnectionStyle or None before passing if conn_style is not None and not isinstance ( conn_style , ConnectionStyle ): logger . warning ( f \"Invalid type provided for 'connection' style. Expected ConnectionStyle, got { type ( conn_style ) } . Using default.\" ) conn_style = None conn = Connection ( start_element = element_i , end_element = element_i_plus_1 , style = conn_style , # Pass the default style ) logger . debug ( f \" \\t >Adding connection { conn . id } to chain group { chain_group . id } \" ) scene . add_element ( conn , parent_id = chain_group . id ) # Add sorted elements to the chain group for element , _ in elements_with_depth : logger . debug ( f \" \\t >Adding element { element . id } to chain group { chain_group . id } \" ) scene . add_element ( element , parent_id = chain_group . id ) return scene options: show_root_heading: true Parses annotations from a file and adds them to the scene. Parameters: annotations_path ( Path ) \u2013 Path to the TOML annotations file. scene ( Scene ) \u2013 The Scene object to add annotations to. Raises: AnnotationFileNotFoundError \u2013 If the annotation file is not found. MalformedAnnotationError \u2013 If the annotation file has invalid content or format. AnnotationError \u2013 For other annotation parsing related errors. SceneCreationError \u2013 If adding an element to the scene fails (e.g., duplicate ID). Source code in src/flatprot/utils/scene_utils.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def add_annotations_to_scene ( annotations_path : Path , scene : Scene ) -> None : \"\"\"Parses annotations from a file and adds them to the scene. Args: annotations_path: Path to the TOML annotations file. scene: The Scene object to add annotations to. Raises: AnnotationFileNotFoundError: If the annotation file is not found. MalformedAnnotationError: If the annotation file has invalid content or format. AnnotationError: For other annotation parsing related errors. SceneCreationError: If adding an element to the scene fails (e.g., duplicate ID). \"\"\" try : # Instantiate the parser with just the file path parser = AnnotationParser ( annotations_path ) # Parse the file to get fully initialized annotation objects annotation_objects : List [ BaseAnnotationElement ] = parser . parse () logger . info ( f \"Loaded { len ( annotation_objects ) } annotations from { annotations_path } \" ) for annotation in annotation_objects : logger . debug ( f \" \\t > Adding annotation ' { annotation . id } ' ( { annotation . __class__ . __name__ } ) to scene\" ) try : scene . add_element ( annotation ) except Exception as e : logger . error ( f \"Failed to add annotation ' { annotation . id } ' to scene: { e } \" ) raise SceneCreationError ( f \"Failed to add annotation ' { annotation . id } ' to scene: { e } \" ) from e except ( AnnotationFileNotFoundError , MalformedAnnotationError , AnnotationError , ) as e : logger . error ( f \"Failed to parse annotations from { annotations_path } : { e } \" ) # Re-raise parser errors as they indicate a problem with the input file raise except Exception as e : logger . error ( f \"An unexpected error occurred while adding annotations: { str ( e ) } \" ) # Re-raise unexpected errors raise options: show_root_heading: true Creates a Scene containing only specified domains, each in its own group. Elements (structure, connections, annotations) are assigned to their respective domain group. Elements not belonging to any defined domain are discarded. Domain groups are progressively translated: last domain stays at origin, earlier domains get negative progressive translations (i\u00d7gap_x, i\u00d7gap_y) where i is negative. Parameters: projected_structure ( Structure ) \u2013 The Structure object with final 2D projected coordinates. domain_definitions ( List [ DomainTransformation ] ) \u2013 List of DomainTransformation objects defining the domains. The domain_id attribute is crucial. gap_x ( float , default: 0.0 ) \u2013 Progressive horizontal gap between domains in pixels (last domain at origin). gap_y ( float , default: 0.0 ) \u2013 Progressive vertical gap between domains in pixels (last domain at origin). arrangement ( str , default: 'horizontal' ) \u2013 How to arrange domain groups (kept for compatibility). default_styles ( Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , AreaAnnotationStyle ]]] , default: None ) \u2013 Optional dictionary mapping element type names to style instances. domain_scop_ids ( Optional [ Dict [ str , str ]] , default: None ) \u2013 Optional dictionary mapping domain_id to an annotation string (e.g., SCOP ID) used for AreaAnnotation labels. domain_alignment_probabilities ( Optional [ Dict [ str , float ]] , default: None ) \u2013 Optional dictionary mapping domain_id to alignment probability (0.0-1.0) for display in annotations. Returns: Scene \u2013 A Scene object containing only the specified domain groups, laid out progressively. Raises: ValueError \u2013 If structure lacks coordinates, or domain_definitions have issues (missing IDs when needed, duplicates). TypeError \u2013 If incompatible style types are provided in default_styles. Source code in src/flatprot/utils/domain_utils.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 def create_domain_aware_scene ( projected_structure : Structure , domain_definitions : List [ DomainTransformation ], gap_x : float = 0.0 , gap_y : float = 0.0 , arrangement : str = \"horizontal\" , default_styles : Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , AreaAnnotationStyle ]] ] = None , domain_scop_ids : Optional [ Dict [ str , str ]] = None , domain_alignment_probabilities : Optional [ Dict [ str , float ]] = None , ) -> Scene : \"\"\"Creates a Scene containing only specified domains, each in its own group. Elements (structure, connections, annotations) are assigned to their respective domain group. Elements not belonging to any defined domain are discarded. Domain groups are progressively translated: last domain stays at origin, earlier domains get negative progressive translations (i\u00d7gap_x, i\u00d7gap_y) where i is negative. Args: projected_structure: The Structure object with final 2D projected coordinates. domain_definitions: List of DomainTransformation objects defining the domains. The domain_id attribute is crucial. gap_x: Progressive horizontal gap between domains in pixels (last domain at origin). gap_y: Progressive vertical gap between domains in pixels (last domain at origin). arrangement: How to arrange domain groups (kept for compatibility). default_styles: Optional dictionary mapping element type names to style instances. domain_scop_ids: Optional dictionary mapping domain_id to an annotation string (e.g., SCOP ID) used for AreaAnnotation labels. domain_alignment_probabilities: Optional dictionary mapping domain_id to alignment probability (0.0-1.0) for display in annotations. Returns: A Scene object containing only the specified domain groups, laid out progressively. Raises: ValueError: If structure lacks coordinates, or domain_definitions have issues (missing IDs when needed, duplicates). TypeError: If incompatible style types are provided in default_styles. \"\"\" if ( projected_structure . coordinates is None or projected_structure . coordinates . size == 0 ): raise ValueError ( \"Input projected_structure has no coordinates.\" ) if domain_scop_ids and any ( d . domain_id is None for d in domain_definitions ): raise ValueError ( \"All domain_definitions must have a domain_id if domain_scop_ids is provided.\" ) defined_domain_ids = [ d . domain_id for d in domain_definitions if d . domain_id ] if len ( defined_domain_ids ) != len ( set ( defined_domain_ids )): raise ValueError ( \"Duplicate domain_ids found in domain_definitions.\" ) if domain_scop_ids : scop_keys = set ( domain_scop_ids . keys ()) if not scop_keys . issubset ( set ( defined_domain_ids )): missing = scop_keys - set ( defined_domain_ids ) raise ValueError ( f \"domain_scop_ids keys not in domain_ids: { missing } \" ) scene = Scene ( structure = projected_structure ) styles = default_styles or {} domain_groups : Dict [ str , SceneGroup ] = {} # Map domain_id to SceneGroup domain_ids_in_order : List [ str ] = [] # Maintain order for fixed layout domain_tf_lookup : Dict [ str , DomainTransformation ] = {} # --- 1. Create Domain Groups Only --- logger . debug ( \"Creating scene groups for defined domains...\" ) for domain_tf in domain_definitions : domain_id = domain_tf . domain_id or str ( domain_tf . domain_range ) if domain_id in domain_groups : logger . warning ( f \"Skipping duplicate domain ID ' { domain_id } '.\" ) continue domain_group = SceneGroup ( id = domain_id , transforms = GroupTransform ()) scene . add_element ( domain_group ) domain_groups [ domain_id ] = domain_group domain_ids_in_order . append ( domain_id ) domain_tf_lookup [ domain_id ] = domain_tf logger . debug ( f \"Created { len ( domain_groups ) } domain groups.\" ) if not domain_groups : logger . warning ( \"No domain groups created. Scene will be empty.\" ) return scene # Return early if no domains defined/created # --- 2. Assign Structure Elements ONLY to Domain Groups --- logger . debug ( \"Assigning structure elements to domain groups...\" ) element_map : Dict [ str , SceneGroup ] = {} # Map element ID to its parent group elements_assigned_count = 0 elements_discarded_count = 0 for _ , chain in projected_structure : for ss_element in chain . secondary_structure : ss_type = ss_element . secondary_structure_type element_info = STRUCTURE_ELEMENT_MAP . get ( ss_type ) if not element_info : elements_discarded_count += 1 continue # Skip unsupported types ElementClass , _ = element_info ss_range_set = ResidueRangeSet ([ ss_element ]) element_type_key = ss_type . name . lower () assigned_group : Optional [ SceneGroup ] = None # Find the domain this element belongs to for domain_tf in domain_definitions : if ss_element in domain_tf . domain_range : domain_id = domain_tf . domain_id or str ( domain_tf . domain_range ) assigned_group = domain_groups . get ( domain_id ) break # Assign to first matching domain # If element belongs to a defined domain, create and add it if assigned_group : try : base_style = styles . get ( element_type_key ) # Type check base style if base_style is not None and not isinstance ( base_style , BaseStructureStyle ): logger . warning ( f \"Invalid style type for ' { element_type_key } '. Using default.\" ) base_style = None viz_element = ElementClass ( residue_range_set = ss_range_set , style = base_style , # Pass style or None ) scene . add_element ( viz_element , parent_id = assigned_group . id ) element_map [ viz_element . id ] = assigned_group elements_assigned_count += 1 except Exception as e : logger . error ( f \"Error creating/assigning element { ss_element } : { e } \" , exc_info = True , ) elements_discarded_count += 1 else : # Element does not belong to any defined domain, discard it elements_discarded_count += 1 logger . debug ( f \"Assigned { elements_assigned_count } elements to domain groups. Discarded { elements_discarded_count } .\" ) # --- 3. Add Connections ONLY Within the Same Domain Group --- logger . debug ( \"Adding connections within domain groups...\" ) all_structure_elements = scene . get_sequential_structure_elements () connections_added_count = 0 connections_discarded_count = 0 for i in range ( len ( all_structure_elements ) - 1 ): element_i = all_structure_elements [ i ] element_i_plus_1 = all_structure_elements [ i + 1 ] # Check adjacency first if not element_i . is_adjacent_to ( element_i_plus_1 ): continue # Find the groups these elements belong to (if they were added) group_i = element_map . get ( element_i . id ) group_i_plus_1 = element_map . get ( element_i_plus_1 . id ) # Only add connection if both elements exist and are in the SAME group if group_i is not None and group_i is group_i_plus_1 : try : base_conn_style = styles . get ( \"connection\" ) # Type check if base_conn_style is not None and not isinstance ( base_conn_style , ConnectionStyle ): logger . warning ( \"Invalid type for 'connection' style. Using default.\" ) base_conn_style = None conn = Connection ( start_element = element_i , end_element = element_i_plus_1 , style = base_conn_style , ) logger . debug ( f \"Adding connection between { element_i . id } and { element_i_plus_1 . id } to group { group_i . id } \" ) scene . add_element ( conn , parent_id = group_i . id ) connections_added_count += 1 except Exception as e : logger . error ( f \"Failed adding connection between { element_i . id } / { element_i_plus_1 . id } : { e } \" , exc_info = True , ) connections_discarded_count += 1 # Count as discarded if creation fails else : # Connection spans groups or involves discarded elements connections_discarded_count += 1 logger . debug ( f \"Added { connections_added_count } connections within groups. Discarded { connections_discarded_count } .\" ) # --- 4. Add Domain Annotations to Respective Groups --- if domain_scop_ids : logger . debug ( \"Adding domain annotations...\" ) annotations_added_count = 0 base_area_style = styles . get ( \"area_annotation\" ) logger . debug ( f \"Base area style: { base_area_style } \" ) # Type check if base_area_style is not None and not isinstance ( base_area_style , AreaAnnotationStyle ): logger . warning ( \"Invalid type for 'area_annotation' style. Using default.\" ) base_area_style = None for domain_id , scop_id in domain_scop_ids . items (): group = domain_groups . get ( domain_id ) domain_tf = domain_tf_lookup . get ( domain_id ) if not group or not domain_tf : logger . warning ( f \"Cannot add annotation for domain ' { domain_id } ': missing group/definition.\" ) continue try : target_range_set = ResidueRangeSet ([ domain_tf . domain_range ]) # Create label with SCOP ID and alignment probability label = scop_id if ( domain_alignment_probabilities and domain_id in domain_alignment_probabilities ): probability = domain_alignment_probabilities [ domain_id ] label = ( f \" { scop_id } \\n ( { probability : .1% } )\" # e.g., \"3000622\\n(85.3%)\" ) annotation = AreaAnnotation ( id = f \" { domain_id } _area\" , residue_range_set = target_range_set , style = base_area_style , # Pass style or None label = label , ) # Add annotation as child of the specific domain group scene . add_element ( annotation , parent_id = group . id ) annotations_added_count += 1 except Exception as e : logger . error ( f \"Failed adding area annotation for domain { domain_id } : { e } \" , exc_info = True , ) logger . debug ( f \"Added { annotations_added_count } domain area annotations.\" ) # --- 5. Apply Progressive Gap Translation to Domain Groups --- # Apply incremental gap_x and gap_y translation to domains for proper separation if gap_x != 0.0 or gap_y != 0.0 : logger . debug ( f \"Applying progressive gap translation with increments: ( { gap_x } , { gap_y } )\" ) layout_applied_count = 0 # Apply reverse progressive translation - last domain stays at origin, earlier domains get positive gaps num_domains = len ( domain_ids_in_order ) for i , domain_id in enumerate ( domain_ids_in_order ): group = domain_groups . get ( domain_id ) if not group : continue # Should not happen based on checks # Calculate reverse progressive translation: last domain (i=num_domains-1) stays at (0,0) # Earlier domains get progressively larger positive translations for visual separation translate_x = ( num_domains - 1 - i ) * gap_x translate_y = ( num_domains - 1 - i ) * gap_y if group . transforms is None : group . transforms = GroupTransform () group . transforms . translate = ( translate_x , translate_y ) logger . debug ( f \"Applied progressive translation to group { domain_id } : ( { translate_x : .2f } , { translate_y : .2f } )\" ) layout_applied_count += 1 logger . debug ( f \"Applied progressive gap translations to { layout_applied_count } domain groups.\" ) else : logger . debug ( \"Keeping domains in original positions (gap_x = gap_y = 0.0).\" ) # Ensure groups have identity transforms but no translation for domain_id in domain_ids_in_order : group = domain_groups . get ( domain_id ) if group : if group . transforms is None : group . transforms = GroupTransform () group . transforms . translate = ( 0.0 , 0.0 ) # Keep in original position return scene options: show_root_heading: true Scene Errors Exceptions specific to scene creation or processing. CircularDependencyError Bases: SceneError , ValueError Raised when an operation would create a circular parent-child relationship. Source code in src/flatprot/scene/errors.py 43 44 45 46 class CircularDependencyError ( SceneError , ValueError ): # Inherit ValueError for context \"\"\"Raised when an operation would create a circular parent-child relationship.\"\"\" pass DuplicateElementError Bases: SceneError Raised when attempting to add an element that already exists. Source code in src/flatprot/scene/errors.py 25 26 27 28 class DuplicateElementError ( SceneError ): \"\"\"Raised when attempting to add an element that already exists.\"\"\" pass ElementNotFoundError Bases: SceneError Raised when a scene element is not found, typically by ID. Source code in src/flatprot/scene/errors.py 19 20 21 22 class ElementNotFoundError ( SceneError ): \"\"\"Raised when a scene element is not found, typically by ID.\"\"\" pass ElementTypeError Bases: SceneError , TypeError Raised when an element is not of the expected type (e.g., expecting SceneGroup). Source code in src/flatprot/scene/errors.py 37 38 39 40 class ElementTypeError ( SceneError , TypeError ): # Inherit TypeError for type context \"\"\"Raised when an element is not of the expected type (e.g., expecting SceneGroup).\"\"\" pass InvalidSceneOperationError Bases: SceneError , ValueError Raised for operations that are invalid given the current element state (e.g., adding already parented element). Source code in src/flatprot/scene/errors.py 55 56 57 58 class InvalidSceneOperationError ( SceneError , ValueError ): # Inherit ValueError \"\"\"Raised for operations that are invalid given the current element state (e.g., adding already parented element).\"\"\" pass ParentNotFoundError Bases: ElementNotFoundError Raised when a specified parent element ID is not found. Source code in src/flatprot/scene/errors.py 31 32 33 34 class ParentNotFoundError ( ElementNotFoundError ): # Inherits as it's a specific case \"\"\"Raised when a specified parent element ID is not found.\"\"\" pass SceneAnnotationError Bases: SceneError Error related to scene annotations. Source code in src/flatprot/scene/errors.py 13 14 15 16 class SceneAnnotationError ( SceneError ): \"\"\"Error related to scene annotations.\"\"\" pass SceneCreationError Bases: SceneError Raised when creation of a scene fails. Source code in src/flatprot/scene/errors.py 61 62 63 64 class SceneCreationError ( SceneError ): \"\"\"Raised when creation of a scene fails.\"\"\" pass SceneError Bases: FlatProtError Base class for all errors in the scene module. Source code in src/flatprot/scene/errors.py 7 8 9 10 class SceneError ( FlatProtError ): \"\"\"Base class for all errors in the scene module.\"\"\" pass SceneGraphInconsistencyError Bases: SceneError , RuntimeError Raised when an internal inconsistency in the scene graph state is detected. Source code in src/flatprot/scene/errors.py 49 50 51 52 class SceneGraphInconsistencyError ( SceneError , RuntimeError ): # Inherit RuntimeError \"\"\"Raised when an internal inconsistency in the scene graph state is detected.\"\"\" pass TargetResidueNotFoundError Bases: SceneError Error raised when a target residue is not found in the structure. Source code in src/flatprot/scene/errors.py 67 68 69 70 71 72 class TargetResidueNotFoundError ( SceneError ): \"\"\"Error raised when a target residue is not found in the structure.\"\"\" def __init__ ( self , structure : Structure , residue : ResidueCoordinate ): message = f \"Residue { residue } not found in structure { structure } \" super () . __init__ ( message ) options: show_root_heading: true","title":"Scene"},{"location":"api/scene/#scene-api","text":"This section documents the components related to the FlatProt Scene, which acts as a container for projected visual elements before rendering.","title":"Scene API"},{"location":"api/scene/#scene-concept","text":"The \"Scene\" in FlatProt acts as a container that holds all the elements to be visualized after they have been projected into 2D space (plus depth information). It's the bridge between the processed structural data and the final rendering step (e.g., SVG generation). Key concepts: Container: The Scene object holds a collection of SceneElement objects (like helices, sheets, coils, annotations). Coordinate Space: Elements within the scene typically exist in a 2D coordinate system (X, Y) representing the canvas, but they retain a Z-coordinate representing their depth relative to the viewer. Resolution: It often works with a CoordinateResolver to map abstract residue identifiers (like ChainID:ResidueIndex ) to the actual 2D+Depth coordinates within the scene's context. Z-Ordering: The depth information (Z-coordinate) associated with elements allows renderers to draw them in the correct order, ensuring closer elements obscure farther ones. Annotations are typically given a very high depth value to ensure they are drawn on top. Rendering: The Scene object, along with its elements and their associated styles, provides all the necessary information for a Renderer (like SVGRenderer ) to draw the final visualization.","title":"Scene Concept"},{"location":"api/scene/#main-scene-class","text":"The central container for all scene elements. Manages the scene graph for a protein structure visualization. The Scene holds the core protein structure data and a hierarchical tree of SceneElements (nodes), including SceneGroups. It provides methods to build and manipulate this tree, and to query elements based on residue information. Source code in src/flatprot/scene/scene.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 class Scene : \"\"\"Manages the scene graph for a protein structure visualization. The Scene holds the core protein structure data and a hierarchical tree of SceneElements (nodes), including SceneGroups. It provides methods to build and manipulate this tree, and to query elements based on residue information. \"\"\" def __init__ ( self , structure : Structure ): \"\"\"Initializes the Scene with a core Structure object. Args: structure: The core biological structure data. \"\"\" if not isinstance ( structure , Structure ): raise TypeError ( \"Scene must be initialized with a Structure object.\" ) self . _structure : Structure = structure # List of top-level nodes (elements with no parent) # The order here determines the base rendering order of top-level items. self . _nodes : List [ BaseSceneElement ] = [] # For quick lookups by ID self . _element_registry : Dict [ str , BaseSceneElement ] = {} # Create the coordinate resolver instance self . _resolver : Optional [ CoordinateResolver ] = None # Initialize as None @property def structure ( self ) -> Structure : \"\"\"Get the core Structure object associated with this scene.\"\"\" return self . _structure @property def top_level_nodes ( self ) -> List [ BaseSceneElement ]: \"\"\"Get the list of top-level nodes in the scene graph.\"\"\" return self . _nodes def get_element_by_id ( self , id : str ) -> Optional [ BaseSceneElement ]: \"\"\"Retrieve a scene element by its unique ID. Args: id: The ID of the element to find. Returns: The found BaseSceneElement or None if no element has that ID. \"\"\" return self . _element_registry . get ( id ) def _register_element ( self , element : BaseSceneElement ) -> None : \"\"\"Internal method to add an element to the ID registry.\"\"\" if element . id in self . _element_registry : # Raise specific error for duplicate IDs raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) self . _element_registry [ element . id ] = element def _unregister_element ( self , element : BaseSceneElement ) -> None : \"\"\"Internal method to remove an element from the ID registry.\"\"\" if element . id in self . _element_registry : del self . _element_registry [ element . id ] # Invalidate resolver cache if element affecting it is removed self . _resolver = None def add_element ( self , element : BaseSceneElement , parent_id : Optional [ str ] = None ) -> None : \"\"\"Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Args: element: The SceneElement to add. parent_id: The ID of the parent SceneGroup, or None for top-level. Raises: ValueError: If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError: If the element is not a BaseSceneElement. \"\"\" if not isinstance ( element , BaseSceneElement ): # Raise specific type error raise ElementTypeError ( f \"Object to add is not a BaseSceneElement subclass (got { type ( element ) . __name__ } ).\" ) # Check for existing element using ID registry (more reliable) if element . id in self . _element_registry : raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) # Check if element object seems already attached (should have parent=None) # This prevents adding the same *object* instance twice if somehow unregistered but still linked if element . parent is not None : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' already has a parent (' { element . parent . id } ') and cannot be added directly.\" ) # Check if it's already a top-level node (should not happen if parent is None check passes, but belt-and-suspenders) if element in self . _nodes : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' is already a top-level node.\" ) self . _register_element ( element ) # Register first parent : Optional [ SceneGroup ] = None if parent_id is not None : potential_parent = self . get_element_by_id ( parent_id ) if potential_parent is None : self . _unregister_element ( element ) # Rollback # Raise specific error for parent not found raise ParentNotFoundError ( f \"Parent group with ID ' { parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): self . _unregister_element ( element ) # Rollback # Raise specific type error for parent raise ElementTypeError ( f \"Specified parent ' { parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) parent = potential_parent try : if parent : # Let add_child raise its specific errors (e.g., ValueError for circular) parent . add_child ( element ) else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # Catch potential errors from add_child or _set_parent self . _unregister_element ( element ) # Rollback registration (also invalidates resolver) if parent is None and element in self . _nodes : self . _nodes . remove ( element ) # Rollback adding to top-level # Re-raise the original specific error, don't wrap raise e # Invalidate resolver cache if element affecting it is added self . _resolver = None def remove_element ( self , element_id : str ) -> None : \"\"\"Removes a SceneElement and its descendants from the scene graph by ID. Args: element_id: The ID of the SceneElement to remove. Raises: ValueError: If the element with the given ID is not found in the scene. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : # Raise specific error raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) # --- Collect nodes to remove --- (No change needed here) nodes_to_unregister : List [ BaseSceneElement ] = [] nodes_to_process : List [ BaseSceneElement ] = [ element ] while nodes_to_process : node = nodes_to_process . pop ( 0 ) # Check if already unregistered (in case of complex graph manipulations, though ideally not needed) if node . id not in self . _element_registry : continue nodes_to_unregister . append ( node ) if isinstance ( node , SceneGroup ): # Add children to process queue (create copy for safe iteration) nodes_to_process . extend ( list ( node . children )) for node in nodes_to_unregister : self . _unregister_element ( node ) # --- Detach the root element --- # parent = element . parent element_was_top_level = element in self . _nodes if parent : if parent . id in self . _element_registry and isinstance ( parent , SceneGroup ): try : parent . remove_child ( element ) except ValueError : # This *shouldn't* happen if graph is consistent. Treat as inconsistency. # Log it, but also raise a specific error. element . _set_parent ( None ) # Raise inconsistency error instead of just warning raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' not found in supposed parent ' { parent . id } ' children list during removal.\" ) else : # Parent reference exists but parent is invalid/unregistered. element . _set_parent ( None ) # This is also an inconsistency raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Parent ' { parent . id if parent else 'None' } ' of element ' { element . id } ' is invalid or unregistered during removal.\" ) elif element_was_top_level : # If it was supposed to be top-level, remove it self . _nodes . remove ( element ) element . _set_parent ( None ) else : # Element was registered, had no parent, but wasn't in top-level nodes. # This indicates an inconsistency. element . _set_parent ( None ) raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' was registered but not found in the scene graph structure (neither parented nor top-level).\" ) # Invalidate resolver cache since elements were removed self . _resolver = None def move_element ( self , element_id : str , new_parent_id : Optional [ str ] = None ) -> None : \"\"\"Moves a SceneElement identified by its ID to a new parent. Args: element_id: The ID of the SceneElement to move. new_parent_id: The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError: If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError: If the target parent is not a SceneGroup. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) current_parent = element . parent new_parent : Optional [ SceneGroup ] = None if new_parent_id is not None : potential_parent = self . get_element_by_id ( new_parent_id ) if potential_parent is None : raise ParentNotFoundError ( f \"New parent group with ID ' { new_parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): raise ElementTypeError ( f \"Target parent ' { new_parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) new_parent = potential_parent # Prevent circular dependency temp_check : Optional [ BaseSceneElement ] = new_parent while temp_check is not None : if temp_check is element : raise CircularDependencyError ( f \"Cannot move element ' { element_id } ' under ' { new_parent_id } ' - would create circular dependency.\" ) temp_check = temp_check . parent if current_parent is new_parent : return # --- Detach Phase --- # element_was_in_nodes = element in self . _nodes try : if current_parent : current_parent . remove_child ( element ) # Let SceneGroup handle internal parent update elif element_was_in_nodes : self . _nodes . remove ( element ) element . _set_parent ( None ) elif ( element . parent is None ): # Already detached, potentially inconsistent state raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' was already detached before move operation.\" ) else : # Should not be reachable if graph is consistent raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' in inconsistent state during detach phase of move.\" ) except ValueError as e : # If remove_child fails unexpectedly (e.g., element not found when it should be) element . _set_parent ( None ) # Force detachment raise SceneGraphInconsistencyError ( \"Scene Graph Inconsistency: \" + f \"Error detaching ' { element_id } ' from current parent ' { current_parent . id if current_parent else 'None' } ': { e } \" ) from e # Raise inconsistency # --- Attach Phase --- # try : if new_parent : new_parent . add_child ( element ) # Let add_child handle parent update & checks else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # If attaching fails, attempt rollback (reattach to original parent/location) rollback_msg = f \"Failed to attach element ' { element_id } ' to new parent ' { new_parent_id } ': { e } . Attempting rollback.\" try : if current_parent : current_parent . add_child ( element ) # Try adding back to original parent elif element_was_in_nodes : # If it was originally top-level element . _set_parent ( None ) self . _nodes . append ( element ) # If originally detached, leave it detached except Exception as rollback_e : # Rollback failed, graph is likely inconsistent msg = f \"Rollback failed after attach error for element ' { element . id } '. Scene graph may be inconsistent. Rollback error: { rollback_e } \" raise SceneGraphInconsistencyError ( msg ) from e # Raise inconsistency, chaining original error raise InvalidSceneOperationError ( rollback_msg ) from e # Invalidate resolver cache since element position changed self . _resolver = None def traverse ( self ) -> Generator [ Tuple [ BaseSceneElement , int ], None , None ]: \"\"\"Performs a depth-first traversal of the scene graph. Yields: Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). \"\"\" nodes_to_visit : List [ Tuple [ BaseSceneElement , int ]] = [ ( node , 0 ) for node in reversed ( self . _nodes ) ] visited_ids : Set [ str ] = set () while nodes_to_visit : element , depth = nodes_to_visit . pop () # Check registry in case node was removed during traversal (unlikely but possible) if element . id not in self . _element_registry or element . id in visited_ids : continue visited_ids . add ( element . id ) yield element , depth if isinstance ( element , SceneGroup ): # Add children to the stack in reverse order to maintain visit order # Ensure children are also still registered before adding children_to_add = [ ( child , depth + 1 ) for child in reversed ( element . children ) if child . id in self . _element_registry ] nodes_to_visit . extend ( children_to_add ) def get_all_elements ( self ) -> List [ BaseSceneElement ]: \"\"\"Returns a flat list of all elements in the scene graph. Returns: A list containing all BaseSceneElement objects registered in the scene. \"\"\" return list ( self . _element_registry . values ()) def get_sequential_structure_elements ( self ) -> List [ BaseStructureSceneElement ]: \"\"\" Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List[BaseStructureSceneElement]: Sorted list of structure elements. \"\"\" structure_elements : List [ BaseStructureSceneElement ] = [] for element in self . _element_registry . values (): if isinstance ( element , BaseStructureSceneElement ): structure_elements . append ( element ) def sort_key ( element : BaseStructureSceneElement ) -> Tuple [ str , int ]: primary_chain = \"~\" # Use ~ to sort after standard chain IDs start_residue = float ( \"inf\" ) # Sort elements without range last if element . residue_range_set and element . residue_range_set . ranges : # Use the first range (min start residue) for sorting key try : first_range = min ( element . residue_range_set . ranges , key = lambda r : ( r . chain_id , r . start ), ) primary_chain = first_range . chain_id start_residue = first_range . start except ( ValueError , TypeError ) as e : logger . warning ( f \"Could not determine sort key for element { element . id } due to range issue: { e } \" ) else : logger . debug ( f \"Structure element { element . id } has no residue range for sorting.\" ) # Return a tuple for multi-level sorting return ( primary_chain , start_residue ) try : structure_elements . sort ( key = sort_key ) except Exception as e : logger . error ( f \"Error sorting structure elements: { e } \" , exc_info = True ) # Return unsorted list in case of unexpected sorting error return structure_elements def __iter__ ( self ) -> Iterator [ BaseSceneElement ]: \"\"\"Iterate over the top-level nodes of the scene graph.\"\"\" return iter ( self . _nodes ) def __len__ ( self ) -> int : \"\"\"Return the total number of elements currently registered in the scene.\"\"\" return len ( self . _element_registry ) def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene.\"\"\" structure_id = getattr ( self . structure , \"id\" , \"N/A\" ) # Safely get structure ID return ( f \"<Scene structure_id=' { structure_id } ' \" f \"top_level_nodes= { len ( self . _nodes ) } total_elements= { len ( self ) } >\" ) # Lazily create resolver only when needed to avoid issues during Scene init @property def resolver ( self ) -> CoordinateResolver : \"\"\"Get the CoordinateResolver instance for this scene.\"\"\" if self . _resolver is None : # Pass the current element registry self . _resolver = CoordinateResolver ( self . _structure , self . _element_registry ) return self . _resolver","title":"Main Scene Class"},{"location":"api/scene/#flatprot.scene.Scene.resolver","text":"Get the CoordinateResolver instance for this scene.","title":"resolver"},{"location":"api/scene/#flatprot.scene.Scene.structure","text":"Get the core Structure object associated with this scene.","title":"structure"},{"location":"api/scene/#flatprot.scene.Scene.top_level_nodes","text":"Get the list of top-level nodes in the scene graph.","title":"top_level_nodes"},{"location":"api/scene/#flatprot.scene.Scene.__init__","text":"Initializes the Scene with a core Structure object. Parameters: structure ( Structure ) \u2013 The core biological structure data. Source code in src/flatprot/scene/scene.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , structure : Structure ): \"\"\"Initializes the Scene with a core Structure object. Args: structure: The core biological structure data. \"\"\" if not isinstance ( structure , Structure ): raise TypeError ( \"Scene must be initialized with a Structure object.\" ) self . _structure : Structure = structure # List of top-level nodes (elements with no parent) # The order here determines the base rendering order of top-level items. self . _nodes : List [ BaseSceneElement ] = [] # For quick lookups by ID self . _element_registry : Dict [ str , BaseSceneElement ] = {} # Create the coordinate resolver instance self . _resolver : Optional [ CoordinateResolver ] = None # Initialize as None","title":"__init__"},{"location":"api/scene/#flatprot.scene.Scene.__iter__","text":"Iterate over the top-level nodes of the scene graph. Source code in src/flatprot/scene/scene.py 441 442 443 def __iter__ ( self ) -> Iterator [ BaseSceneElement ]: \"\"\"Iterate over the top-level nodes of the scene graph.\"\"\" return iter ( self . _nodes )","title":"__iter__"},{"location":"api/scene/#flatprot.scene.Scene.__len__","text":"Return the total number of elements currently registered in the scene. Source code in src/flatprot/scene/scene.py 445 446 447 def __len__ ( self ) -> int : \"\"\"Return the total number of elements currently registered in the scene.\"\"\" return len ( self . _element_registry )","title":"__len__"},{"location":"api/scene/#flatprot.scene.Scene.__repr__","text":"Provide a string representation of the scene. Source code in src/flatprot/scene/scene.py 449 450 451 452 453 454 455 def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene.\"\"\" structure_id = getattr ( self . structure , \"id\" , \"N/A\" ) # Safely get structure ID return ( f \"<Scene structure_id=' { structure_id } ' \" f \"top_level_nodes= { len ( self . _nodes ) } total_elements= { len ( self ) } >\" )","title":"__repr__"},{"location":"api/scene/#flatprot.scene.Scene.add_element","text":"Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Parameters: element ( BaseSceneElement ) \u2013 The SceneElement to add. parent_id ( Optional [ str ] , default: None ) \u2013 The ID of the parent SceneGroup, or None for top-level. Raises: ValueError \u2013 If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError \u2013 If the element is not a BaseSceneElement. Source code in src/flatprot/scene/scene.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def add_element ( self , element : BaseSceneElement , parent_id : Optional [ str ] = None ) -> None : \"\"\"Adds a SceneElement to the scene graph. If parent_id is provided, the element is added as a child of the specified parent group. Otherwise, it's added as a top-level node. Args: element: The SceneElement to add. parent_id: The ID of the parent SceneGroup, or None for top-level. Raises: ValueError: If parent_id is specified but not found, or if the target parent is not a SceneGroup, or if the element ID already exists. TypeError: If the element is not a BaseSceneElement. \"\"\" if not isinstance ( element , BaseSceneElement ): # Raise specific type error raise ElementTypeError ( f \"Object to add is not a BaseSceneElement subclass (got { type ( element ) . __name__ } ).\" ) # Check for existing element using ID registry (more reliable) if element . id in self . _element_registry : raise DuplicateElementError ( f \"Element with ID ' { element . id } ' already exists in the registry.\" ) # Check if element object seems already attached (should have parent=None) # This prevents adding the same *object* instance twice if somehow unregistered but still linked if element . parent is not None : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' already has a parent (' { element . parent . id } ') and cannot be added directly.\" ) # Check if it's already a top-level node (should not happen if parent is None check passes, but belt-and-suspenders) if element in self . _nodes : raise InvalidSceneOperationError ( f \"Element ' { element . id } ' is already a top-level node.\" ) self . _register_element ( element ) # Register first parent : Optional [ SceneGroup ] = None if parent_id is not None : potential_parent = self . get_element_by_id ( parent_id ) if potential_parent is None : self . _unregister_element ( element ) # Rollback # Raise specific error for parent not found raise ParentNotFoundError ( f \"Parent group with ID ' { parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): self . _unregister_element ( element ) # Rollback # Raise specific type error for parent raise ElementTypeError ( f \"Specified parent ' { parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) parent = potential_parent try : if parent : # Let add_child raise its specific errors (e.g., ValueError for circular) parent . add_child ( element ) else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # Catch potential errors from add_child or _set_parent self . _unregister_element ( element ) # Rollback registration (also invalidates resolver) if parent is None and element in self . _nodes : self . _nodes . remove ( element ) # Rollback adding to top-level # Re-raise the original specific error, don't wrap raise e # Invalidate resolver cache if element affecting it is added self . _resolver = None","title":"add_element"},{"location":"api/scene/#flatprot.scene.Scene.get_all_elements","text":"Returns a flat list of all elements in the scene graph. Returns: List [ BaseSceneElement ] \u2013 A list containing all BaseSceneElement objects registered in the scene. Source code in src/flatprot/scene/scene.py 384 385 386 387 388 389 390 def get_all_elements ( self ) -> List [ BaseSceneElement ]: \"\"\"Returns a flat list of all elements in the scene graph. Returns: A list containing all BaseSceneElement objects registered in the scene. \"\"\" return list ( self . _element_registry . values ())","title":"get_all_elements"},{"location":"api/scene/#flatprot.scene.Scene.get_element_by_id","text":"Retrieve a scene element by its unique ID. Parameters: id ( str ) \u2013 The ID of the element to find. Returns: Optional [ BaseSceneElement ] \u2013 The found BaseSceneElement or None if no element has that ID. Source code in src/flatprot/scene/scene.py 67 68 69 70 71 72 73 74 75 76 def get_element_by_id ( self , id : str ) -> Optional [ BaseSceneElement ]: \"\"\"Retrieve a scene element by its unique ID. Args: id: The ID of the element to find. Returns: The found BaseSceneElement or None if no element has that ID. \"\"\" return self . _element_registry . get ( id )","title":"get_element_by_id"},{"location":"api/scene/#flatprot.scene.Scene.get_sequential_structure_elements","text":"Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List [ BaseStructureSceneElement ] \u2013 List[BaseStructureSceneElement]: Sorted list of structure elements. Source code in src/flatprot/scene/scene.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def get_sequential_structure_elements ( self ) -> List [ BaseStructureSceneElement ]: \"\"\" Returns a list of all BaseStructureSceneElement instances in the scene, sorted sequentially by chain ID and then by starting residue index. Assumes each BaseStructureSceneElement primarily represents a single contiguous range for sorting purposes. Returns: List[BaseStructureSceneElement]: Sorted list of structure elements. \"\"\" structure_elements : List [ BaseStructureSceneElement ] = [] for element in self . _element_registry . values (): if isinstance ( element , BaseStructureSceneElement ): structure_elements . append ( element ) def sort_key ( element : BaseStructureSceneElement ) -> Tuple [ str , int ]: primary_chain = \"~\" # Use ~ to sort after standard chain IDs start_residue = float ( \"inf\" ) # Sort elements without range last if element . residue_range_set and element . residue_range_set . ranges : # Use the first range (min start residue) for sorting key try : first_range = min ( element . residue_range_set . ranges , key = lambda r : ( r . chain_id , r . start ), ) primary_chain = first_range . chain_id start_residue = first_range . start except ( ValueError , TypeError ) as e : logger . warning ( f \"Could not determine sort key for element { element . id } due to range issue: { e } \" ) else : logger . debug ( f \"Structure element { element . id } has no residue range for sorting.\" ) # Return a tuple for multi-level sorting return ( primary_chain , start_residue ) try : structure_elements . sort ( key = sort_key ) except Exception as e : logger . error ( f \"Error sorting structure elements: { e } \" , exc_info = True ) # Return unsorted list in case of unexpected sorting error return structure_elements","title":"get_sequential_structure_elements"},{"location":"api/scene/#flatprot.scene.Scene.move_element","text":"Moves a SceneElement identified by its ID to a new parent. Parameters: element_id ( str ) \u2013 The ID of the SceneElement to move. new_parent_id ( Optional [ str ] , default: None ) \u2013 The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError \u2013 If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError \u2013 If the target parent is not a SceneGroup. Source code in src/flatprot/scene/scene.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def move_element ( self , element_id : str , new_parent_id : Optional [ str ] = None ) -> None : \"\"\"Moves a SceneElement identified by its ID to a new parent. Args: element_id: The ID of the SceneElement to move. new_parent_id: The ID of the new parent SceneGroup, or None to move to the top level. Raises: ValueError: If the element or new parent is not found, if the new parent is not a SceneGroup, or if the move would create a circular dependency. TypeError: If the target parent is not a SceneGroup. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) current_parent = element . parent new_parent : Optional [ SceneGroup ] = None if new_parent_id is not None : potential_parent = self . get_element_by_id ( new_parent_id ) if potential_parent is None : raise ParentNotFoundError ( f \"New parent group with ID ' { new_parent_id } ' not found.\" ) if not isinstance ( potential_parent , SceneGroup ): raise ElementTypeError ( f \"Target parent ' { new_parent_id } ' is not a SceneGroup (got { type ( potential_parent ) . __name__ } ).\" ) new_parent = potential_parent # Prevent circular dependency temp_check : Optional [ BaseSceneElement ] = new_parent while temp_check is not None : if temp_check is element : raise CircularDependencyError ( f \"Cannot move element ' { element_id } ' under ' { new_parent_id } ' - would create circular dependency.\" ) temp_check = temp_check . parent if current_parent is new_parent : return # --- Detach Phase --- # element_was_in_nodes = element in self . _nodes try : if current_parent : current_parent . remove_child ( element ) # Let SceneGroup handle internal parent update elif element_was_in_nodes : self . _nodes . remove ( element ) element . _set_parent ( None ) elif ( element . parent is None ): # Already detached, potentially inconsistent state raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' was already detached before move operation.\" ) else : # Should not be reachable if graph is consistent raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element_id } ' in inconsistent state during detach phase of move.\" ) except ValueError as e : # If remove_child fails unexpectedly (e.g., element not found when it should be) element . _set_parent ( None ) # Force detachment raise SceneGraphInconsistencyError ( \"Scene Graph Inconsistency: \" + f \"Error detaching ' { element_id } ' from current parent ' { current_parent . id if current_parent else 'None' } ': { e } \" ) from e # Raise inconsistency # --- Attach Phase --- # try : if new_parent : new_parent . add_child ( element ) # Let add_child handle parent update & checks else : element . _set_parent ( None ) self . _nodes . append ( element ) except ( ValueError , TypeError , SceneError ) as e : # If attaching fails, attempt rollback (reattach to original parent/location) rollback_msg = f \"Failed to attach element ' { element_id } ' to new parent ' { new_parent_id } ': { e } . Attempting rollback.\" try : if current_parent : current_parent . add_child ( element ) # Try adding back to original parent elif element_was_in_nodes : # If it was originally top-level element . _set_parent ( None ) self . _nodes . append ( element ) # If originally detached, leave it detached except Exception as rollback_e : # Rollback failed, graph is likely inconsistent msg = f \"Rollback failed after attach error for element ' { element . id } '. Scene graph may be inconsistent. Rollback error: { rollback_e } \" raise SceneGraphInconsistencyError ( msg ) from e # Raise inconsistency, chaining original error raise InvalidSceneOperationError ( rollback_msg ) from e # Invalidate resolver cache since element position changed self . _resolver = None","title":"move_element"},{"location":"api/scene/#flatprot.scene.Scene.remove_element","text":"Removes a SceneElement and its descendants from the scene graph by ID. Parameters: element_id ( str ) \u2013 The ID of the SceneElement to remove. Raises: ValueError \u2013 If the element with the given ID is not found in the scene. Source code in src/flatprot/scene/scene.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def remove_element ( self , element_id : str ) -> None : \"\"\"Removes a SceneElement and its descendants from the scene graph by ID. Args: element_id: The ID of the SceneElement to remove. Raises: ValueError: If the element with the given ID is not found in the scene. \"\"\" element = self . get_element_by_id ( element_id ) if element is None : # Raise specific error raise ElementNotFoundError ( f \"Element with ID ' { element_id } ' not found.\" ) # --- Collect nodes to remove --- (No change needed here) nodes_to_unregister : List [ BaseSceneElement ] = [] nodes_to_process : List [ BaseSceneElement ] = [ element ] while nodes_to_process : node = nodes_to_process . pop ( 0 ) # Check if already unregistered (in case of complex graph manipulations, though ideally not needed) if node . id not in self . _element_registry : continue nodes_to_unregister . append ( node ) if isinstance ( node , SceneGroup ): # Add children to process queue (create copy for safe iteration) nodes_to_process . extend ( list ( node . children )) for node in nodes_to_unregister : self . _unregister_element ( node ) # --- Detach the root element --- # parent = element . parent element_was_top_level = element in self . _nodes if parent : if parent . id in self . _element_registry and isinstance ( parent , SceneGroup ): try : parent . remove_child ( element ) except ValueError : # This *shouldn't* happen if graph is consistent. Treat as inconsistency. # Log it, but also raise a specific error. element . _set_parent ( None ) # Raise inconsistency error instead of just warning raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' not found in supposed parent ' { parent . id } ' children list during removal.\" ) else : # Parent reference exists but parent is invalid/unregistered. element . _set_parent ( None ) # This is also an inconsistency raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Parent ' { parent . id if parent else 'None' } ' of element ' { element . id } ' is invalid or unregistered during removal.\" ) elif element_was_top_level : # If it was supposed to be top-level, remove it self . _nodes . remove ( element ) element . _set_parent ( None ) else : # Element was registered, had no parent, but wasn't in top-level nodes. # This indicates an inconsistency. element . _set_parent ( None ) raise SceneGraphInconsistencyError ( f \"SceneGraph Inconsistency: Element ' { element . id } ' was registered but not found in the scene graph structure (neither parented nor top-level).\" ) # Invalidate resolver cache since elements were removed self . _resolver = None","title":"remove_element"},{"location":"api/scene/#flatprot.scene.Scene.traverse","text":"Performs a depth-first traversal of the scene graph. Yields: Tuple [ BaseSceneElement , int ] \u2013 Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). Source code in src/flatprot/scene/scene.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def traverse ( self ) -> Generator [ Tuple [ BaseSceneElement , int ], None , None ]: \"\"\"Performs a depth-first traversal of the scene graph. Yields: Tuple[BaseSceneElement, int]: A tuple containing the scene element and its depth in the tree (0 for top-level). \"\"\" nodes_to_visit : List [ Tuple [ BaseSceneElement , int ]] = [ ( node , 0 ) for node in reversed ( self . _nodes ) ] visited_ids : Set [ str ] = set () while nodes_to_visit : element , depth = nodes_to_visit . pop () # Check registry in case node was removed during traversal (unlikely but possible) if element . id not in self . _element_registry or element . id in visited_ids : continue visited_ids . add ( element . id ) yield element , depth if isinstance ( element , SceneGroup ): # Add children to the stack in reverse order to maintain visit order # Ensure children are also still registered before adding children_to_add = [ ( child , depth + 1 ) for child in reversed ( element . children ) if child . id in self . _element_registry ] nodes_to_visit . extend ( children_to_add ) options: show_root_heading: true members_order: source","title":"traverse"},{"location":"api/scene/#base-classes","text":"Abstract base classes for elements and styles within the scene. Bases: ABC , Generic [ StyleType ] Abstract base class for all elements within a scene graph. This class is generic and requires a specific StyleType that inherits from BaseSceneStyle. Source code in src/flatprot/scene/base_element.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class BaseSceneElement ( ABC , Generic [ StyleType ]): \"\"\"Abstract base class for all elements within a scene graph. This class is generic and requires a specific StyleType that inherits from BaseSceneStyle. \"\"\" def __init__ ( self , id : str , style : Optional [ StyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseSceneElement. Args: id: A unique identifier for this scene element. style: A style instance for this element. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( id , str ) or not id : raise ValueError ( \"SceneElement ID must be a non-empty string.\" ) self . id : str = id self . _style : Optional [ StyleType ] = style or self . default_style self . _parent : Optional [ SceneGroupType ] = parent @property def parent ( self ) -> Optional [ SceneGroupType ]: \"\"\"Get the parent group of this element.\"\"\" return self . _parent # Keep internal setter for parent relationship management by Scene/SceneGroup def _set_parent ( self , value : Optional [ SceneGroupType ]) -> None : \"\"\"Internal method to set the parent group. Should be called by Scene/SceneGroup.\"\"\" # Basic type check, assumes SceneGroup will inherit from BaseSceneElement if value is not None and not isinstance ( value , BaseSceneElement ): # A more specific check like isinstance(value, SceneGroup) would be ideal # but causes circular dependency issues without careful structuring or protocols. # This provides a basic safeguard. We expect SceneGroup to inherit BaseSceneElement. raise TypeError ( \"Parent must be a SceneGroup (subclass of BaseSceneElement).\" ) self . _parent = value @property @abstractmethod def default_style ( self ) -> StyleType : \"\"\"Provides the default style instance for this element type. Subclasses must implement this property. Returns: An instance of the specific StyleType for this element. \"\"\" raise NotImplementedError @property def style ( self ) -> StyleType : \"\"\"Get the effective style for this element (instance-specific or default).\"\"\" return self . _style if self . _style is not None else self . default_style () def update_style ( self , new_style : StyleType ) -> None : \"\"\"Update the instance-specific style of this element. Args: new_style: The new style object to apply. \"\"\" # Ensure the provided style is compatible # Note: isinstance check might be too strict if subclasses of the style are allowed. # Adjust check if necessary based on desired style inheritance behavior. expected_style_type = self . default_style () . __class__ if not isinstance ( new_style , expected_style_type ): raise TypeError ( f \"Invalid style type. Expected { expected_style_type . __name__ } , \" f \"got { type ( new_style ) . __name__ } .\" ) self . _style = new_style @abstractmethod def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A float representing the depth, or None if depth cannot be determined or is not applicable (e.g., for groups). \"\"\" raise NotImplementedError def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene element.\"\"\" parent_id = f \"' { self . _parent . id } '\" if self . _parent else None style_source = \"default\" if self . _style is None else \"instance\" # Safely get range representation, default to 'N/A' if not present range_repr = str ( getattr ( self , \"residue_range_set\" , \"N/A\" )) range_str = f \" range=' { range_repr } '\" if range_repr != \"N/A\" else \"\" target_repr = str ( getattr ( self , \"target\" , \"N/A\" )) target_str = f \" target=' { target_repr } '\" if target_repr != \"N/A\" else \"\" return ( f \"< { self . __class__ . __name__ } id=' { self . id } ' { range_str }{ target_str } \" f \"parent= { parent_id } style_source= { style_source } >\" )","title":"Base Classes"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.default_style","text":"Provides the default style instance for this element type. Subclasses must implement this property. Returns: StyleType \u2013 An instance of the specific StyleType for this element.","title":"default_style"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.parent","text":"Get the parent group of this element.","title":"parent"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.style","text":"Get the effective style for this element (instance-specific or default).","title":"style"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.__init__","text":"Initializes a BaseSceneElement. Parameters: id ( str ) \u2013 A unique identifier for this scene element. style ( Optional [ StyleType ] , default: None ) \u2013 A style instance for this element. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/base_element.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , id : str , style : Optional [ StyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseSceneElement. Args: id: A unique identifier for this scene element. style: A style instance for this element. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( id , str ) or not id : raise ValueError ( \"SceneElement ID must be a non-empty string.\" ) self . id : str = id self . _style : Optional [ StyleType ] = style or self . default_style self . _parent : Optional [ SceneGroupType ] = parent","title":"__init__"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.__repr__","text":"Provide a string representation of the scene element. Source code in src/flatprot/scene/base_element.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __repr__ ( self ) -> str : \"\"\"Provide a string representation of the scene element.\"\"\" parent_id = f \"' { self . _parent . id } '\" if self . _parent else None style_source = \"default\" if self . _style is None else \"instance\" # Safely get range representation, default to 'N/A' if not present range_repr = str ( getattr ( self , \"residue_range_set\" , \"N/A\" )) range_str = f \" range=' { range_repr } '\" if range_repr != \"N/A\" else \"\" target_repr = str ( getattr ( self , \"target\" , \"N/A\" )) target_str = f \" target=' { target_repr } '\" if target_repr != \"N/A\" else \"\" return ( f \"< { self . __class__ . __name__ } id=' { self . id } ' { range_str }{ target_str } \" f \"parent= { parent_id } style_source= { style_source } >\" )","title":"__repr__"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.get_depth","text":"Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ float ] \u2013 A float representing the depth, or None if depth cannot be determined Optional [ float ] \u2013 or is not applicable (e.g., for groups). Source code in src/flatprot/scene/base_element.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate or retrieve the representative depth for Z-ordering. Depth should typically be derived from the pre-projected coordinates (column 2) in the provided structure object. Lower values are typically closer to the viewer. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A float representing the depth, or None if depth cannot be determined or is not applicable (e.g., for groups). \"\"\" raise NotImplementedError","title":"get_depth"},{"location":"api/scene/#flatprot.scene.base_element.BaseSceneElement.update_style","text":"Update the instance-specific style of this element. Parameters: new_style ( StyleType ) \u2013 The new style object to apply. Source code in src/flatprot/scene/base_element.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def update_style ( self , new_style : StyleType ) -> None : \"\"\"Update the instance-specific style of this element. Args: new_style: The new style object to apply. \"\"\" # Ensure the provided style is compatible # Note: isinstance check might be too strict if subclasses of the style are allowed. # Adjust check if necessary based on desired style inheritance behavior. expected_style_type = self . default_style () . __class__ if not isinstance ( new_style , expected_style_type ): raise TypeError ( f \"Invalid style type. Expected { expected_style_type . __name__ } , \" f \"got { type ( new_style ) . __name__ } .\" ) self . _style = new_style options: show_root_heading: true members_order: source Bases: BaseModel Base class for all scene element style definitions using Pydantic. Source code in src/flatprot/scene/base_element.py 19 20 21 22 23 24 25 26 27 28 29 30 class BaseSceneStyle ( BaseModel ): \"\"\"Base class for all scene element style definitions using Pydantic.\"\"\" visibility : bool = Field ( default = True , description = \"Whether the element is visible.\" ) opacity : float = Field ( default = 1.0 , ge = 0.0 , le = 1.0 , description = \"Opacity of the element (0.0 to 1.0).\" ) # Add other common style attributes here if needed later model_config = { \"extra\" : \"forbid\" } # Forbid extra fields options: show_root_heading: true members_order: source","title":"update_style"},{"location":"api/scene/#structure-elements","text":"Classes representing secondary structure elements within the scene. Bases: BaseSceneElement [ StructureStyleType ] , ABC , Generic [ StructureStyleType ] Abstract base class for scene elements representing structural components. Automatically generates an ID based on the subclass type and residue range. Requires a concrete style type inheriting from BaseStructureStyle. Source code in src/flatprot/scene/structure/base_structure.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class BaseStructureSceneElement ( BaseSceneElement [ StructureStyleType ], ABC , Generic [ StructureStyleType ] ): \"\"\"Abstract base class for scene elements representing structural components. Automatically generates an ID based on the subclass type and residue range. Requires a concrete style type inheriting from BaseStructureStyle. \"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ StructureStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Args: residue_range_set: The set of residue ranges this element represents. style: An optional specific style instance for this element. If None, the default style defined by the subclass's `default_style` property will be used at access time. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" # Generate the ID *before* calling super().__init__ # Uses the concrete class's name (e.g., \"Helix\") generated_id = self . _generate_id ( self . __class__ , residue_range_set ) self . residue_range_set = residue_range_set # Pass the potentially None style to the BaseSceneElement constructor. # BaseSceneElement's `style` property handles returning the default # style if the instance's `_style` attribute is None. super () . __init__ ( id = generated_id , style = style , # Pass the direct input style (can be None) parent = parent , ) @staticmethod def _generate_id ( cls : type , residue_range_set : ResidueRangeSet ) -> str : \"\"\"Generates a unique ID based on class name and residue range set.\"\"\" # Ensure the string representation of the range set is canonical and ID-friendly # Replace spaces, commas, and colons to create a valid identifier part. # Sorting ranges within the set ensures canonical representation if order matters. # Assuming ResidueRangeSet.__str__ provides a consistent, sorted representation. range_repr = ( str ( residue_range_set ) . replace ( \" \" , \"\" ) . replace ( \",\" , \"_\" ) . replace ( \":\" , \"-\" ) ) return f \" { cls . __name__ } - { range_repr } \" @abstractmethod def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's `residue_range_set` to query the provided `structure` object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) suitable for rendering (X, Y, Depth). \"\"\" raise NotImplementedError # Concrete subclasses (Helix, Sheet, etc.) MUST implement default_style @property @abstractmethod def default_style ( self ) -> StructureStyleType : \"\"\"Provides the default style instance for this specific element type. Concrete subclasses (e.g., Helix, Sheet) must implement this property. Returns: An instance of the specific StyleType (e.g., HelixStyle) for this element. \"\"\" raise NotImplementedError def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their `get_coordinates` method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), or None if the residue is not found or its coordinate cannot be determined. \"\"\" try : # Check if the residue belongs to the range represented by this element if residue not in self . residue_range_set : logger . debug ( f \"Residue { residue } not in range set { self . residue_range_set } for element ' { self . id } '\" ) return None chain = structure [ residue . chain_id ] # Check if the residue index exists in this chain's mapping if residue . residue_index not in chain : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None coord_index = chain . coordinate_index ( residue . residue_index ) if not ( 0 <= coord_index < len ( structure . coordinates )): struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Coordinate index { coord_index } out of bounds for residue { residue } in structure ' { struct_id } ' (element ' { self . id } ').\" ) return structure . coordinates [ coord_index ] except KeyError : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None except ( IndexError , AttributeError ) as e : struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Error retrieving coordinate for { residue } in structure ' { struct_id } ' (element ' { self . id } '): { e } \" ) from e def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: The mean depth as a float, or None if no coordinates are found. \"\"\" # Get coordinates directly from the element's get_coordinates method # which handles different element types appropriately coords = self . get_coordinates ( structure ) if coords is None or len ( coords ) == 0 : return None # Extract depth values (Z-coordinate) from the coordinates depths = coords [:, 2 ] if len ( depths ) == 0 : return None return float ( np . mean ( depths )) def is_adjacent_to ( self , other : \"BaseStructureSceneElement\" ) -> bool : \"\"\"Check if this element is adjacent to another element. Args: other: The other element to check adjacency with. Returns: True if the elements are adjacent, False otherwise. \"\"\" if not isinstance ( other , BaseStructureSceneElement ): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return self . residue_range_set . is_adjacent_to ( other . residue_range_set ) @abstractmethod def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError @abstractmethod def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError","title":"Structure Elements"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.default_style","text":"Provides the default style instance for this specific element type. Concrete subclasses (e.g., Helix, Sheet) must implement this property. Returns: StructureStyleType \u2013 An instance of the specific StyleType (e.g., HelixStyle) for this element.","title":"default_style"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.__init__","text":"Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Parameters: residue_range_set ( ResidueRangeSet ) \u2013 The set of residue ranges this element represents. style ( Optional [ StructureStyleType ] , default: None ) \u2013 An optional specific style instance for this element. If None, the default style defined by the subclass's default_style property will be used at access time. metadata \u2013 Optional dictionary for storing arbitrary metadata. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/structure/base_structure.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ StructureStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseStructureSceneElement. The ID is generated automatically based on the concrete subclass name and the provided residue range set. Args: residue_range_set: The set of residue ranges this element represents. style: An optional specific style instance for this element. If None, the default style defined by the subclass's `default_style` property will be used at access time. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" # Generate the ID *before* calling super().__init__ # Uses the concrete class's name (e.g., \"Helix\") generated_id = self . _generate_id ( self . __class__ , residue_range_set ) self . residue_range_set = residue_range_set # Pass the potentially None style to the BaseSceneElement constructor. # BaseSceneElement's `style` property handles returning the default # style if the instance's `_style` attribute is None. super () . __init__ ( id = generated_id , style = style , # Pass the direct input style (can be None) parent = parent , )","title":"__init__"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.get_coordinate_at_residue","text":"Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their get_coordinates method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the 2D point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth data. Returns: Optional [ ndarray ] \u2013 A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), Optional [ ndarray ] \u2013 or None if the residue is not found or its coordinate cannot be determined. Source code in src/flatprot/scene/structure/base_structure.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D canvas coordinate + Depth corresponding to a given residue, derived from the pre-projected coordinates in the structure object. This default implementation assumes a direct mapping between the residue index and the corresponding entry in the main structure.coordinates array. Subclasses that implement complex coordinate calculations or simplifications in their `get_coordinates` method (e.g., smoothing, interpolation) MAY NEED TO OVERRIDE this method to provide the correct mapping to their specific rendered representation. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array representing the calculated 2D coordinate + Depth (e.g., [X, Y, Depth]), or None if the residue is not found or its coordinate cannot be determined. \"\"\" try : # Check if the residue belongs to the range represented by this element if residue not in self . residue_range_set : logger . debug ( f \"Residue { residue } not in range set { self . residue_range_set } for element ' { self . id } '\" ) return None chain = structure [ residue . chain_id ] # Check if the residue index exists in this chain's mapping if residue . residue_index not in chain : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None coord_index = chain . coordinate_index ( residue . residue_index ) if not ( 0 <= coord_index < len ( structure . coordinates )): struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Coordinate index { coord_index } out of bounds for residue { residue } in structure ' { struct_id } ' (element ' { self . id } ').\" ) return structure . coordinates [ coord_index ] except KeyError : logger . debug ( f \"Residue { residue } not in chain { chain } for element ' { self . id } '\" ) return None except ( IndexError , AttributeError ) as e : struct_id = getattr ( structure , \"id\" , \"N/A\" ) raise CoordinateCalculationError ( f \"Error retrieving coordinate for { residue } in structure ' { struct_id } ' (element ' { self . id } '): { e } \" ) from e","title":"get_coordinate_at_residue"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.get_coordinates","text":"Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's residue_range_set to query the provided structure object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ ndarray ] \u2013 A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) Optional [ ndarray ] \u2013 suitable for rendering (X, Y, Depth). Source code in src/flatprot/scene/structure/base_structure.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @abstractmethod def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the final 2D + Depth coordinates for rendering this element. Implementations should use the element's `residue_range_set` to query the provided `structure` object (which is assumed to already contain projected 2D + Depth coordinates) and return the relevant slice or a simplified representation (e.g., lines for coils) based on these pre-projected coordinates. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3] or similar) suitable for rendering (X, Y, Depth). \"\"\" raise NotImplementedError","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.get_depth","text":"Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: Optional [ float ] \u2013 The mean depth as a float, or None if no coordinates are found. Source code in src/flatprot/scene/structure/base_structure.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Calculate the mean depth of this structural element. Calculates the mean of the depth values (column 2) of the pre-projected coordinates corresponding to the residues in the element's residue_range_set. Args: structure: The core Structure object containing pre-projected 2D + Depth coordinate data. Returns: The mean depth as a float, or None if no coordinates are found. \"\"\" # Get coordinates directly from the element's get_coordinates method # which handles different element types appropriately coords = self . get_coordinates ( structure ) if coords is None or len ( coords ) == 0 : return None # Extract depth values (Z-coordinate) from the coordinates depths = coords [:, 2 ] if len ( depths ) == 0 : return None return float ( np . mean ( depths ))","title":"get_depth"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.get_end_connection_point","text":"Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Parameters: structure ( Structure ) \u2013 The core Structure object with pre-projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if not applicable/determinable. Source code in src/flatprot/scene/structure/base_structure.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @abstractmethod def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the end connection point. This is typically the coordinate corresponding to the last residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError","title":"get_end_connection_point"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.get_start_connection_point","text":"Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Parameters: structure ( Structure ) \u2013 The core Structure object with pre-projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if not applicable/determinable. Source code in src/flatprot/scene/structure/base_structure.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 @abstractmethod def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Get the 2D coordinate (X, Y) of the start connection point. This is typically the coordinate corresponding to the first residue in the element's range, projected onto the 2D canvas. Args: structure: The core Structure object with pre-projected coordinates. Returns: A NumPy array [X, Y] or None if not applicable/determinable. \"\"\" raise NotImplementedError","title":"get_start_connection_point"},{"location":"api/scene/#flatprot.scene.structure.base_structure.BaseStructureSceneElement.is_adjacent_to","text":"Check if this element is adjacent to another element. Parameters: other ( BaseStructureSceneElement ) \u2013 The other element to check adjacency with. Returns: bool \u2013 True if the elements are adjacent, False otherwise. Source code in src/flatprot/scene/structure/base_structure.py 218 219 220 221 222 223 224 225 226 227 228 229 230 def is_adjacent_to ( self , other : \"BaseStructureSceneElement\" ) -> bool : \"\"\"Check if this element is adjacent to another element. Args: other: The other element to check adjacency with. Returns: True if the elements are adjacent, False otherwise. \"\"\" if not isinstance ( other , BaseStructureSceneElement ): raise TypeError ( f \"Cannot check adjacency with { type ( other ) } \" ) return self . residue_range_set . is_adjacent_to ( other . residue_range_set ) options: show_root_heading: true Bases: BaseSceneStyle Base style for elements representing parts of the protein structure. Source code in src/flatprot/scene/structure/base_structure.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class BaseStructureStyle ( BaseSceneStyle ): \"\"\"Base style for elements representing parts of the protein structure.\"\"\" color : Color = Field ( default = Color (( 0.5 , 0.5 , 0.5 )), description = \"Default color for the element (hex string). Grey.\" , ) stroke_color : Color = Field ( default = Color (( 0.0 , 0.0 , 0.0 )), description = \"Color for the stroke (hex string). Black.\" , ) stroke_width : float = Field ( default = 1.0 , ge = 0.0 , description = \"Line width for stroke.\" ) opacity : float = Field ( default = 1.0 , ge = 0.0 , le = 1.0 , description = \"Opacity for the element.\" ) options: show_root_heading: true Bases: BaseStructureSceneElement [ HelixStyle ] Represents an Alpha Helix segment, visualized as a zigzag ribbon. Source code in src/flatprot/scene/structure/helix.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 class HelixSceneElement ( BaseStructureSceneElement [ HelixStyle ]): \"\"\"Represents an Alpha Helix segment, visualized as a zigzag ribbon.\"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ HelixStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the HelixSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated zigzag coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> HelixStyle : \"\"\"Provides the default style for Helix elements.\"\"\" return HelixStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this helix.\"\"\" coords_list = [] if not self . residue_range_set . ranges : # Cannot get coordinates if no ranges are defined. raise CoordinateCalculationError ( f \"Cannot get coordinates for Helix ' { self . id } ': no residue ranges defined.\" ) helix_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ helix_range . chain_id ] for res_idx in range ( helix_range . start , helix_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : # Coordinate index out of bounds. raise CoordinateCalculationError ( f \"Coordinate index { coord_idx } out of bounds for residue { helix_range . chain_id } : { res_idx } in structure.\" ) else : # Residue not found in chain coordinate map. raise CoordinateCalculationError ( f \"Residue { helix_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : # Error fetching coordinates raise CoordinateCalculationError ( f \"Error fetching coordinates for helix ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the ribbon outline coordinates [X, Y, Depth], or a simple line [start, end] if below min_helix_length. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) if self . _original_coords_len < 2 : # If only one residue, return just that point self . _cached_display_coords = np . array ([ original_coords [ 0 ]]) return self . _cached_display_coords # If too short, return a simple line (start and end points) if self . _original_coords_len < self . style . min_helix_length : self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Calculate zigzag points start_point_3d = original_coords [ 0 ] end_point_3d = original_coords [ - 1 ] zigzag_coords = calculate_zigzag_points ( start_point_3d , end_point_3d , self . style . ribbon_thickness , self . style . wavelength , self . style . amplitude , ) if ( zigzag_coords is None and self . _original_coords_len >= 2 ): # Log only if zigzag expected but failed raise CoordinateCalculationError ( f \"Could not generate zigzag points for helix ' { self . id } ' (length= { self . _original_coords_len } ), likely zero length between endpoints.\" ) self . _cached_display_coords = zigzag_coords return self . _cached_display_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] corresponding to the residue's position. \"\"\" # 1. Ensure display coordinates are calculated display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None element_range = self . residue_range_set . ranges [ 0 ] # Assuming single range if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None except Exception : return None # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Should be shape (1, 3) # 4. Handle the case where a simple line was drawn if len ( display_coords ) == 2 : # Linear interpolation along the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Handle the zigzag ribbon case # display_coords contains top points then bottom points reversed num_wave_points = len ( display_coords ) // 2 # Number of points along one edge if num_wave_points < 1 : raise CoordinateCalculationError ( f \"Invalid number of wave points ( { num_wave_points } ) for helix { self . id } \" ) # Map original sequence index to fractional position along the wave points (0 to num_wave_points-1) mapped_wave_frac = ( original_sequence_index * ( num_wave_points - 1 )) / ( self . _original_coords_len - 1 ) # Find the indices in the display_coords array idx_low = int ( np . floor ( mapped_wave_frac )) idx_high = min ( idx_low + 1 , num_wave_points - 1 ) idx_low = min ( idx_low , num_wave_points - 1 ) # Clamp low index too frac = mapped_wave_frac - idx_low # Get corresponding points on top and bottom edges top_low = display_coords [ idx_low ] top_high = display_coords [ idx_high ] # Bottom indices are reversed: num_total - 1 - index bottom_low = display_coords [ len ( display_coords ) - 1 - idx_low ] bottom_high = display_coords [ len ( display_coords ) - 1 - idx_high ] # Interpolate along top and bottom edges interp_top = top_low * ( 1 - frac ) + top_high * frac interp_bottom = bottom_low * ( 1 - frac ) + bottom_high * frac # Return the midpoint between the interpolated top and bottom points return ( interp_top + interp_bottom ) / 2.0 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 0 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the starting edge # First point (top edge start) = coords_2d[0] # Corresponding bottom point (bottom edge start) = coords_2d[-1] return ( coords_2d [ 0 ] + coords_2d [ - 1 ]) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ 0 ] # Return the first point def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 1 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the ending edge # Last point of top edge = coords_2d[num_edge_points - 1] # Corresponding last point of bottom edge = coords_2d[num_edge_points] num_edge_points = len ( coords_2d ) // 2 last_top_point = coords_2d [ num_edge_points - 1 ] last_bottom_point = coords_2d [ num_edge_points ] return ( last_top_point + last_bottom_point ) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ - 1 ] # Return the last point","title":"is_adjacent_to"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.default_style","text":"Provides the default style for Helix elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.__init__","text":"Initializes the HelixSceneElement. Source code in src/flatprot/scene/structure/helix.py 137 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ HelixStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the HelixSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated zigzag coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None","title":"__init__"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.get_coordinate_at_residue","text":"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] corresponding to the residue's position. Source code in src/flatprot/scene/structure/helix.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the helix representation. For short helices, interpolates linearly. For zigzag helices, finds the midpoint between the top and bottom ribbon points at the corresponding position. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] corresponding to the residue's position. \"\"\" # 1. Ensure display coordinates are calculated display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None element_range = self . residue_range_set . ranges [ 0 ] # Assuming single range if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None except Exception : return None # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Should be shape (1, 3) # 4. Handle the case where a simple line was drawn if len ( display_coords ) == 2 : # Linear interpolation along the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Handle the zigzag ribbon case # display_coords contains top points then bottom points reversed num_wave_points = len ( display_coords ) // 2 # Number of points along one edge if num_wave_points < 1 : raise CoordinateCalculationError ( f \"Invalid number of wave points ( { num_wave_points } ) for helix { self . id } \" ) # Map original sequence index to fractional position along the wave points (0 to num_wave_points-1) mapped_wave_frac = ( original_sequence_index * ( num_wave_points - 1 )) / ( self . _original_coords_len - 1 ) # Find the indices in the display_coords array idx_low = int ( np . floor ( mapped_wave_frac )) idx_high = min ( idx_low + 1 , num_wave_points - 1 ) idx_low = min ( idx_low , num_wave_points - 1 ) # Clamp low index too frac = mapped_wave_frac - idx_low # Get corresponding points on top and bottom edges top_low = display_coords [ idx_low ] top_high = display_coords [ idx_high ] # Bottom indices are reversed: num_total - 1 - index bottom_low = display_coords [ len ( display_coords ) - 1 - idx_low ] bottom_high = display_coords [ len ( display_coords ) - 1 - idx_high ] # Interpolate along top and bottom edges interp_top = top_low * ( 1 - frac ) + top_high * frac interp_bottom = bottom_low * ( 1 - frac ) + bottom_high * frac # Return the midpoint between the interpolated top and bottom points return ( interp_top + interp_bottom ) / 2.0","title":"get_coordinate_at_residue"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.get_coordinates","text":"Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of the ribbon outline coordinates [X, Y, Depth], Optional [ ndarray ] \u2013 or a simple line [start, end] if below min_helix_length. Source code in src/flatprot/scene/structure/helix.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the helix zigzag ribbon. Calculates the ribbon shape based on start/end points of the pre-projected coordinate slice and style parameters. Handles minimum length. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the ribbon outline coordinates [X, Y, Depth], or a simple line [start, end] if below min_helix_length. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) if self . _original_coords_len < 2 : # If only one residue, return just that point self . _cached_display_coords = np . array ([ original_coords [ 0 ]]) return self . _cached_display_coords # If too short, return a simple line (start and end points) if self . _original_coords_len < self . style . min_helix_length : self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Calculate zigzag points start_point_3d = original_coords [ 0 ] end_point_3d = original_coords [ - 1 ] zigzag_coords = calculate_zigzag_points ( start_point_3d , end_point_3d , self . style . ribbon_thickness , self . style . wavelength , self . style . amplitude , ) if ( zigzag_coords is None and self . _original_coords_len >= 2 ): # Log only if zigzag expected but failed raise CoordinateCalculationError ( f \"Could not generate zigzag points for helix ' { self . id } ' (length= { self . _original_coords_len } ), likely zero length between endpoints.\" ) self . _cached_display_coords = zigzag_coords return self . _cached_display_coords","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.get_end_connection_point","text":"Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/helix.py 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 1 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the ending edge # Last point of top edge = coords_2d[num_edge_points - 1] # Corresponding last point of bottom edge = coords_2d[num_edge_points] num_edge_points = len ( coords_2d ) // 2 last_top_point = coords_2d [ num_edge_points - 1 ] last_bottom_point = coords_2d [ num_edge_points ] return ( last_top_point + last_bottom_point ) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ - 1 ] # Return the last point","title":"get_end_connection_point"},{"location":"api/scene/#flatprot.scene.structure.helix.HelixSceneElement.get_start_connection_point","text":"Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/helix.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" # Get the full 3D coordinates used for rendering display_coords = self . get_coordinates ( structure ) if display_coords is None or len ( display_coords ) == 0 : return None coords_2d = display_coords [:, : 2 ] # Work with XY # If rendered as a simple line (2 points) if len ( coords_2d ) == 2 : return coords_2d [ 0 ] # If rendered as zigzag (even number of points >= 4) if len ( coords_2d ) >= 4 : # Midpoint of the starting edge # First point (top edge start) = coords_2d[0] # Corresponding bottom point (bottom edge start) = coords_2d[-1] return ( coords_2d [ 0 ] + coords_2d [ - 1 ]) / 2.0 # Fallback for unexpected cases (e.g., single point helix coord result) return coords_2d [ 0 ] # Return the first point options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Helix elements. Defines properties for rendering helices as zigzag ribbons. Source code in src/flatprot/scene/structure/helix.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class HelixStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Helix elements. Defines properties for rendering helices as zigzag ribbons. \"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#ff0000\" ), description = \"Default color for helix (red).\" ) stroke_width : float = Field ( default = 1 , description = \"Reference width for calculating helix dimensions.\" ) simplified_width : float = Field ( default = 2 , description = \"Width to use for simplified helix rendering (line only).\" , ) # Helix-specific attributes ribbon_thickness : float = Field ( default = 8 , description = \"Factor to multiply linewidth by for the ribbon thickness.\" , ) wavelength : float = Field ( default = 10.0 , description = \"Factor to multiply linewidth by for the zigzag wavelength.\" , ) amplitude : float = Field ( default = 3.0 , description = \"Factor to multiply linewidth by for the zigzag amplitude.\" , ) min_helix_length : int = Field ( default = 4 , ge = 2 , description = \"Minimum number of residues required to draw a zigzag shape instead of a line.\" , ) options: show_root_heading: true Bases: BaseStructureSceneElement [ SheetStyle ] Represents a Beta Sheet segment, visualized as a triangular arrow. Source code in src/flatprot/scene/structure/sheet.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class SheetSceneElement ( BaseStructureSceneElement [ SheetStyle ]): \"\"\"Represents a Beta Sheet segment, visualized as a triangular arrow.\"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ SheetStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the SheetSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated arrow coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> SheetStyle : \"\"\"Provides the default style for Sheet elements.\"\"\" return SheetStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this sheet.\"\"\" coords_list = [] if not self . residue_range_set . ranges : raise CoordinateCalculationError ( f \"Cannot get coordinates for Sheet ' { self . id } ': no residue ranges defined.\" ) sheet_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ sheet_range . chain_id ] for res_idx in range ( sheet_range . start , sheet_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : raise CoordinateCalculationError ( f \"Sheet ' { self . id } ': Coordinate index { coord_idx } out of bounds for residue { sheet_range . chain_id } : { res_idx } .\" ) else : raise CoordinateCalculationError ( f \"Sheet ' { self . id } ': Residue { sheet_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : raise CoordinateCalculationError ( f \"Error fetching coordinates for sheet ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) containing [X, Y, Depth] for each point. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # If only one point, cannot draw line or arrow if self . _original_coords_len == 1 : self . _cached_display_coords = np . array ( [ original_coords [ 0 ]] ) # Return the single point return self . _cached_display_coords # Use only X, Y for shape calculation, keep Z (depth) start_point_xy = original_coords [ 0 , : 2 ] end_point_xy = original_coords [ - 1 , : 2 ] # Use average depth of start/end for the base, end depth for tip start_depth = original_coords [ 0 , 2 ] end_depth = original_coords [ - 1 , 2 ] avg_base_depth = ( start_depth + end_depth ) / 2.0 direction = end_point_xy - start_point_xy length = np . linalg . norm ( direction ) # If too short or degenerate, return a simple line (start and end points) if length < 1e-6 or self . _original_coords_len < self . style . min_sheet_length : # Return original start and end points (X, Y, Depth) self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Normalize direction vector (only need X, Y) direction /= length # Calculate perpendicular vector in 2D perp = np . array ([ - direction [ 1 ], direction [ 0 ]]) arrow_base_half_width = self . style . arrow_width / 2.0 # Calculate arrow base points (X, Y) left_point_xy = start_point_xy + perp * arrow_base_half_width right_point_xy = start_point_xy - perp * arrow_base_half_width # Combine XY with Depth left_point = np . append ( left_point_xy , avg_base_depth ) right_point = np . append ( right_point_xy , avg_base_depth ) tip_point = np . append ( end_point_xy , end_depth ) # Tip uses depth of last residue self . _cached_display_coords = np . array ([ left_point , right_point , tip_point ]) return self . _cached_display_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] interpolated along the sheet axis. \"\"\" # 1. Ensure display coordinates are calculated and length is known display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single continuous range for sheet element representation element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start # Validate index against the original length before simplification/arrow calc if not ( 0 <= original_sequence_index < self . _original_coords_len ): raise CoordinateCalculationError ( f \"Residue index { original_sequence_index } derived from { residue } is out of original bounds [0, { self . _original_coords_len } ) for element { self . id } .\" ) except Exception as e : raise CoordinateCalculationError ( f \"Error calculating original sequence index for { residue } in element { self . id } : { e } \" ) from e # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Return the single point calculated by get_coordinates # 4. Handle the case where a line was drawn (display_coords has 2 points) if len ( display_coords ) == 2 : # Simple linear interpolation between the start and end points of the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Interpolate along the arrow axis (base midpoint to tip) # display_coords has shape [3, 3]: [left_base, right_base, tip] base_midpoint = ( display_coords [ 0 ] + display_coords [ 1 ]) / 2.0 tip_point = display_coords [ 2 ] # Calculate fraction along the length (0 = base midpoint, 1 = tip) # Based on position within the *original* sequence length frac = original_sequence_index / ( self . _original_coords_len - 1 ) # Linear interpolation between base midpoint and tip point interpolated_coord = base_midpoint * ( 1 - frac ) + tip_point * frac return interpolated_coord def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None if len ( coords_2d ) < 3 : return coords_2d [ 0 , : 2 ] return ( coords_2d [ 0 , : 2 ] + coords_2d [ 1 , : 2 ]) / 2 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ]","title":"get_start_connection_point"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.default_style","text":"Provides the default style for Sheet elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.__init__","text":"Initializes the SheetSceneElement. Source code in src/flatprot/scene/structure/sheet.py 57 58 59 60 61 62 63 64 65 66 67 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ SheetStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the SheetSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated arrow coordinates and original length self . _cached_display_coords : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None","title":"__init__"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.get_coordinate_at_residue","text":"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] interpolated along the sheet axis. Source code in src/flatprot/scene/structure/sheet.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue along the central axis of the sheet arrow representation. Interpolates along the axis from the base midpoint to the tip, or along the line if the arrow shape is not drawn. Args: residue: The residue coordinate (chain and index) to find the point for. structure: The core Structure object containing pre-projected data. Returns: A NumPy array [X, Y, Depth] interpolated along the sheet axis. \"\"\" # 1. Ensure display coordinates are calculated and length is known display_coords = self . get_coordinates ( structure ) if ( display_coords is None or self . _original_coords_len is None or self . _original_coords_len == 0 ): return None # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single continuous range for sheet element representation element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Calculate the 0-based index within the original sequence length try : original_sequence_index = residue . residue_index - element_range . start # Validate index against the original length before simplification/arrow calc if not ( 0 <= original_sequence_index < self . _original_coords_len ): raise CoordinateCalculationError ( f \"Residue index { original_sequence_index } derived from { residue } is out of original bounds [0, { self . _original_coords_len } ) for element { self . id } .\" ) except Exception as e : raise CoordinateCalculationError ( f \"Error calculating original sequence index for { residue } in element { self . id } : { e } \" ) from e # Handle single point case if self . _original_coords_len == 1 : return display_coords [ 0 ] # Return the single point calculated by get_coordinates # 4. Handle the case where a line was drawn (display_coords has 2 points) if len ( display_coords ) == 2 : # Simple linear interpolation between the start and end points of the line frac = original_sequence_index / ( self . _original_coords_len - 1 ) interpolated_coord = ( display_coords [ 0 ] * ( 1 - frac ) + display_coords [ 1 ] * frac ) return interpolated_coord # 5. Interpolate along the arrow axis (base midpoint to tip) # display_coords has shape [3, 3]: [left_base, right_base, tip] base_midpoint = ( display_coords [ 0 ] + display_coords [ 1 ]) / 2.0 tip_point = display_coords [ 2 ] # Calculate fraction along the length (0 = base midpoint, 1 = tip) # Based on position within the *original* sequence length frac = original_sequence_index / ( self . _original_coords_len - 1 ) # Linear interpolation between base midpoint and tip point interpolated_coord = base_midpoint * ( 1 - frac ) + tip_point * frac return interpolated_coord","title":"get_coordinate_at_residue"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.get_coordinates","text":"Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) Optional [ ndarray ] \u2013 containing [X, Y, Depth] for each point. Source code in src/flatprot/scene/structure/sheet.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the 2D + Depth coordinates for the sheet arrow. Calculates the three points (arrow base left, base right, tip) based on the start and end points of the pre-projected coordinate slice. Handles minimum length requirement. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of the arrow coordinates (shape [3, 3] or [2, 3]) containing [X, Y, Depth] for each point. \"\"\" if self . _cached_display_coords is not None : return self . _cached_display_coords original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None or len ( original_coords ) == 0 : self . _cached_display_coords = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # If only one point, cannot draw line or arrow if self . _original_coords_len == 1 : self . _cached_display_coords = np . array ( [ original_coords [ 0 ]] ) # Return the single point return self . _cached_display_coords # Use only X, Y for shape calculation, keep Z (depth) start_point_xy = original_coords [ 0 , : 2 ] end_point_xy = original_coords [ - 1 , : 2 ] # Use average depth of start/end for the base, end depth for tip start_depth = original_coords [ 0 , 2 ] end_depth = original_coords [ - 1 , 2 ] avg_base_depth = ( start_depth + end_depth ) / 2.0 direction = end_point_xy - start_point_xy length = np . linalg . norm ( direction ) # If too short or degenerate, return a simple line (start and end points) if length < 1e-6 or self . _original_coords_len < self . style . min_sheet_length : # Return original start and end points (X, Y, Depth) self . _cached_display_coords = np . array ( [ original_coords [ 0 ], original_coords [ - 1 ]] ) return self . _cached_display_coords # Normalize direction vector (only need X, Y) direction /= length # Calculate perpendicular vector in 2D perp = np . array ([ - direction [ 1 ], direction [ 0 ]]) arrow_base_half_width = self . style . arrow_width / 2.0 # Calculate arrow base points (X, Y) left_point_xy = start_point_xy + perp * arrow_base_half_width right_point_xy = start_point_xy - perp * arrow_base_half_width # Combine XY with Depth left_point = np . append ( left_point_xy , avg_base_depth ) right_point = np . append ( right_point_xy , avg_base_depth ) tip_point = np . append ( end_point_xy , end_depth ) # Tip uses depth of last residue self . _cached_display_coords = np . array ([ left_point , right_point , tip_point ]) return self . _cached_display_coords","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.get_end_connection_point","text":"Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/sheet.py 268 269 270 271 272 273 274 275 276 277 278 279 280 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ]","title":"get_end_connection_point"},{"location":"api/scene/#flatprot.scene.structure.sheet.SheetSceneElement.get_start_connection_point","text":"Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/sheet.py 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None if len ( coords_2d ) < 3 : return coords_2d [ 0 , : 2 ] return ( coords_2d [ 0 , : 2 ] + coords_2d [ 1 , : 2 ]) / 2 options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Sheet elements. Defines properties for rendering beta sheets as triangular arrows. Source code in src/flatprot/scene/structure/sheet.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SheetStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Sheet elements. Defines properties for rendering beta sheets as triangular arrows. \"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#0000ff\" ), description = \"Default color for sheet (blue).\" ) stroke_width : float = Field ( default = 1.0 , description = \"Base width of the sheet arrow.\" ) simplified_width : float = Field ( default = 2 , description = \"Width to use for simplified sheet rendering (line only).\" , ) # Sheet-specific attributes arrow_width : float = Field ( default = 8.0 , description = \"Factor to multiply linewidth by for the arrowhead base width.\" , ) min_sheet_length : int = Field ( default = 3 , ge = 1 , description = \"Minimum number of residues required to draw an arrow shape instead of a line.\" , ) options: show_root_heading: true Bases: BaseStructureSceneElement [ CoilStyle ] Represents a Coil segment of a protein structure. Renders as a smoothed line based on the pre-projected coordinates. Source code in src/flatprot/scene/structure/coil.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CoilSceneElement ( BaseStructureSceneElement [ CoilStyle ]): \"\"\"Represents a Coil segment of a protein structure. Renders as a smoothed line based on the pre-projected coordinates. \"\"\" def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ CoilStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the CoilSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated smoothed coordinates and original indices self . _cached_smoothed_coords : Optional [ np . ndarray ] = None self . _original_indices : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None @property def default_style ( self ) -> CoilStyle : \"\"\"Provides the default style for Coil elements.\"\"\" return CoilStyle () def _get_original_coords_slice ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Helper to extract the original coordinate slice for this coil.\"\"\" coords_list = [] if not self . residue_range_set . ranges : raise CoordinateCalculationError ( f \"Cannot get coordinates for Coil ' { self . id } ': no residue ranges defined.\" ) coil_range = self . residue_range_set . ranges [ 0 ] try : chain = structure [ coil_range . chain_id ] for res_idx in range ( coil_range . start , coil_range . end + 1 ): if res_idx in chain : coord_idx = chain . coordinate_index ( res_idx ) if 0 <= coord_idx < len ( structure . coordinates ): coords_list . append ( structure . coordinates [ coord_idx ]) else : raise CoordinateCalculationError ( f \"Coil ' { self . id } ': Coordinate index { coord_idx } out of bounds for residue { coil_range . chain_id } : { res_idx } .\" ) else : raise CoordinateCalculationError ( f \"Coil ' { self . id } ': Residue { coil_range . chain_id } : { res_idx } not found in chain coordinate map.\" ) except ( KeyError , IndexError , AttributeError ) as e : raise CoordinateCalculationError ( f \"Error getting original coordinates for Coil ' { self . id } ': { e } \" ) from e return np . array ( coords_list ) if coords_list else None def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). \"\"\" # Return cached result if available if self . _cached_smoothed_coords is not None : return self . _cached_smoothed_coords # 1. Get the original (pre-projected) coordinates slice for this element original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None : self . _cached_smoothed_coords = None self . _original_indices = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # Handle single-point coils separately if self . _original_coords_len == 1 : self . _cached_smoothed_coords = original_coords self . _original_indices = np . array ([ 0 ]) # Index of the single point return self . _cached_smoothed_coords # 2. Apply smoothing based on style (only if >= 2 points) smoothing_factor = self . style . smoothing_factor smoothed_coords , used_indices = smooth_coordinates ( original_coords , smoothing_factor ) # 3. Cache and return self . _cached_smoothed_coords = smoothed_coords # Map the indices from smooth_coordinates (relative to the slice) back to the # original residue indices or coordinate indices if needed elsewhere, but # for get_2d_coordinate_at_residue, we primarily need the mapping *between* # original sequence index and smoothed sequence index. # We store the indices *within the original slice* that were kept. self . _original_indices = used_indices return self . _cached_smoothed_coords def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. \"\"\" # 1. Ensure smoothed coordinates are calculated and cached # This call populates self._cached_smoothed_coords, self._original_coords_len, etc. smoothed_coords = self . get_coordinates ( structure ) if smoothed_coords is None or self . _original_coords_len is None : return None # Cannot determine coordinate if smoothing failed # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single range for simplicity element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Map residue index to the 0-based index within the *original* sequence of this coil # This index represents the position *before* smoothing. try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None # Residue index is outside the valid range for this element except Exception : return None # Should not happen if residue is in range set, but defensive check # 4. Map the original sequence index to the fractional index within the *smoothed* sequence # This tells us where the original residue falls along the smoothed line. orig_len = self . _original_coords_len smooth_len = len ( smoothed_coords ) # Avoid division by zero if original length was 1 (although checked earlier) if orig_len <= 1 : return smoothed_coords [ 0 ] if smooth_len > 0 else None # Calculate fractional position along the smoothed line mapped_idx_frac = ( original_sequence_index * ( smooth_len - 1 )) / ( orig_len - 1 ) # 5. Linear interpolation between adjacent smoothed points idx_low = int ( np . floor ( mapped_idx_frac )) # Clamp idx_high to the last valid index of the smoothed array idx_high = min ( idx_low + 1 , smooth_len - 1 ) # Ensure idx_low is also within bounds (handles edge case where mapped_idx_frac might be exactly smooth_len-1) idx_low = min ( idx_low , smooth_len - 1 ) # Calculate interpolation fraction frac = mapped_idx_frac - idx_low # Interpolate X, Y, and Depth coord_low = smoothed_coords [ idx_low ] coord_high = smoothed_coords [ idx_high ] interpolated_coord = coord_low * ( 1 - frac ) + coord_high * frac return interpolated_coord def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ 0 , : 2 ] def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ]","title":"get_start_connection_point"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.default_style","text":"Provides the default style for Coil elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.__init__","text":"Initializes the CoilSceneElement. Source code in src/flatprot/scene/structure/coil.py 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , residue_range_set : ResidueRangeSet , style : Optional [ CoilStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes the CoilSceneElement.\"\"\" super () . __init__ ( residue_range_set , style , parent ) # Cache for the calculated smoothed coordinates and original indices self . _cached_smoothed_coords : Optional [ np . ndarray ] = None self . _original_indices : Optional [ np . ndarray ] = None self . _original_coords_len : Optional [ int ] = None","title":"__init__"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.get_coordinate_at_residue","text":"Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Parameters: residue ( ResidueCoordinate ) \u2013 The residue coordinate (chain and index) to find the 2D point for. structure ( Structure ) \u2013 The core Structure object containing pre-projected 2D + Depth data. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. Source code in src/flatprot/scene/structure/coil.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def get_coordinate_at_residue ( self , residue : ResidueCoordinate , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieves the specific 2D coordinate + Depth corresponding to a residue within the smoothed representation of the coil. Uses linear interpolation between the points of the smoothed coil line. Args: residue: The residue coordinate (chain and index) to find the 2D point for. structure: The core Structure object containing pre-projected 2D + Depth data. Returns: A NumPy array [X, Y, Depth] from the smoothed representation, potentially interpolated. \"\"\" # 1. Ensure smoothed coordinates are calculated and cached # This call populates self._cached_smoothed_coords, self._original_coords_len, etc. smoothed_coords = self . get_coordinates ( structure ) if smoothed_coords is None or self . _original_coords_len is None : return None # Cannot determine coordinate if smoothing failed # 2. Check if residue is within the element's range if residue not in self . residue_range_set : return None # Assuming single range for simplicity element_range = self . residue_range_set . ranges [ 0 ] if residue . chain_id != element_range . chain_id : return None # 3. Map residue index to the 0-based index within the *original* sequence of this coil # This index represents the position *before* smoothing. try : original_sequence_index = residue . residue_index - element_range . start if not ( 0 <= original_sequence_index < self . _original_coords_len ): return None # Residue index is outside the valid range for this element except Exception : return None # Should not happen if residue is in range set, but defensive check # 4. Map the original sequence index to the fractional index within the *smoothed* sequence # This tells us where the original residue falls along the smoothed line. orig_len = self . _original_coords_len smooth_len = len ( smoothed_coords ) # Avoid division by zero if original length was 1 (although checked earlier) if orig_len <= 1 : return smoothed_coords [ 0 ] if smooth_len > 0 else None # Calculate fractional position along the smoothed line mapped_idx_frac = ( original_sequence_index * ( smooth_len - 1 )) / ( orig_len - 1 ) # 5. Linear interpolation between adjacent smoothed points idx_low = int ( np . floor ( mapped_idx_frac )) # Clamp idx_high to the last valid index of the smoothed array idx_high = min ( idx_low + 1 , smooth_len - 1 ) # Ensure idx_low is also within bounds (handles edge case where mapped_idx_frac might be exactly smooth_len-1) idx_low = min ( idx_low , smooth_len - 1 ) # Calculate interpolation fraction frac = mapped_idx_frac - idx_low # Interpolate X, Y, and Depth coord_low = smoothed_coords [ idx_low ] coord_high = smoothed_coords [ idx_high ] interpolated_coord = coord_low * ( 1 - frac ) + coord_high * frac return interpolated_coord","title":"get_coordinate_at_residue"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.get_coordinates","text":"Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Parameters: structure ( Structure ) \u2013 The core Structure object containing pre-projected data. Returns: Optional [ ndarray ] \u2013 A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). Source code in src/flatprot/scene/structure/coil.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def get_coordinates ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Retrieve the smoothed 2D + Depth coordinates for rendering the coil. Fetches the pre-projected coordinates from the structure, applies smoothing based on the style's smoothing_factor, and caches the result. Args: structure: The core Structure object containing pre-projected data. Returns: A NumPy array of smoothed 2D + Depth coordinates (X, Y, Depth). \"\"\" # Return cached result if available if self . _cached_smoothed_coords is not None : return self . _cached_smoothed_coords # 1. Get the original (pre-projected) coordinates slice for this element original_coords = self . _get_original_coords_slice ( structure ) if original_coords is None : self . _cached_smoothed_coords = None self . _original_indices = None self . _original_coords_len = 0 return None self . _original_coords_len = len ( original_coords ) # Handle single-point coils separately if self . _original_coords_len == 1 : self . _cached_smoothed_coords = original_coords self . _original_indices = np . array ([ 0 ]) # Index of the single point return self . _cached_smoothed_coords # 2. Apply smoothing based on style (only if >= 2 points) smoothing_factor = self . style . smoothing_factor smoothed_coords , used_indices = smooth_coordinates ( original_coords , smoothing_factor ) # 3. Cache and return self . _cached_smoothed_coords = smoothed_coords # Map the indices from smooth_coordinates (relative to the slice) back to the # original residue indices or coordinate indices if needed elsewhere, but # for get_2d_coordinate_at_residue, we primarily need the mapping *between* # original sequence index and smoothed sequence index. # We store the indices *within the original slice* that were kept. self . _original_indices = used_indices return self . _cached_smoothed_coords","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.get_end_connection_point","text":"Calculate the 2D coordinate for the end connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/coil.py 260 261 262 263 264 265 266 267 268 269 270 271 272 def get_end_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the end connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ - 1 , : 2 ]","title":"get_end_connection_point"},{"location":"api/scene/#flatprot.scene.structure.coil.CoilSceneElement.get_start_connection_point","text":"Calculate the 2D coordinate for the start connection point. Parameters: structure ( Structure ) \u2013 The core Structure object containing projected coordinates. Returns: Optional [ ndarray ] \u2013 A NumPy array [X, Y] or None if calculation fails. Source code in src/flatprot/scene/structure/coil.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def get_start_connection_point ( self , structure : Structure ) -> Optional [ np . ndarray ]: \"\"\"Calculate the 2D coordinate for the start connection point. Args: structure: The core Structure object containing projected coordinates. Returns: A NumPy array [X, Y] or None if calculation fails. \"\"\" coords_2d = self . get_coordinates ( structure )[:, : 2 ] if coords_2d is None : return None return coords_2d [ 0 , : 2 ] options: show_root_heading: true Bases: BaseStructureStyle Style properties specific to Coil elements. Source code in src/flatprot/scene/structure/coil.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class CoilStyle ( BaseStructureStyle ): \"\"\"Style properties specific to Coil elements.\"\"\" # Override inherited defaults color : Color = Field ( default = Color ( \"#5b5859\" ), description = \"Default color for coil (light grey).\" , ) stroke_width : float = Field ( default = 1.0 , description = \"Line width for coil.\" ) # Coil-specific attribute smoothing_factor : float = Field ( default = 0.1 , ge = 0.0 , le = 1.0 , description = \"Fraction of points to keep during smoothing (0.0 to 1.0).\" \"Higher value means less smoothing.\" , ) options: show_root_heading: true","title":"get_start_connection_point"},{"location":"api/scene/#annotation-elements","text":"Classes representing annotation elements within the scene. Bases: BaseSceneElement [ AnnotationStyleType ] , ABC , Generic [ AnnotationStyleType ] Abstract base class for scene elements representing annotations. Stores the original target specification (coordinates, range, or range set) and requires the corresponding ResidueRangeSet for the base scene element. Requires a concrete style type inheriting from BaseAnnotationStyle. Source code in src/flatprot/scene/annotation/base_annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 class BaseAnnotationElement ( BaseSceneElement [ AnnotationStyleType ], ABC , Generic [ AnnotationStyleType ] ): \"\"\"Abstract base class for scene elements representing annotations. Stores the original target specification (coordinates, range, or range set) and requires the corresponding ResidueRangeSet for the base scene element. Requires a concrete style type inheriting from BaseAnnotationStyle. \"\"\" def __init__ ( self , id : str , # ID is required for annotations target : Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ], label : Optional [ str ] = None , style : Optional [ AnnotationStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate `residue_range_set` based on their specific `target` type before calling this initializer. Args: id: A unique identifier for this annotation element. target: The original target specification (list of coordinates, range, or set). Stored for use by subclasses in `get_coordinates`. residue_range_set: The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label: The label for the annotation. style: An optional specific style instance for this annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: TypeError: If the target type is not one of the allowed types. ValueError: If residue_range_set is empty. \"\"\" # Validate the target type if not isinstance ( target , ( ResidueCoordinate , list , ResidueRange , ResidueRangeSet ) ) or ( isinstance ( target , list ) and not all ( isinstance ( item , ResidueCoordinate ) for item in target ) ): raise ValueError ( f \"Unsupported target type for annotation: { type ( target ) } . \" f \"Expected List[ResidueCoordinate], ResidueRange, or ResidueRangeSet.\" ) self . label = label self . _target = target # Store the original target # Pass the explicitly provided residue_range_set to the BaseSceneElement constructor super () . __init__ ( id = id , style = style , parent = parent , ) @property def target ( self ) -> Union [ List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ]: \"\"\"Get the target specification provided during initialization.\"\"\" return self . _target @property def targets_specific_coordinates ( self ) -> bool : \"\"\"Check if this annotation targets a list of specific coordinates.\"\"\" return isinstance ( self . _target , list ) @abstractmethod def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. # Other specific exceptions possible depending on implementation \"\"\" raise NotImplementedError # Concrete subclasses (Marker, Line, Area) MUST implement default_style @property @abstractmethod def default_style ( self ) -> AnnotationStyleType : \"\"\"Provides the default style instance for this specific annotation type. Concrete subclasses must implement this property. Returns: An instance of the specific AnnotationStyleType for this element. \"\"\" raise NotImplementedError def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Args: structure: The core Structure object (unused). Returns: A very large float value (infinity). \"\"\" # Return positive infinity to ensure annotations are sorted last (drawn on top) # when using ascending sort order for depth. Adjust if sort order is descending. return float ( \"inf\" )","title":"Annotation Elements"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.default_style","text":"Provides the default style instance for this specific annotation type. Concrete subclasses must implement this property. Returns: AnnotationStyleType \u2013 An instance of the specific AnnotationStyleType for this element.","title":"default_style"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.target","text":"Get the target specification provided during initialization.","title":"target"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.targets_specific_coordinates","text":"Check if this annotation targets a list of specific coordinates.","title":"targets_specific_coordinates"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.__init__","text":"Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate residue_range_set based on their specific target type before calling this initializer. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target ( Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ] ) \u2013 The original target specification (list of coordinates, range, or set). Stored for use by subclasses in get_coordinates . residue_range_set \u2013 The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label ( Optional [ str ] , default: None ) \u2013 The label for the annotation. style ( Optional [ AnnotationStyleType ] , default: None ) \u2013 An optional specific style instance for this annotation. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: TypeError \u2013 If the target type is not one of the allowed types. ValueError \u2013 If residue_range_set is empty. Source code in src/flatprot/scene/annotation/base_annotation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , id : str , # ID is required for annotations target : Union [ ResidueCoordinate , List [ ResidueCoordinate ], ResidueRange , ResidueRangeSet ], label : Optional [ str ] = None , style : Optional [ AnnotationStyleType ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a BaseAnnotationElement. Subclasses are responsible for constructing the appropriate `residue_range_set` based on their specific `target` type before calling this initializer. Args: id: A unique identifier for this annotation element. target: The original target specification (list of coordinates, range, or set). Stored for use by subclasses in `get_coordinates`. residue_range_set: The ResidueRangeSet derived from the target, required by the BaseSceneElement for its internal logic (e.g., bounding box). label: The label for the annotation. style: An optional specific style instance for this annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: TypeError: If the target type is not one of the allowed types. ValueError: If residue_range_set is empty. \"\"\" # Validate the target type if not isinstance ( target , ( ResidueCoordinate , list , ResidueRange , ResidueRangeSet ) ) or ( isinstance ( target , list ) and not all ( isinstance ( item , ResidueCoordinate ) for item in target ) ): raise ValueError ( f \"Unsupported target type for annotation: { type ( target ) } . \" f \"Expected List[ResidueCoordinate], ResidueRange, or ResidueRangeSet.\" ) self . label = label self . _target = target # Store the original target # Pass the explicitly provided residue_range_set to the BaseSceneElement constructor super () . __init__ ( id = id , style = style , parent = parent , )","title":"__init__"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.get_coordinates","text":"Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError \u2013 If coordinates cannot be resolved. TargetResidueNotFoundError \u2013 If a target residue is not found. Source code in src/flatprot/scene/annotation/base_annotation.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @abstractmethod def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the renderable coordinates for this annotation. Uses the provided CoordinateResolver to find the correct coordinates for its target (coordinates, range, or range set) in the context of the scene elements. The interpretation of the target depends on the concrete annotation type. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of coordinates (shape [N, 3], X, Y, Z) suitable for rendering. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. # Other specific exceptions possible depending on implementation \"\"\" raise NotImplementedError","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.annotation.base_annotation.BaseAnnotationElement.get_depth","text":"Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Parameters: structure ( Structure ) \u2013 The core Structure object (unused). Returns: Optional [ float ] \u2013 A very large float value (infinity). Source code in src/flatprot/scene/annotation/base_annotation.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def get_depth ( self , structure : Structure ) -> Optional [ float ]: \"\"\"Return a fixed high depth value for annotations. This ensures annotations are rendered on top of other elements when sorted by depth (ascending). Args: structure: The core Structure object (unused). Returns: A very large float value (infinity). \"\"\" # Return positive infinity to ensure annotations are sorted last (drawn on top) # when using ascending sort order for depth. Adjust if sort order is descending. return float ( \"inf\" ) options: show_root_heading: true Bases: BaseSceneStyle Base style for annotation elements. Source code in src/flatprot/scene/annotation/base_annotation.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class BaseAnnotationStyle ( BaseSceneStyle ): \"\"\"Base style for annotation elements.\"\"\" color : Color = Field ( default = Color (( 1.0 , 0.0 , 0.0 )), description = \"Default color for the annotation (hex string). Red.\" , ) offset : Tuple [ float , float ] = Field ( default = ( 0.0 , 0.0 ), description = \"2D offset (x, y) from the anchor point in canvas units.\" , ) label_offset : Tuple [ float , float ] = Field ( default = ( 0.0 , 0.0 ), description = \"2D offset (x, y) from the label anchor point in canvas units.\" , ) label_color : Color = Field ( default = Color (( 0.0 , 0.0 , 0.0 )), description = \"Default color for the label (hex string). Black.\" , ) label_font_size : float = Field ( default = 12.0 , description = \"Font size for the label.\" , ) label_font_weight : str = Field ( default = \"normal\" , description = \"Font weight for the label.\" , ) label_font_family : str = Field ( default = \"Arial\" , description = \"Font family for the label.\" , ) label : Optional [ str ] = Field ( default = None , description = \"Optional text label for the annotation.\" ) options: show_root_heading: true Bases: BaseAnnotationElement [ PointAnnotationStyle ] Represents an annotation marking a single residue coordinate. Source code in src/flatprot/scene/annotation/point.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PointAnnotation ( BaseAnnotationElement [ PointAnnotationStyle ]): \"\"\"Represents an annotation marking a single residue coordinate.\"\"\" def __init__ ( self , id : str , target : ResidueCoordinate , # Expects a single coordinate label : Optional [ str ] = None , style : Optional [ PointAnnotationStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a PointAnnotation. Args: id: A unique identifier for this annotation element. target_coordinate: The specific residue coordinate this annotation targets. style: An optional specific style instance for this annotation. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( target , ResidueCoordinate ): raise TypeError ( \"target_coordinate must be a single ResidueCoordinate instance.\" ) # Call superclass init, passing the single coordinate in a list super () . __init__ ( id = id , target = target , # Base class expects a list style = style , label = label , parent = parent , ) @property def target_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the specific target coordinate for this point annotation.\"\"\" # target_coordinates is guaranteed to be a list with one element by __init__ return self . target @property def default_style ( self ) -> PointAnnotationStyle : \"\"\"Provides the default style for PointAnnotation elements.\"\"\" return PointAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates of the target point. Raises: CoordinateCalculationError: If the coordinate cannot be resolved. TargetResidueNotFoundError: If the target residue is not found. \"\"\" target_res = self . target_coordinate # Delegate resolution to the resolver point = resolver . resolve ( target_res ) # Resolver handles errors, so point should be valid if no exception was raised return np . array ([ point ])","title":"get_depth"},{"location":"api/scene/#flatprot.scene.annotation.point.PointAnnotation.default_style","text":"Provides the default style for PointAnnotation elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.annotation.point.PointAnnotation.target_coordinate","text":"Get the specific target coordinate for this point annotation.","title":"target_coordinate"},{"location":"api/scene/#flatprot.scene.annotation.point.PointAnnotation.__init__","text":"Initializes a PointAnnotation. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target_coordinate \u2013 The specific residue coordinate this annotation targets. style ( Optional [ PointAnnotationStyle ] , default: None ) \u2013 An optional specific style instance for this annotation. metadata \u2013 Optional dictionary for storing arbitrary metadata. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Source code in src/flatprot/scene/annotation/point.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , id : str , target : ResidueCoordinate , # Expects a single coordinate label : Optional [ str ] = None , style : Optional [ PointAnnotationStyle ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a PointAnnotation. Args: id: A unique identifier for this annotation element. target_coordinate: The specific residue coordinate this annotation targets. style: An optional specific style instance for this annotation. metadata: Optional dictionary for storing arbitrary metadata. parent: The parent SceneGroup in the scene graph, if any. \"\"\" if not isinstance ( target , ResidueCoordinate ): raise TypeError ( \"target_coordinate must be a single ResidueCoordinate instance.\" ) # Call superclass init, passing the single coordinate in a list super () . __init__ ( id = id , target = target , # Base class expects a list style = style , label = label , parent = parent , )","title":"__init__"},{"location":"api/scene/#flatprot.scene.annotation.point.PointAnnotation.get_coordinates","text":"Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates ndarray \u2013 of the target point. Raises: CoordinateCalculationError \u2013 If the coordinate cannot be resolved. TargetResidueNotFoundError \u2013 If the target residue is not found. Source code in src/flatprot/scene/annotation/point.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the coordinates for the point annotation marker. Uses the CoordinateResolver to find the rendered coordinate of the target residue. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [1, 3] containing the (X, Y, Z) coordinates of the target point. Raises: CoordinateCalculationError: If the coordinate cannot be resolved. TargetResidueNotFoundError: If the target residue is not found. \"\"\" target_res = self . target_coordinate # Delegate resolution to the resolver point = resolver . resolve ( target_res ) # Resolver handles errors, so point should be valid if no exception was raised return np . array ([ point ]) options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to PointAnnotation elements. Source code in src/flatprot/scene/annotation/point.py 25 26 27 28 29 30 31 32 class PointAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to PointAnnotation elements.\"\"\" marker_radius : float = Field ( default = 5.0 , ge = 0 , description = \"Radius of the point marker.\" , ) options: show_root_heading: true Bases: BaseAnnotationElement [ LineAnnotationStyle ] Represents an annotation connecting two specific residue coordinates with a line. Source code in src/flatprot/scene/annotation/line.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class LineAnnotation ( BaseAnnotationElement [ LineAnnotationStyle ]): \"\"\"Represents an annotation connecting two specific residue coordinates with a line.\"\"\" def __init__ ( self , id : str , start_coordinate : ResidueCoordinate , end_coordinate : ResidueCoordinate , style : Optional [ LineAnnotationStyle ] = None , label : Optional [ str ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a LineAnnotation. Args: id: A unique identifier for this annotation element. target_coordinates: A list containing exactly two ResidueCoordinates defining the start and end points of the line. style: The specific style instance for this line annotation. label: The label for the annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If `target_coordinates` does not contain exactly two elements. TypeError: If elements in `target_coordinates` are not ResidueCoordinate instances. \"\"\" if not isinstance ( start_coordinate , ResidueCoordinate ) or not isinstance ( end_coordinate , ResidueCoordinate ): raise ValueError ( \"LineAnnotation must be initialized with two ResidueCoordinate instances.\" ) # Call superclass init super () . __init__ ( id = id , target = [ start_coordinate , end_coordinate ], style = style , label = label , parent = parent , ) @property def start_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the start target coordinate for the line.\"\"\" return self . target [ 0 ] @property def end_coordinate ( self ) -> ResidueCoordinate : \"\"\"Get the end target coordinate for the line.\"\"\" return self . target [ 1 ] @property def default_style ( self ) -> LineAnnotationStyle : \"\"\"Provides the default style for LineAnnotation elements.\"\"\" return LineAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates of the start and end points. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. \"\"\" start_res = self . start_coordinate end_res = self . end_coordinate start_point = resolver . resolve ( start_res ) end_point = resolver . resolve ( end_res ) # Return as a [2, 3] array return np . array ([ start_point , end_point ])","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.annotation.line.LineAnnotation.default_style","text":"Provides the default style for LineAnnotation elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.annotation.line.LineAnnotation.end_coordinate","text":"Get the end target coordinate for the line.","title":"end_coordinate"},{"location":"api/scene/#flatprot.scene.annotation.line.LineAnnotation.start_coordinate","text":"Get the start target coordinate for the line.","title":"start_coordinate"},{"location":"api/scene/#flatprot.scene.annotation.line.LineAnnotation.__init__","text":"Initializes a LineAnnotation. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. target_coordinates \u2013 A list containing exactly two ResidueCoordinates defining the start and end points of the line. style ( Optional [ LineAnnotationStyle ] , default: None ) \u2013 The specific style instance for this line annotation. label ( Optional [ str ] , default: None ) \u2013 The label for the annotation. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: ValueError \u2013 If target_coordinates does not contain exactly two elements. TypeError \u2013 If elements in target_coordinates are not ResidueCoordinate instances. Source code in src/flatprot/scene/annotation/line.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , id : str , start_coordinate : ResidueCoordinate , end_coordinate : ResidueCoordinate , style : Optional [ LineAnnotationStyle ] = None , label : Optional [ str ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes a LineAnnotation. Args: id: A unique identifier for this annotation element. target_coordinates: A list containing exactly two ResidueCoordinates defining the start and end points of the line. style: The specific style instance for this line annotation. label: The label for the annotation. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If `target_coordinates` does not contain exactly two elements. TypeError: If elements in `target_coordinates` are not ResidueCoordinate instances. \"\"\" if not isinstance ( start_coordinate , ResidueCoordinate ) or not isinstance ( end_coordinate , ResidueCoordinate ): raise ValueError ( \"LineAnnotation must be initialized with two ResidueCoordinate instances.\" ) # Call superclass init super () . __init__ ( id = id , target = [ start_coordinate , end_coordinate ], style = style , label = label , parent = parent , )","title":"__init__"},{"location":"api/scene/#flatprot.scene.annotation.line.LineAnnotation.get_coordinates","text":"Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates ndarray \u2013 of the start and end points. Raises: CoordinateCalculationError \u2013 If coordinates cannot be resolved. TargetResidueNotFoundError \u2013 If a target residue is not found. Source code in src/flatprot/scene/annotation/line.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the start and end coordinates for the line annotation. Uses the CoordinateResolver to find the rendered coordinates of the two target residues. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of shape [2, 3] containing the (X, Y, Z) coordinates of the start and end points. Raises: CoordinateCalculationError: If coordinates cannot be resolved. TargetResidueNotFoundError: If a target residue is not found. \"\"\" start_res = self . start_coordinate end_res = self . end_coordinate start_point = resolver . resolve ( start_res ) end_point = resolver . resolve ( end_res ) # Return as a [2, 3] array return np . array ([ start_point , end_point ]) options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to LineAnnotation elements. Source code in src/flatprot/scene/annotation/line.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class LineAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to LineAnnotation elements.\"\"\" stroke_width : float = Field ( default = 1.0 , ge = 0 , description = \"Width of the annotation line.\" ) line_style : Tuple [ float , ... ] = Field ( default = ( 5 , 5 ), description = \"Dash pattern for the line (e.g., (5, 5) for dashed). Empty tuple means solid.\" , ) connector_color : Color = Field ( default = Color ( \"#000000\" ), description = \"Color of the connector circles at the start and end of the line.\" , ) line_color : Color = Field ( default = Color ( \"#000000\" ), description = \"Color of the line.\" , ) arrowhead_start : bool = Field ( default = False , description = \"Whether to draw an arrowhead at the start of the line.\" , ) arrowhead_end : bool = Field ( default = False , description = \"Whether to draw an arrowhead at the end of the line.\" , ) connector_radius : float = Field ( default = 2.0 , ge = 0 , description = \"Radius of the connector circles at the start and end of the line.\" , ) options: show_root_heading: true Bases: BaseAnnotationElement [ AreaAnnotationStyle ] Represents an annotation highlighting an area encompassing specific residues or ranges. Source code in src/flatprot/scene/annotation/area.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class AreaAnnotation ( BaseAnnotationElement [ AreaAnnotationStyle ]): \"\"\"Represents an annotation highlighting an area encompassing specific residues or ranges.\"\"\" def __init__ ( self , id : str , style : Optional [ AreaAnnotationStyle ] = None , label : Optional [ str ] = None , residue_range_set : Optional [ ResidueRangeSet ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes an AreaAnnotation. Exactly one of `residue_range_set` or `target_coordinates` must be provided to define the residues encompassed by the area. Args: id: A unique identifier for this annotation element. style: The specific style instance for this area annotation. label: Optional text label for the annotation. residue_range_set: The set of residue ranges this annotation targets. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If neither or both targeting arguments are provided. \"\"\" # Metadata argument removed, using label directly super () . __init__ ( id = id , target = residue_range_set , style = style , label = label , parent = parent , ) self . _cached_outline_coords : Optional [ np . ndarray ] = None @property def default_style ( self ) -> AreaAnnotationStyle : \"\"\"Provides the default style for AreaAnnotation elements.\"\"\" return AreaAnnotationStyle () def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError: If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. \"\"\" logger . debug ( f \"Calculating area coordinates for ' { self . id } ' using resolver\" ) if self . target is None : raise ValueError ( f \"AreaAnnotation ' { self . id } ' has no target defined.\" ) # 1. Collect all available target 3D coordinates using the resolver target_coords_3d_list : List [ np . ndarray ] = [] for res_coord in self . target : try : point = resolver . resolve ( res_coord ) target_coords_3d_list . append ( point ) except ( CoordinateCalculationError , TargetResidueNotFoundError ) as e : logger . warning ( f \"Could not resolve coordinate for { res_coord } in AreaAnnotation ' { self . id } ': { e } . Skipping point.\" ) # Let unexpected errors propagate if len ( target_coords_3d_list ) < 3 : raise CoordinateCalculationError ( f \"Need at least 3 resolvable points to calculate area for annotation ' { self . id } ', found { len ( target_coords_3d_list ) } within its range set.\" ) # Convert list to numpy array for calculations target_coords_3d = np . array ( target_coords_3d_list ) target_coords_2d = target_coords_3d [:, : 2 ] # Use only XY for shape calculation avg_depth = float ( np . mean ( target_coords_3d [:, 2 ])) # Calculate average depth # 2. Compute the convex hull using Andrew's monotone chain algorithm hull_points_2d = _convex_hull ( target_coords_2d ) # 3. Apply padding by offsetting the vertices of the convex hull padding = self . style . padding if padding > 0 and len ( hull_points_2d ) > 0 : # Add check for non-empty hull padded_points_2d = _apply_padding ( hull_points_2d , padding ) else : padded_points_2d = hull_points_2d # 4. Combine XY with the calculated average depth if len ( padded_points_2d ) == 0 : # This could happen if input points were collinear/identical and hull failed raise CoordinateCalculationError ( f \"Could not compute valid outline for AreaAnnotation ' { self . id } ' after padding. This is a calculation issue, please check the residue range set.\" ) num_outline_points = len ( padded_points_2d ) depth_column = np . full (( num_outline_points , 1 ), avg_depth ) outline_coords_3d = np . hstack (( padded_points_2d , depth_column )) # self._cached_outline_coords = outline_coords_3d # Removed caching logger . debug ( f \"Successfully calculated area coordinates for ' { self . id } '\" ) return outline_coords_3d","title":"get_coordinates"},{"location":"api/scene/#flatprot.scene.annotation.area.AreaAnnotation.default_style","text":"Provides the default style for AreaAnnotation elements.","title":"default_style"},{"location":"api/scene/#flatprot.scene.annotation.area.AreaAnnotation.__init__","text":"Initializes an AreaAnnotation. Exactly one of residue_range_set or target_coordinates must be provided to define the residues encompassed by the area. Parameters: id ( str ) \u2013 A unique identifier for this annotation element. style ( Optional [ AreaAnnotationStyle ] , default: None ) \u2013 The specific style instance for this area annotation. label ( Optional [ str ] , default: None ) \u2013 Optional text label for the annotation. residue_range_set ( Optional [ ResidueRangeSet ] , default: None ) \u2013 The set of residue ranges this annotation targets. parent ( Optional [ SceneGroupType ] , default: None ) \u2013 The parent SceneGroup in the scene graph, if any. Raises: ValueError \u2013 If neither or both targeting arguments are provided. Source code in src/flatprot/scene/annotation/area.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def __init__ ( self , id : str , style : Optional [ AreaAnnotationStyle ] = None , label : Optional [ str ] = None , residue_range_set : Optional [ ResidueRangeSet ] = None , parent : Optional [ SceneGroupType ] = None , ): \"\"\"Initializes an AreaAnnotation. Exactly one of `residue_range_set` or `target_coordinates` must be provided to define the residues encompassed by the area. Args: id: A unique identifier for this annotation element. style: The specific style instance for this area annotation. label: Optional text label for the annotation. residue_range_set: The set of residue ranges this annotation targets. parent: The parent SceneGroup in the scene graph, if any. Raises: ValueError: If neither or both targeting arguments are provided. \"\"\" # Metadata argument removed, using label directly super () . __init__ ( id = id , target = residue_range_set , style = style , label = label , parent = parent , ) self . _cached_outline_coords : Optional [ np . ndarray ] = None","title":"__init__"},{"location":"api/scene/#flatprot.scene.annotation.area.AreaAnnotation.get_coordinates","text":"Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Parameters: resolver ( CoordinateResolver ) \u2013 The CoordinateResolver instance for the scene. Returns: ndarray \u2013 A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing ndarray \u2013 the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError \u2013 If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. Source code in src/flatprot/scene/annotation/area.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_coordinates ( self , resolver : CoordinateResolver ) -> np . ndarray : \"\"\"Calculate the padded convex hull outline coordinates for the area annotation. Fetches coordinates for all residues defined in the residue_range_set using the CoordinateResolver. Calculates the convex hull if at least 3 points are found. Args: resolver: The CoordinateResolver instance for the scene. Returns: A NumPy array of 2D + Depth coordinates (shape [N, 3]) representing the padded convex hull outline of the area (X, Y, AvgDepth). Raises: CoordinateCalculationError: If fewer than 3 valid coordinates are found for the specified residue range set, or if hull/padding calculation fails. \"\"\" logger . debug ( f \"Calculating area coordinates for ' { self . id } ' using resolver\" ) if self . target is None : raise ValueError ( f \"AreaAnnotation ' { self . id } ' has no target defined.\" ) # 1. Collect all available target 3D coordinates using the resolver target_coords_3d_list : List [ np . ndarray ] = [] for res_coord in self . target : try : point = resolver . resolve ( res_coord ) target_coords_3d_list . append ( point ) except ( CoordinateCalculationError , TargetResidueNotFoundError ) as e : logger . warning ( f \"Could not resolve coordinate for { res_coord } in AreaAnnotation ' { self . id } ': { e } . Skipping point.\" ) # Let unexpected errors propagate if len ( target_coords_3d_list ) < 3 : raise CoordinateCalculationError ( f \"Need at least 3 resolvable points to calculate area for annotation ' { self . id } ', found { len ( target_coords_3d_list ) } within its range set.\" ) # Convert list to numpy array for calculations target_coords_3d = np . array ( target_coords_3d_list ) target_coords_2d = target_coords_3d [:, : 2 ] # Use only XY for shape calculation avg_depth = float ( np . mean ( target_coords_3d [:, 2 ])) # Calculate average depth # 2. Compute the convex hull using Andrew's monotone chain algorithm hull_points_2d = _convex_hull ( target_coords_2d ) # 3. Apply padding by offsetting the vertices of the convex hull padding = self . style . padding if padding > 0 and len ( hull_points_2d ) > 0 : # Add check for non-empty hull padded_points_2d = _apply_padding ( hull_points_2d , padding ) else : padded_points_2d = hull_points_2d # 4. Combine XY with the calculated average depth if len ( padded_points_2d ) == 0 : # This could happen if input points were collinear/identical and hull failed raise CoordinateCalculationError ( f \"Could not compute valid outline for AreaAnnotation ' { self . id } ' after padding. This is a calculation issue, please check the residue range set.\" ) num_outline_points = len ( padded_points_2d ) depth_column = np . full (( num_outline_points , 1 ), avg_depth ) outline_coords_3d = np . hstack (( padded_points_2d , depth_column )) # self._cached_outline_coords = outline_coords_3d # Removed caching logger . debug ( f \"Successfully calculated area coordinates for ' { self . id } '\" ) return outline_coords_3d options: show_root_heading: true Bases: BaseAnnotationStyle Style properties specific to AreaAnnotation elements. Source code in src/flatprot/scene/annotation/area.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class AreaAnnotationStyle ( BaseAnnotationStyle ): \"\"\"Style properties specific to AreaAnnotation elements.\"\"\" fill_color : Optional [ Color ] = Field ( default = Color (( 0 , 0 , 0 , 0 )), description = \"Optional fill color (hex string). If None, uses 'color' with reduced opacity.\" , ) fill_opacity : float = Field ( default = 0.3 , ge = 0.0 , le = 1.0 , description = \"Opacity for the fill color.\" ) stroke_width : float = Field ( default = 1.0 , ge = 0 , description = \"Width of the area outline stroke.\" ) line_style : Tuple [ float , ... ] = Field ( default = (), description = \"Dash pattern for the outline (e.g., (5, 5) for dashed). Empty tuple means solid.\" , ) padding : float = Field ( default = 20.0 , ge = 0 , description = \"Padding pixels added outside the convex hull.\" , ) interpolation_points : int = Field ( default = 3 , ge = 3 , description = \"Number of points to generate along the hull outline before smoothing.\" , ) smoothing_window : int = Field ( default = 1 , ge = 1 , description = \"Window size for rolling average smoothing (odd number recommended).\" , ) options: show_root_heading: true","title":"get_coordinates"},{"location":"api/scene/#coordinate-resolver","text":"Handles the mapping between residue identifiers and scene coordinates. Resolves ResidueCoordinates to their final rendered coordinates. This class iterates through relevant scene elements to find the one covering the target residue and asks that element for the coordinate in its specific rendered space. Source code in src/flatprot/scene/resolver.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class CoordinateResolver : \"\"\" Resolves ResidueCoordinates to their final rendered coordinates. This class iterates through relevant scene elements to find the one covering the target residue and asks that element for the coordinate in its specific rendered space. \"\"\" def __init__ ( self , structure : Structure , element_registry : Dict [ str , BaseSceneElement ] ): \"\"\" Initializes the CoordinateResolver. Args: structure: The core Structure object. element_registry: The Scene's dictionary mapping element IDs to elements. \"\"\" self . _structure = structure # Filter the registry to only contain structure elements for efficiency self . _structure_elements = [ element for element in element_registry . values () if isinstance ( element , BaseStructureSceneElement ) ] def resolve ( self , target_residue : ResidueCoordinate ) -> np . ndarray : \"\"\" Finds the covering structure element and gets the rendered coordinate. Args: target_residue: The ResidueCoordinate to resolve. Returns: A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError: If the residue is not found within any covering structure element's range. CoordinateCalculationError: If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. \"\"\" covering_element : Optional [ BaseStructureSceneElement ] = None for element in self . _structure_elements : # Check if the element's range set exists and contains the target if ( element . residue_range_set and target_residue in element . residue_range_set ): covering_element = element break # Use the first one found if covering_element is None : logger . warning ( f \"No structure element found covering target residue { target_residue } .\" ) # Raise specific error indicating no element coverage raise CoordinateCalculationError ( f \"Target residue { target_residue } is not covered by any structure element in the scene.\" ) # Ask the covering element for the coordinate try : resolved_coord = covering_element . get_coordinate_at_residue ( target_residue , self . _structure ) if resolved_coord is None : # Element covered the range but couldn't resolve the specific point logger . warning ( f \"Element ' { covering_element . id } ' could not provide coordinate for { target_residue } .\" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' failed to resolve coordinate for { target_residue } .\" ) # Validate shape if not isinstance ( resolved_coord , np . ndarray ) or resolved_coord . shape != ( 3 , ): logger . error ( f \"Element ' { covering_element . id } ' returned invalid coordinate shape for { target_residue } : { type ( resolved_coord ) } shape { getattr ( resolved_coord , 'shape' , 'N/A' ) } \" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' returned invalid coordinate data for { target_residue } .\" ) return resolved_coord except TargetResidueNotFoundError as e : # This can happen if the element's internal lookup fails logger . warning ( f \"Element ' { covering_element . id } ' could not find { target_residue } internally: { e } \" ) raise # Re-raise the specific error except CoordinateCalculationError as e : logger . error ( f \"Coordinate calculation error within element ' { covering_element . id } ' for { target_residue } : { e } \" , exc_info = True , ) raise # Re-raise calculation errors from the element except Exception as e : # Catch unexpected errors from the element's method logger . error ( f \"Unexpected error in get_coordinate_at_residue for element ' { covering_element . id } ' and { target_residue } : { e } \" , exc_info = True , ) raise CoordinateCalculationError ( f \"Unexpected error resolving coordinate for { target_residue } via element ' { covering_element . id } '.\" ) from e","title":"Coordinate Resolver"},{"location":"api/scene/#flatprot.scene.resolver.CoordinateResolver.__init__","text":"Initializes the CoordinateResolver. Parameters: structure ( Structure ) \u2013 The core Structure object. element_registry ( Dict [ str , BaseSceneElement ] ) \u2013 The Scene's dictionary mapping element IDs to elements. Source code in src/flatprot/scene/resolver.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , structure : Structure , element_registry : Dict [ str , BaseSceneElement ] ): \"\"\" Initializes the CoordinateResolver. Args: structure: The core Structure object. element_registry: The Scene's dictionary mapping element IDs to elements. \"\"\" self . _structure = structure # Filter the registry to only contain structure elements for efficiency self . _structure_elements = [ element for element in element_registry . values () if isinstance ( element , BaseStructureSceneElement ) ]","title":"__init__"},{"location":"api/scene/#flatprot.scene.resolver.CoordinateResolver.resolve","text":"Finds the covering structure element and gets the rendered coordinate. Parameters: target_residue ( ResidueCoordinate ) \u2013 The ResidueCoordinate to resolve. Returns: ndarray \u2013 A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError \u2013 If the residue is not found within any covering structure element's range. CoordinateCalculationError \u2013 If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. Source code in src/flatprot/scene/resolver.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def resolve ( self , target_residue : ResidueCoordinate ) -> np . ndarray : \"\"\" Finds the covering structure element and gets the rendered coordinate. Args: target_residue: The ResidueCoordinate to resolve. Returns: A NumPy array [3,] with the resolved (X, Y, Z) coordinate. Raises: TargetResidueNotFoundError: If the residue is not found within any covering structure element's range. CoordinateCalculationError: If the covering element exists but fails to calculate the specific coordinate, or if no covering element is found. \"\"\" covering_element : Optional [ BaseStructureSceneElement ] = None for element in self . _structure_elements : # Check if the element's range set exists and contains the target if ( element . residue_range_set and target_residue in element . residue_range_set ): covering_element = element break # Use the first one found if covering_element is None : logger . warning ( f \"No structure element found covering target residue { target_residue } .\" ) # Raise specific error indicating no element coverage raise CoordinateCalculationError ( f \"Target residue { target_residue } is not covered by any structure element in the scene.\" ) # Ask the covering element for the coordinate try : resolved_coord = covering_element . get_coordinate_at_residue ( target_residue , self . _structure ) if resolved_coord is None : # Element covered the range but couldn't resolve the specific point logger . warning ( f \"Element ' { covering_element . id } ' could not provide coordinate for { target_residue } .\" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' failed to resolve coordinate for { target_residue } .\" ) # Validate shape if not isinstance ( resolved_coord , np . ndarray ) or resolved_coord . shape != ( 3 , ): logger . error ( f \"Element ' { covering_element . id } ' returned invalid coordinate shape for { target_residue } : { type ( resolved_coord ) } shape { getattr ( resolved_coord , 'shape' , 'N/A' ) } \" ) raise CoordinateCalculationError ( f \"Element ' { covering_element . id } ' returned invalid coordinate data for { target_residue } .\" ) return resolved_coord except TargetResidueNotFoundError as e : # This can happen if the element's internal lookup fails logger . warning ( f \"Element ' { covering_element . id } ' could not find { target_residue } internally: { e } \" ) raise # Re-raise the specific error except CoordinateCalculationError as e : logger . error ( f \"Coordinate calculation error within element ' { covering_element . id } ' for { target_residue } : { e } \" , exc_info = True , ) raise # Re-raise calculation errors from the element except Exception as e : # Catch unexpected errors from the element's method logger . error ( f \"Unexpected error in get_coordinate_at_residue for element ' { covering_element . id } ' and { target_residue } : { e } \" , exc_info = True , ) raise CoordinateCalculationError ( f \"Unexpected error resolving coordinate for { target_residue } via element ' { covering_element . id } '.\" ) from e options: show_root_heading: true members_order: source","title":"resolve"},{"location":"api/scene/#scene-utilities","text":"Helper functions for creating and modifying scenes. Creates a Scene object populated with elements derived from a Structure. Iterates through chains and secondary structure elements within the provided Structure object, creating corresponding SceneGroup and structure-specific SceneElements (Helix, Sheet, Coil). Elements within each chain group are sorted by their mean depth based on the pre-calculated coordinates in the Structure object. Parameters: structure ( Structure ) \u2013 The core Structure object containing chain, secondary structure, and pre-projected coordinate data (X, Y, Depth). default_styles ( Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle ]]] , default: None ) \u2013 An optional dictionary mapping lowercase element type names ('helix', 'sheet', 'coil', 'connection') to specific style instances to be used as defaults. If not provided or a type is missing, the element's own default style will be used. Returns: Scene \u2013 A Scene object representing the structure. Raises: SceneCreationError \u2013 If Structure has no coordinates or other critical errors occur. CoordinateCalculationError \u2013 If depth calculation fails for an element. Source code in src/flatprot/utils/scene_utils.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def create_scene_from_structure ( structure : Structure , default_styles : Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle ]] ] = None , ) -> Scene : \"\"\"Creates a Scene object populated with elements derived from a Structure. Iterates through chains and secondary structure elements within the provided Structure object, creating corresponding SceneGroup and structure-specific SceneElements (Helix, Sheet, Coil). Elements within each chain group are sorted by their mean depth based on the pre-calculated coordinates in the Structure object. Args: structure: The core Structure object containing chain, secondary structure, and pre-projected coordinate data (X, Y, Depth). default_styles: An optional dictionary mapping lowercase element type names ('helix', 'sheet', 'coil', 'connection') to specific style instances to be used as defaults. If not provided or a type is missing, the element's own default style will be used. Returns: A Scene object representing the structure. Raises: SceneCreationError: If Structure has no coordinates or other critical errors occur. CoordinateCalculationError: If depth calculation fails for an element. \"\"\" if structure . coordinates is None or len ( structure . coordinates ) == 0 : raise SceneCreationError ( f \"Structure ' { structure . id } ' has no coordinates.\" ) scene = Scene ( structure = structure ) styles = default_styles or {} for chain_id , chain in structure : chain_group = SceneGroup ( id = f \" { structure . id } _ { chain_id } \" ) scene . add_element ( chain_group ) logger . debug ( f \" \\t >Adding chain group { chain_group . id } to scene\" ) elements_with_depth = [] chain_elements_in_order : List [ BaseStructureSceneElement ] = [] for ss_element in chain . secondary_structure : ss_type = ss_element . secondary_structure_type element_info = STRUCTURE_ELEMENT_MAP . get ( ss_type ) if not element_info : logger . warning ( f \"Unsupported secondary structure type: { ss_type . value } \" ) continue ElementClass , DefaultStyleClass = element_info # Ensure ss_element start/end are valid ints start_idx = int ( ss_element . start ) end_idx = int ( ss_element . end ) ss_range_set = ResidueRangeSet ( [ ResidueRange ( chain_id = chain_id , start = start_idx , end = end_idx )] ) # Determine the style: Use provided default or element's default element_type_key = ss_type . name . lower () style_instance = styles . get ( element_type_key , None ) try : viz_element = ElementClass ( residue_range_set = ss_range_set , style = style_instance , # Pass the specific instance or None ) # Calculate depth based on *pre-projected* coords in structure depth = viz_element . get_depth ( structure ) if depth is None : # Raise or warn if depth calculation fails raise CoordinateCalculationError ( f \"Could not calculate depth for element { viz_element . id } \" ) elements_with_depth . append (( viz_element , depth )) chain_elements_in_order . append ( viz_element ) # <-- Add element to ordered list except CoordinateCalculationError as e : # Log or handle coordinate/depth errors # For now, re-raise to indicate a problem raise SceneCreationError ( f \"Error processing element { ss_type . value } { ss_range_set } in chain { chain_id } : { e } \" ) from e except Exception as e : # Catch unexpected errors during element creation raise SceneCreationError ( f \"Unexpected error creating element { ss_type . value } { ss_range_set } in chain { chain_id } : { e } \" ) from e # Sort elements by depth (farthest first) elements_with_depth . sort ( key = lambda x : x [ 1 ], reverse = True ) # Add Connections between adjacent elements in the original structural order for i in range ( len ( chain_elements_in_order ) - 1 ): element_i = chain_elements_in_order [ i ] element_i_plus_1 = chain_elements_in_order [ i + 1 ] if element_i . is_adjacent_to ( element_i_plus_1 ): # Get the default connection style if provided conn_style = styles . get ( \"connection\" , None ) # Ensure it's a ConnectionStyle or None before passing if conn_style is not None and not isinstance ( conn_style , ConnectionStyle ): logger . warning ( f \"Invalid type provided for 'connection' style. Expected ConnectionStyle, got { type ( conn_style ) } . Using default.\" ) conn_style = None conn = Connection ( start_element = element_i , end_element = element_i_plus_1 , style = conn_style , # Pass the default style ) logger . debug ( f \" \\t >Adding connection { conn . id } to chain group { chain_group . id } \" ) scene . add_element ( conn , parent_id = chain_group . id ) # Add sorted elements to the chain group for element , _ in elements_with_depth : logger . debug ( f \" \\t >Adding element { element . id } to chain group { chain_group . id } \" ) scene . add_element ( element , parent_id = chain_group . id ) return scene options: show_root_heading: true Parses annotations from a file and adds them to the scene. Parameters: annotations_path ( Path ) \u2013 Path to the TOML annotations file. scene ( Scene ) \u2013 The Scene object to add annotations to. Raises: AnnotationFileNotFoundError \u2013 If the annotation file is not found. MalformedAnnotationError \u2013 If the annotation file has invalid content or format. AnnotationError \u2013 For other annotation parsing related errors. SceneCreationError \u2013 If adding an element to the scene fails (e.g., duplicate ID). Source code in src/flatprot/utils/scene_utils.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def add_annotations_to_scene ( annotations_path : Path , scene : Scene ) -> None : \"\"\"Parses annotations from a file and adds them to the scene. Args: annotations_path: Path to the TOML annotations file. scene: The Scene object to add annotations to. Raises: AnnotationFileNotFoundError: If the annotation file is not found. MalformedAnnotationError: If the annotation file has invalid content or format. AnnotationError: For other annotation parsing related errors. SceneCreationError: If adding an element to the scene fails (e.g., duplicate ID). \"\"\" try : # Instantiate the parser with just the file path parser = AnnotationParser ( annotations_path ) # Parse the file to get fully initialized annotation objects annotation_objects : List [ BaseAnnotationElement ] = parser . parse () logger . info ( f \"Loaded { len ( annotation_objects ) } annotations from { annotations_path } \" ) for annotation in annotation_objects : logger . debug ( f \" \\t > Adding annotation ' { annotation . id } ' ( { annotation . __class__ . __name__ } ) to scene\" ) try : scene . add_element ( annotation ) except Exception as e : logger . error ( f \"Failed to add annotation ' { annotation . id } ' to scene: { e } \" ) raise SceneCreationError ( f \"Failed to add annotation ' { annotation . id } ' to scene: { e } \" ) from e except ( AnnotationFileNotFoundError , MalformedAnnotationError , AnnotationError , ) as e : logger . error ( f \"Failed to parse annotations from { annotations_path } : { e } \" ) # Re-raise parser errors as they indicate a problem with the input file raise except Exception as e : logger . error ( f \"An unexpected error occurred while adding annotations: { str ( e ) } \" ) # Re-raise unexpected errors raise options: show_root_heading: true Creates a Scene containing only specified domains, each in its own group. Elements (structure, connections, annotations) are assigned to their respective domain group. Elements not belonging to any defined domain are discarded. Domain groups are progressively translated: last domain stays at origin, earlier domains get negative progressive translations (i\u00d7gap_x, i\u00d7gap_y) where i is negative. Parameters: projected_structure ( Structure ) \u2013 The Structure object with final 2D projected coordinates. domain_definitions ( List [ DomainTransformation ] ) \u2013 List of DomainTransformation objects defining the domains. The domain_id attribute is crucial. gap_x ( float , default: 0.0 ) \u2013 Progressive horizontal gap between domains in pixels (last domain at origin). gap_y ( float , default: 0.0 ) \u2013 Progressive vertical gap between domains in pixels (last domain at origin). arrangement ( str , default: 'horizontal' ) \u2013 How to arrange domain groups (kept for compatibility). default_styles ( Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , AreaAnnotationStyle ]]] , default: None ) \u2013 Optional dictionary mapping element type names to style instances. domain_scop_ids ( Optional [ Dict [ str , str ]] , default: None ) \u2013 Optional dictionary mapping domain_id to an annotation string (e.g., SCOP ID) used for AreaAnnotation labels. domain_alignment_probabilities ( Optional [ Dict [ str , float ]] , default: None ) \u2013 Optional dictionary mapping domain_id to alignment probability (0.0-1.0) for display in annotations. Returns: Scene \u2013 A Scene object containing only the specified domain groups, laid out progressively. Raises: ValueError \u2013 If structure lacks coordinates, or domain_definitions have issues (missing IDs when needed, duplicates). TypeError \u2013 If incompatible style types are provided in default_styles. Source code in src/flatprot/utils/domain_utils.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 def create_domain_aware_scene ( projected_structure : Structure , domain_definitions : List [ DomainTransformation ], gap_x : float = 0.0 , gap_y : float = 0.0 , arrangement : str = \"horizontal\" , default_styles : Optional [ Dict [ str , Union [ BaseStructureStyle , ConnectionStyle , AreaAnnotationStyle ]] ] = None , domain_scop_ids : Optional [ Dict [ str , str ]] = None , domain_alignment_probabilities : Optional [ Dict [ str , float ]] = None , ) -> Scene : \"\"\"Creates a Scene containing only specified domains, each in its own group. Elements (structure, connections, annotations) are assigned to their respective domain group. Elements not belonging to any defined domain are discarded. Domain groups are progressively translated: last domain stays at origin, earlier domains get negative progressive translations (i\u00d7gap_x, i\u00d7gap_y) where i is negative. Args: projected_structure: The Structure object with final 2D projected coordinates. domain_definitions: List of DomainTransformation objects defining the domains. The domain_id attribute is crucial. gap_x: Progressive horizontal gap between domains in pixels (last domain at origin). gap_y: Progressive vertical gap between domains in pixels (last domain at origin). arrangement: How to arrange domain groups (kept for compatibility). default_styles: Optional dictionary mapping element type names to style instances. domain_scop_ids: Optional dictionary mapping domain_id to an annotation string (e.g., SCOP ID) used for AreaAnnotation labels. domain_alignment_probabilities: Optional dictionary mapping domain_id to alignment probability (0.0-1.0) for display in annotations. Returns: A Scene object containing only the specified domain groups, laid out progressively. Raises: ValueError: If structure lacks coordinates, or domain_definitions have issues (missing IDs when needed, duplicates). TypeError: If incompatible style types are provided in default_styles. \"\"\" if ( projected_structure . coordinates is None or projected_structure . coordinates . size == 0 ): raise ValueError ( \"Input projected_structure has no coordinates.\" ) if domain_scop_ids and any ( d . domain_id is None for d in domain_definitions ): raise ValueError ( \"All domain_definitions must have a domain_id if domain_scop_ids is provided.\" ) defined_domain_ids = [ d . domain_id for d in domain_definitions if d . domain_id ] if len ( defined_domain_ids ) != len ( set ( defined_domain_ids )): raise ValueError ( \"Duplicate domain_ids found in domain_definitions.\" ) if domain_scop_ids : scop_keys = set ( domain_scop_ids . keys ()) if not scop_keys . issubset ( set ( defined_domain_ids )): missing = scop_keys - set ( defined_domain_ids ) raise ValueError ( f \"domain_scop_ids keys not in domain_ids: { missing } \" ) scene = Scene ( structure = projected_structure ) styles = default_styles or {} domain_groups : Dict [ str , SceneGroup ] = {} # Map domain_id to SceneGroup domain_ids_in_order : List [ str ] = [] # Maintain order for fixed layout domain_tf_lookup : Dict [ str , DomainTransformation ] = {} # --- 1. Create Domain Groups Only --- logger . debug ( \"Creating scene groups for defined domains...\" ) for domain_tf in domain_definitions : domain_id = domain_tf . domain_id or str ( domain_tf . domain_range ) if domain_id in domain_groups : logger . warning ( f \"Skipping duplicate domain ID ' { domain_id } '.\" ) continue domain_group = SceneGroup ( id = domain_id , transforms = GroupTransform ()) scene . add_element ( domain_group ) domain_groups [ domain_id ] = domain_group domain_ids_in_order . append ( domain_id ) domain_tf_lookup [ domain_id ] = domain_tf logger . debug ( f \"Created { len ( domain_groups ) } domain groups.\" ) if not domain_groups : logger . warning ( \"No domain groups created. Scene will be empty.\" ) return scene # Return early if no domains defined/created # --- 2. Assign Structure Elements ONLY to Domain Groups --- logger . debug ( \"Assigning structure elements to domain groups...\" ) element_map : Dict [ str , SceneGroup ] = {} # Map element ID to its parent group elements_assigned_count = 0 elements_discarded_count = 0 for _ , chain in projected_structure : for ss_element in chain . secondary_structure : ss_type = ss_element . secondary_structure_type element_info = STRUCTURE_ELEMENT_MAP . get ( ss_type ) if not element_info : elements_discarded_count += 1 continue # Skip unsupported types ElementClass , _ = element_info ss_range_set = ResidueRangeSet ([ ss_element ]) element_type_key = ss_type . name . lower () assigned_group : Optional [ SceneGroup ] = None # Find the domain this element belongs to for domain_tf in domain_definitions : if ss_element in domain_tf . domain_range : domain_id = domain_tf . domain_id or str ( domain_tf . domain_range ) assigned_group = domain_groups . get ( domain_id ) break # Assign to first matching domain # If element belongs to a defined domain, create and add it if assigned_group : try : base_style = styles . get ( element_type_key ) # Type check base style if base_style is not None and not isinstance ( base_style , BaseStructureStyle ): logger . warning ( f \"Invalid style type for ' { element_type_key } '. Using default.\" ) base_style = None viz_element = ElementClass ( residue_range_set = ss_range_set , style = base_style , # Pass style or None ) scene . add_element ( viz_element , parent_id = assigned_group . id ) element_map [ viz_element . id ] = assigned_group elements_assigned_count += 1 except Exception as e : logger . error ( f \"Error creating/assigning element { ss_element } : { e } \" , exc_info = True , ) elements_discarded_count += 1 else : # Element does not belong to any defined domain, discard it elements_discarded_count += 1 logger . debug ( f \"Assigned { elements_assigned_count } elements to domain groups. Discarded { elements_discarded_count } .\" ) # --- 3. Add Connections ONLY Within the Same Domain Group --- logger . debug ( \"Adding connections within domain groups...\" ) all_structure_elements = scene . get_sequential_structure_elements () connections_added_count = 0 connections_discarded_count = 0 for i in range ( len ( all_structure_elements ) - 1 ): element_i = all_structure_elements [ i ] element_i_plus_1 = all_structure_elements [ i + 1 ] # Check adjacency first if not element_i . is_adjacent_to ( element_i_plus_1 ): continue # Find the groups these elements belong to (if they were added) group_i = element_map . get ( element_i . id ) group_i_plus_1 = element_map . get ( element_i_plus_1 . id ) # Only add connection if both elements exist and are in the SAME group if group_i is not None and group_i is group_i_plus_1 : try : base_conn_style = styles . get ( \"connection\" ) # Type check if base_conn_style is not None and not isinstance ( base_conn_style , ConnectionStyle ): logger . warning ( \"Invalid type for 'connection' style. Using default.\" ) base_conn_style = None conn = Connection ( start_element = element_i , end_element = element_i_plus_1 , style = base_conn_style , ) logger . debug ( f \"Adding connection between { element_i . id } and { element_i_plus_1 . id } to group { group_i . id } \" ) scene . add_element ( conn , parent_id = group_i . id ) connections_added_count += 1 except Exception as e : logger . error ( f \"Failed adding connection between { element_i . id } / { element_i_plus_1 . id } : { e } \" , exc_info = True , ) connections_discarded_count += 1 # Count as discarded if creation fails else : # Connection spans groups or involves discarded elements connections_discarded_count += 1 logger . debug ( f \"Added { connections_added_count } connections within groups. Discarded { connections_discarded_count } .\" ) # --- 4. Add Domain Annotations to Respective Groups --- if domain_scop_ids : logger . debug ( \"Adding domain annotations...\" ) annotations_added_count = 0 base_area_style = styles . get ( \"area_annotation\" ) logger . debug ( f \"Base area style: { base_area_style } \" ) # Type check if base_area_style is not None and not isinstance ( base_area_style , AreaAnnotationStyle ): logger . warning ( \"Invalid type for 'area_annotation' style. Using default.\" ) base_area_style = None for domain_id , scop_id in domain_scop_ids . items (): group = domain_groups . get ( domain_id ) domain_tf = domain_tf_lookup . get ( domain_id ) if not group or not domain_tf : logger . warning ( f \"Cannot add annotation for domain ' { domain_id } ': missing group/definition.\" ) continue try : target_range_set = ResidueRangeSet ([ domain_tf . domain_range ]) # Create label with SCOP ID and alignment probability label = scop_id if ( domain_alignment_probabilities and domain_id in domain_alignment_probabilities ): probability = domain_alignment_probabilities [ domain_id ] label = ( f \" { scop_id } \\n ( { probability : .1% } )\" # e.g., \"3000622\\n(85.3%)\" ) annotation = AreaAnnotation ( id = f \" { domain_id } _area\" , residue_range_set = target_range_set , style = base_area_style , # Pass style or None label = label , ) # Add annotation as child of the specific domain group scene . add_element ( annotation , parent_id = group . id ) annotations_added_count += 1 except Exception as e : logger . error ( f \"Failed adding area annotation for domain { domain_id } : { e } \" , exc_info = True , ) logger . debug ( f \"Added { annotations_added_count } domain area annotations.\" ) # --- 5. Apply Progressive Gap Translation to Domain Groups --- # Apply incremental gap_x and gap_y translation to domains for proper separation if gap_x != 0.0 or gap_y != 0.0 : logger . debug ( f \"Applying progressive gap translation with increments: ( { gap_x } , { gap_y } )\" ) layout_applied_count = 0 # Apply reverse progressive translation - last domain stays at origin, earlier domains get positive gaps num_domains = len ( domain_ids_in_order ) for i , domain_id in enumerate ( domain_ids_in_order ): group = domain_groups . get ( domain_id ) if not group : continue # Should not happen based on checks # Calculate reverse progressive translation: last domain (i=num_domains-1) stays at (0,0) # Earlier domains get progressively larger positive translations for visual separation translate_x = ( num_domains - 1 - i ) * gap_x translate_y = ( num_domains - 1 - i ) * gap_y if group . transforms is None : group . transforms = GroupTransform () group . transforms . translate = ( translate_x , translate_y ) logger . debug ( f \"Applied progressive translation to group { domain_id } : ( { translate_x : .2f } , { translate_y : .2f } )\" ) layout_applied_count += 1 logger . debug ( f \"Applied progressive gap translations to { layout_applied_count } domain groups.\" ) else : logger . debug ( \"Keeping domains in original positions (gap_x = gap_y = 0.0).\" ) # Ensure groups have identity transforms but no translation for domain_id in domain_ids_in_order : group = domain_groups . get ( domain_id ) if group : if group . transforms is None : group . transforms = GroupTransform () group . transforms . translate = ( 0.0 , 0.0 ) # Keep in original position return scene options: show_root_heading: true","title":"Scene Utilities"},{"location":"api/scene/#scene-errors","text":"Exceptions specific to scene creation or processing.","title":"Scene Errors"},{"location":"api/scene/#flatprot.scene.errors.CircularDependencyError","text":"Bases: SceneError , ValueError Raised when an operation would create a circular parent-child relationship. Source code in src/flatprot/scene/errors.py 43 44 45 46 class CircularDependencyError ( SceneError , ValueError ): # Inherit ValueError for context \"\"\"Raised when an operation would create a circular parent-child relationship.\"\"\" pass","title":"CircularDependencyError"},{"location":"api/scene/#flatprot.scene.errors.DuplicateElementError","text":"Bases: SceneError Raised when attempting to add an element that already exists. Source code in src/flatprot/scene/errors.py 25 26 27 28 class DuplicateElementError ( SceneError ): \"\"\"Raised when attempting to add an element that already exists.\"\"\" pass","title":"DuplicateElementError"},{"location":"api/scene/#flatprot.scene.errors.ElementNotFoundError","text":"Bases: SceneError Raised when a scene element is not found, typically by ID. Source code in src/flatprot/scene/errors.py 19 20 21 22 class ElementNotFoundError ( SceneError ): \"\"\"Raised when a scene element is not found, typically by ID.\"\"\" pass","title":"ElementNotFoundError"},{"location":"api/scene/#flatprot.scene.errors.ElementTypeError","text":"Bases: SceneError , TypeError Raised when an element is not of the expected type (e.g., expecting SceneGroup). Source code in src/flatprot/scene/errors.py 37 38 39 40 class ElementTypeError ( SceneError , TypeError ): # Inherit TypeError for type context \"\"\"Raised when an element is not of the expected type (e.g., expecting SceneGroup).\"\"\" pass","title":"ElementTypeError"},{"location":"api/scene/#flatprot.scene.errors.InvalidSceneOperationError","text":"Bases: SceneError , ValueError Raised for operations that are invalid given the current element state (e.g., adding already parented element). Source code in src/flatprot/scene/errors.py 55 56 57 58 class InvalidSceneOperationError ( SceneError , ValueError ): # Inherit ValueError \"\"\"Raised for operations that are invalid given the current element state (e.g., adding already parented element).\"\"\" pass","title":"InvalidSceneOperationError"},{"location":"api/scene/#flatprot.scene.errors.ParentNotFoundError","text":"Bases: ElementNotFoundError Raised when a specified parent element ID is not found. Source code in src/flatprot/scene/errors.py 31 32 33 34 class ParentNotFoundError ( ElementNotFoundError ): # Inherits as it's a specific case \"\"\"Raised when a specified parent element ID is not found.\"\"\" pass","title":"ParentNotFoundError"},{"location":"api/scene/#flatprot.scene.errors.SceneAnnotationError","text":"Bases: SceneError Error related to scene annotations. Source code in src/flatprot/scene/errors.py 13 14 15 16 class SceneAnnotationError ( SceneError ): \"\"\"Error related to scene annotations.\"\"\" pass","title":"SceneAnnotationError"},{"location":"api/scene/#flatprot.scene.errors.SceneCreationError","text":"Bases: SceneError Raised when creation of a scene fails. Source code in src/flatprot/scene/errors.py 61 62 63 64 class SceneCreationError ( SceneError ): \"\"\"Raised when creation of a scene fails.\"\"\" pass","title":"SceneCreationError"},{"location":"api/scene/#flatprot.scene.errors.SceneError","text":"Bases: FlatProtError Base class for all errors in the scene module. Source code in src/flatprot/scene/errors.py 7 8 9 10 class SceneError ( FlatProtError ): \"\"\"Base class for all errors in the scene module.\"\"\" pass","title":"SceneError"},{"location":"api/scene/#flatprot.scene.errors.SceneGraphInconsistencyError","text":"Bases: SceneError , RuntimeError Raised when an internal inconsistency in the scene graph state is detected. Source code in src/flatprot/scene/errors.py 49 50 51 52 class SceneGraphInconsistencyError ( SceneError , RuntimeError ): # Inherit RuntimeError \"\"\"Raised when an internal inconsistency in the scene graph state is detected.\"\"\" pass","title":"SceneGraphInconsistencyError"},{"location":"api/scene/#flatprot.scene.errors.TargetResidueNotFoundError","text":"Bases: SceneError Error raised when a target residue is not found in the structure. Source code in src/flatprot/scene/errors.py 67 68 69 70 71 72 class TargetResidueNotFoundError ( SceneError ): \"\"\"Error raised when a target residue is not found in the structure.\"\"\" def __init__ ( self , structure : Structure , residue : ResidueCoordinate ): message = f \"Residue { residue } not found in structure { structure } \" super () . __init__ ( message ) options: show_root_heading: true","title":"TargetResidueNotFoundError"},{"location":"api/transformation/","text":"Transformation & Projection API This section documents functions and classes related to transforming protein structures (e.g., alignment, inertia-based) and projecting them into 2D coordinates for visualization. Transformation Matrix Defines the core class for handling 3D transformation matrices. Represents a transformation matrix. Source code in src/flatprot/transformation/transformation_matrix.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class TransformationMatrix : \"\"\"Represents a transformation matrix.\"\"\" rotation : np . ndarray translation : np . ndarray def __post_init__ ( self ): \"\"\"Validate matrix shapes.\"\"\" if self . rotation . shape != ( 3 , 3 ): raise ValueError ( \"Rotation matrix must be 3x3\" ) if self . translation . shape != ( 3 ,): raise ValueError ( \"Translation vector must have shape (3,)\" ) def before ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 \"\"\" return TransformationMatrix ( rotation = other . rotation @ self . rotation , translation = other . rotation @ self . translation + other . translation , ) def after ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 \"\"\" return TransformationMatrix ( rotation = self . rotation @ other . rotation , translation = self . rotation @ other . translation + self . translation , ) def to_array ( self ) -> np . ndarray : \"\"\"Convert TransformationMatrix to a single numpy array for storage. Returns: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector \"\"\" return np . vstack ([ self . rotation , self . translation ]) @classmethod def from_array ( cls , arr : np . ndarray ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from stored array format. Args: arr: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix instance \"\"\" if arr . shape != ( 4 , 3 ): raise ValueError ( f \"Input array must be 4x3, but got { arr . shape } \" ) # Original slicing for 4x3 array return cls ( rotation = arr [ 0 : 3 , :], translation = arr [ 3 , :]) @classmethod def from_string ( cls , s : str ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from string representation (assuming 4x3 layout).\"\"\" # Assuming the string represents a flattened 4x3 matrix arr = np . fromstring ( s , sep = \" \" ) # Adjust separator if needed if arr . size != 12 : raise ValueError ( \"String must represent 12 numbers for a 4x3 matrix\" ) arr = arr . reshape ( 4 , 3 ) return cls . from_array ( arr ) def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply the transformation matrix using the standard (R @ X) + T convention. Args: coordinates: Array of shape (N, 3) containing 3D coordinates. Returns: Array of shape (N, 3) containing transformed coordinates. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) if coordinates . size == 0 : return coordinates # Return empty array if input is empty # Standard application: Rotate around origin, then translate rotated = ( self . rotation @ coordinates . T ) . T transformed = rotated + self . translation return transformed def __eq__ ( self , other : \"TransformationMatrix\" ) -> bool : \"\"\"Check if two TransformationMatrix instances are equal.\"\"\" return np . allclose ( self . rotation , other . rotation ) and np . allclose ( self . translation , other . translation ) __eq__ ( other ) Check if two TransformationMatrix instances are equal. Source code in src/flatprot/transformation/transformation_matrix.py 106 107 108 109 110 def __eq__ ( self , other : \"TransformationMatrix\" ) -> bool : \"\"\"Check if two TransformationMatrix instances are equal.\"\"\" return np . allclose ( self . rotation , other . rotation ) and np . allclose ( self . translation , other . translation ) __post_init__ () Validate matrix shapes. Source code in src/flatprot/transformation/transformation_matrix.py 16 17 18 19 20 21 def __post_init__ ( self ): \"\"\"Validate matrix shapes.\"\"\" if self . rotation . shape != ( 3 , 3 ): raise ValueError ( \"Rotation matrix must be 3x3\" ) if self . translation . shape != ( 3 ,): raise ValueError ( \"Translation vector must have shape (3,)\" ) after ( other ) Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 Source code in src/flatprot/transformation/transformation_matrix.py 35 36 37 38 39 40 41 42 43 44 45 def after ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 \"\"\" return TransformationMatrix ( rotation = self . rotation @ other . rotation , translation = self . rotation @ other . translation + self . translation , ) apply ( coordinates ) Apply the transformation matrix using the standard (R @ X) + T convention. Parameters: coordinates ( ndarray ) \u2013 Array of shape (N, 3) containing 3D coordinates. Returns: ndarray \u2013 Array of shape (N, 3) containing transformed coordinates. Source code in src/flatprot/transformation/transformation_matrix.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply the transformation matrix using the standard (R @ X) + T convention. Args: coordinates: Array of shape (N, 3) containing 3D coordinates. Returns: Array of shape (N, 3) containing transformed coordinates. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) if coordinates . size == 0 : return coordinates # Return empty array if input is empty # Standard application: Rotate around origin, then translate rotated = ( self . rotation @ coordinates . T ) . T transformed = rotated + self . translation return transformed before ( other ) Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 Source code in src/flatprot/transformation/transformation_matrix.py 23 24 25 26 27 28 29 30 31 32 33 def before ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 \"\"\" return TransformationMatrix ( rotation = other . rotation @ self . rotation , translation = other . rotation @ self . translation + other . translation , ) from_array ( arr ) classmethod Create TransformationMatrix from stored array format. Parameters: arr ( ndarray ) \u2013 Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix \u2013 TransformationMatrix instance Source code in src/flatprot/transformation/transformation_matrix.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @classmethod def from_array ( cls , arr : np . ndarray ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from stored array format. Args: arr: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix instance \"\"\" if arr . shape != ( 4 , 3 ): raise ValueError ( f \"Input array must be 4x3, but got { arr . shape } \" ) # Original slicing for 4x3 array return cls ( rotation = arr [ 0 : 3 , :], translation = arr [ 3 , :]) from_string ( s ) classmethod Create TransformationMatrix from string representation (assuming 4x3 layout). Source code in src/flatprot/transformation/transformation_matrix.py 72 73 74 75 76 77 78 79 80 @classmethod def from_string ( cls , s : str ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from string representation (assuming 4x3 layout).\"\"\" # Assuming the string represents a flattened 4x3 matrix arr = np . fromstring ( s , sep = \" \" ) # Adjust separator if needed if arr . size != 12 : raise ValueError ( \"String must represent 12 numbers for a 4x3 matrix\" ) arr = arr . reshape ( 4 , 3 ) return cls . from_array ( arr ) to_array () Convert TransformationMatrix to a single numpy array for storage. Returns: ndarray \u2013 Array of shape (4, 3) where first 3 rows are rotation matrix ndarray \u2013 and last row is translation vector Source code in src/flatprot/transformation/transformation_matrix.py 47 48 49 50 51 52 53 54 def to_array ( self ) -> np . ndarray : \"\"\"Convert TransformationMatrix to a single numpy array for storage. Returns: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector \"\"\" return np . vstack ([ self . rotation , self . translation ]) options: show_root_heading: true members_order: source Inertia-Based Transformation Classes and functions for calculating and applying transformations based on the principal axes of inertia. These transformations are often used for aligning protein structures in a way that preserves their overall shape and orientation. Commonly these are implemented in orientation features of molecular visualization software. Calculate transformation matrix for optimal molecular orientation, returning components compatible with standard (R @ X) + T application. The transformation aligns the principal axes with the coordinate axes and moves the center of mass/geometry C to the origin. This function calculates R_inertia and C, then returns R_standard = R_inertia and T_standard = -(R_inertia @ C). Parameters: coordinates ( ndarray ) \u2013 Nx3 array of atomic coordinates weights ( ndarray ) \u2013 N-length array of weights for each coordinate Returns: TransformationMatrix \u2013 TransformationMatrix with rotation = R_inertia and translation = -(R_inertia @ C) Source code in src/flatprot/transformation/inertia_transformation.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def calculate_inertia_transformation_matrix ( coordinates : np . ndarray , weights : np . ndarray ) -> TransformationMatrix : \"\"\" Calculate transformation matrix for optimal molecular orientation, returning components compatible with standard (R @ X) + T application. The transformation aligns the principal axes with the coordinate axes and moves the center of mass/geometry C to the origin. This function calculates R_inertia and C, then returns R_standard = R_inertia and T_standard = -(R_inertia @ C). Args: coordinates: Nx3 array of atomic coordinates weights: N-length array of weights for each coordinate Returns: TransformationMatrix with rotation = R_inertia and translation = -(R_inertia @ C) \"\"\" # Calculate center (weighted or geometric) C if np . allclose ( weights , weights [ 0 ]): # All weights equal -> geometric center center_C = np . mean ( coordinates , axis = 0 ) else : # Weighted center of mass total_weight = np . sum ( weights ) if total_weight == 0 : center_C = np . mean ( coordinates , axis = 0 ) # Fallback for zero weights else : center_C = ( np . sum ( coordinates * weights [:, np . newaxis ], axis = 0 ) / total_weight ) # Center coordinates for inertia tensor calculation centered_coords = coordinates - center_C # Principal axis method using inertia tensor inertia_tensor = np . zeros (( 3 , 3 )) for coord , weight in zip ( centered_coords , weights ): r_squared = np . sum ( coord * coord ) inertia_tensor += weight * ( r_squared * np . eye ( 3 ) - np . outer ( coord , coord )) _ , eigenvectors = np . linalg . eigh ( inertia_tensor ) # Rotation matrix (R_inertia) is composed of the eigenvectors rotation_R_inertia = eigenvectors # Ensure a right-handed coordinate system if np . linalg . det ( rotation_R_inertia ) < 0 : rotation_R_inertia [:, 2 ] *= - 1 # Calculate the standard translation T = -(R_inertia @ C) # Ensure C is treated as a column vector for matmul center_C_col = center_C . reshape ( - 1 , 1 ) translation_T_standard_col = - ( rotation_R_inertia @ center_C_col ) translation_T_standard = translation_T_standard_col . flatten () # Back to (3,) # Return the matrix with components for standard application return TransformationMatrix ( rotation = rotation_R_inertia , translation = translation_T_standard ) options: show_root_heading: true Bases: BaseTransformationParameters Parameters for inertia-based projection calculation. Source code in src/flatprot/transformation/inertia_transformation.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @dataclass class InertiaTransformationParameters ( BaseTransformationParameters ): \"\"\"Parameters for inertia-based projection calculation.\"\"\" residue_weights : dict [ ResidueType , float ] # Maps residue type to weight use_weights : bool = False @classmethod def default ( cls ) -> \"InertiaTransformationParameters\" : \"\"\"Creates default parameters using standard amino acid weights.\"\"\" return cls ( residue_weights = { ResidueType . ALA : 89.1 , ResidueType . ARG : 174.2 , ResidueType . ASN : 132.1 , ResidueType . ASP : 133.1 , ResidueType . CYS : 121.2 , ResidueType . GLN : 146.2 , ResidueType . GLU : 147.1 , ResidueType . GLY : 75.1 , ResidueType . HIS : 155.2 , ResidueType . ILE : 131.2 , ResidueType . LEU : 131.2 , ResidueType . LYS : 146.2 , ResidueType . MET : 149.2 , ResidueType . PHE : 165.2 , ResidueType . PRO : 115.1 , ResidueType . SER : 105.1 , ResidueType . THR : 119.1 , ResidueType . TRP : 204.2 , ResidueType . TYR : 181.2 , ResidueType . VAL : 117.1 , } ) default () classmethod Creates default parameters using standard amino acid weights. Source code in src/flatprot/transformation/inertia_transformation.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @classmethod def default ( cls ) -> \"InertiaTransformationParameters\" : \"\"\"Creates default parameters using standard amino acid weights.\"\"\" return cls ( residue_weights = { ResidueType . ALA : 89.1 , ResidueType . ARG : 174.2 , ResidueType . ASN : 132.1 , ResidueType . ASP : 133.1 , ResidueType . CYS : 121.2 , ResidueType . GLN : 146.2 , ResidueType . GLU : 147.1 , ResidueType . GLY : 75.1 , ResidueType . HIS : 155.2 , ResidueType . ILE : 131.2 , ResidueType . LEU : 131.2 , ResidueType . LYS : 146.2 , ResidueType . MET : 149.2 , ResidueType . PHE : 165.2 , ResidueType . PRO : 115.1 , ResidueType . SER : 105.1 , ResidueType . THR : 119.1 , ResidueType . TRP : 204.2 , ResidueType . TYR : 181.2 , ResidueType . VAL : 117.1 , } ) options: show_root_heading: true members_order: source Bases: BaseTransformation [ InertiaTransformationParameters , InertiaTransformationArguments ] Transforms using inertia-based calculation with residue weights. Source code in src/flatprot/transformation/inertia_transformation.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class InertiaTransformer ( BaseTransformation [ InertiaTransformationParameters , InertiaTransformationArguments ] ): \"\"\"Transforms using inertia-based calculation with residue weights.\"\"\" def __init__ ( self , parameters : InertiaTransformationParameters ): super () . __init__ ( parameters = parameters ) def _calculate_transformation_matrix ( self , coordinates : np . ndarray , parameters : InertiaTransformationParameters , ) -> TransformationMatrix : \"\"\"Calculate transformation matrix for given coordinates.\"\"\" if not self . parameters . use_weights : weights = np . ones ( len ( coordinates )) else : # Map residue types to weights using parameters.residue_weights weights = np . array ( [ self . parameters . residue_weights . get ( res , 1.0 ) for res in parameters . residues ] ) return calculate_inertia_transformation_matrix ( coordinates , weights ) options: show_root_heading: true members_order: source Matrix-Based Transformation Classes for applying a pre-defined transformation matrix. Bases: BaseTransformationParameters Parameters for matrix-based transformation. Source code in src/flatprot/transformation/matrix_transformation.py 14 15 16 17 18 @dataclass class MatrixTransformParameters ( BaseTransformationParameters ): \"\"\"Parameters for matrix-based transformation.\"\"\" matrix : TransformationMatrix options: show_root_heading: true members_order: source Bases: BaseTransformation [ MatrixTransformParameters , None] Projects coordinates using a provided rotation matrix and translation vector. This projector applies a fixed projection matrix provided at initialization. Source code in src/flatprot/transformation/matrix_transformation.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MatrixTransformer ( BaseTransformation [ MatrixTransformParameters , None ]): \"\"\"Projects coordinates using a provided rotation matrix and translation vector. This projector applies a fixed projection matrix provided at initialization. \"\"\" def __init__ ( self , parameters : MatrixTransformParameters ): \"\"\"Initialize with a fixed transformation matrix. Args: projection_matrix: The ProjectionMatrix to use for all projections \"\"\" super () . __init__ ( parameters ) self . _cached_transformation = parameters . matrix def _calculate_transformation_matrix ( self , coordinates : np . ndarray , ) -> TransformationMatrix : \"\"\"Return the fixed projection matrix. Since this projector uses a fixed projection matrix provided at initialization, this method simply returns the cached transformation. \"\"\" return self . _cached_transformation __init__ ( parameters ) Initialize with a fixed transformation matrix. Parameters: projection_matrix \u2013 The ProjectionMatrix to use for all projections Source code in src/flatprot/transformation/matrix_transformation.py 27 28 29 30 31 32 33 34 def __init__ ( self , parameters : MatrixTransformParameters ): \"\"\"Initialize with a fixed transformation matrix. Args: projection_matrix: The ProjectionMatrix to use for all projections \"\"\" super () . __init__ ( parameters ) self . _cached_transformation = parameters . matrix options: show_root_heading: true members_order: source Structure Transformation Utilities Helper functions (often used internally by CLI commands) for applying transformations to flatprot.core.Structure objects. Transforms a Structure using its principal axes of inertia. Parameters: structure ( Structure ) \u2013 The protein structure to transform. custom_config_params ( Optional [ InertiaTransformationParameters ] , default: None ) \u2013 Optional InertiaTransformationParameters to override defaults (e.g., custom residue weights or disabling weights) passed to the InertiaTransformer's initialization. Returns: Structure \u2013 A new Structure object with transformed coordinates oriented along principal axes. Raises: TransformationError \u2013 If the structure is unsuitable for inertia calculation (e.g., lacks coordinates or residues), or if the transformation process fails mathematically. ValueError \u2013 If the structure lacks coordinates or residues required for the process. Source code in src/flatprot/utils/structure_utils.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def transform_structure_with_inertia ( structure : Structure , custom_config_params : Optional [ InertiaTransformationParameters ] = None , ) -> Structure : \"\"\"Transforms a Structure using its principal axes of inertia. Args: structure: The protein structure to transform. custom_config_params: Optional InertiaTransformationParameters to override defaults (e.g., custom residue weights or disabling weights) passed to the InertiaTransformer's initialization. Returns: A new Structure object with transformed coordinates oriented along principal axes. Raises: TransformationError: If the structure is unsuitable for inertia calculation (e.g., lacks coordinates or residues), or if the transformation process fails mathematically. ValueError: If the structure lacks coordinates or residues required for the process. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates for inertia transformation.\" ) if not hasattr ( structure , \"residues\" ) or not structure . residues : raise ValueError ( \"Structure has no residues for inertia transformation.\" ) if structure . coordinates . size == 0 : logger . warning ( \"Structure coordinates are empty, returning original structure.\" ) return structure # Return unchanged structure try : # Use provided config params or create default ones for the transformer's __init__ # InertiaTransformationParameters likely holds config like residue_weights dict inertia_config_parameters = ( custom_config_params or InertiaTransformationParameters . default () ) # Instantiate the transformer with its configuration parameters transformer = InertiaTransformer ( parameters = inertia_config_parameters ) logger . info ( \"Applying inertia transformation...\" ) # Prepare the runtime arguments needed specifically for the transform call # InertiaTransformArguments (aliased from InertiaTransformationParameters in inertia.py) # likely holds data specific to this call, like the list of residues. transform_arguments = InertiaTransformationArguments ( residues = structure . residues ) # Wrap the transformer's transform method def transform_func ( coords : np . ndarray ) -> np . ndarray : # Pass coordinates and the required runtime arguments object return transformer . transform ( coords , arguments = transform_arguments ) new_structure = structure . apply_vectorized_transformation ( transform_func ) logger . info ( \"Inertia transformation complete.\" ) return new_structure except Exception as e : logger . error ( f \"Error during inertia transformation: { str ( e ) } \" , exc_info = True ) # Re-raise as TransformationError if not already one if isinstance ( e , TransformationError ): raise raise TransformationError ( f \"Inertia transformation failed: { str ( e ) } \" ) from e options: show_root_heading: true Transforms a Structure using a matrix (loaded from path or identity). Parameters: structure ( Structure ) \u2013 The protein structure to transform. matrix_path ( Optional [ Path ] , default: None ) \u2013 Optional path to a numpy matrix file (.npy) for transformation. If None or loading fails gracefully, the identity matrix is used. Returns: Structure \u2013 A new Structure object with transformed coordinates. Raises: TransformationError \u2013 If the transformation process fails unexpectedly (e.g., matrix loading error, issues during transformation math). ValueError \u2013 If the structure lacks coordinates. Source code in src/flatprot/utils/structure_utils.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def transform_structure_with_matrix ( structure : Structure , matrix_path : Optional [ Path ] = None ) -> Structure : \"\"\"Transforms a Structure using a matrix (loaded from path or identity). Args: structure: The protein structure to transform. matrix_path: Optional path to a numpy matrix file (.npy) for transformation. If None or loading fails gracefully, the identity matrix is used. Returns: A new Structure object with transformed coordinates. Raises: TransformationError: If the transformation process fails unexpectedly (e.g., matrix loading error, issues during transformation math). ValueError: If the structure lacks coordinates. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to transform.\" ) if structure . coordinates . size == 0 : logger . warning ( \"Structure coordinates are empty, returning original structure.\" ) return structure # Return unchanged structure if no coords try : transformation_matrix = _load_transformation_matrix ( matrix_path ) # Correctly instantiate MatrixTransformer using its parameters class transformer_params = MatrixTransformParameters ( matrix = transformation_matrix ) transformer = MatrixTransformer ( parameters = transformer_params ) logger . info ( f \"Applying matrix transformation (source: { matrix_path or 'Identity' } )...\" ) new_structure = structure . apply_vectorized_transformation ( lambda coords : transformer . transform ( coords , arguments = None ) ) logger . info ( \"Matrix transformation complete.\" ) return new_structure except Exception as e : # Catch potential errors from apply_vectorized_transformation or transform_func logger . error ( f \"Error during matrix transformation: { str ( e ) } \" , exc_info = True ) # Re-raise as TransformationError if not already (e.g. ValueError from shape mismatch) if isinstance ( e , TransformationError ): raise raise TransformationError ( f \"Matrix transformation failed: { str ( e ) } \" ) from e options: show_root_heading: true Orthographic Projection Function for projecting a transformed 3D structure onto a 2D canvas. Projects the coordinates of a Structure orthographically, returning a new Structure. Assumes the input structure's coordinates are already appropriately transformed (e.g., centered and oriented via inertia or matrix transformation). The coordinates of the returned Structure will be the projected (X, Y, Depth) values. Parameters: structure ( Structure ) \u2013 The Structure object whose coordinates are to be projected. Assumes structure.coordinates holds the transformed 3D points. width ( int ) \u2013 The width of the target canvas in pixels. height ( int ) \u2013 The height of the target canvas in pixels. padding_x ( float , default: 0.05 ) \u2013 Horizontal padding as a fraction of the width (0 to <0.5). padding_y ( float , default: 0.05 ) \u2013 Vertical padding as a fraction of the height (0 to <0.5). maintain_aspect_ratio ( bool , default: True ) \u2013 Whether to scale uniformly to fit while preserving the structure's shape, or stretch to fill padding box. center_projection ( bool , default: True ) \u2013 Whether to center the projected structure within the canvas. view_direction ( Optional [ ndarray ] , default: None ) \u2013 Optional (3,) numpy array for the view direction (camera looking along -view_direction). Defaults to [0, 0, 1] if None. up_vector ( Optional [ ndarray ] , default: None ) \u2013 Optional (3,) numpy array for the initial up vector. Defaults to [0, 1, 0] if None. disable_scaling ( bool , default: False ) \u2013 If True, disables automatic scaling to fit canvas, useful for overlay comparisons where consistent scales are needed across different structures. Returns: Structure \u2013 A new Structure object where the coordinates represent the projected data: Structure \u2013 Column 0: X canvas coordinate (float) Structure \u2013 Column 1: Y canvas coordinate (float) Structure \u2013 Column 2: Depth value (float, representing scaled Z for visibility/layering) Raises: ProjectionError \u2013 If the projection process fails (e.g., mathematical error, invalid parameters). ValueError \u2013 If the structure lacks coordinates or if vector inputs are invalid. Source code in src/flatprot/utils/structure_utils.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def project_structure_orthographically ( structure : Structure , width : int , height : int , padding_x : float = 0.05 , padding_y : float = 0.05 , maintain_aspect_ratio : bool = True , center_projection : bool = True , view_direction : Optional [ np . ndarray ] = None , up_vector : Optional [ np . ndarray ] = None , disable_scaling : bool = False , ) -> Structure : \"\"\"Projects the coordinates of a Structure orthographically, returning a new Structure. Assumes the input structure's coordinates are already appropriately transformed (e.g., centered and oriented via inertia or matrix transformation). The coordinates of the returned Structure will be the projected (X, Y, Depth) values. Args: structure: The Structure object whose coordinates are to be projected. Assumes structure.coordinates holds the transformed 3D points. width: The width of the target canvas in pixels. height: The height of the target canvas in pixels. padding_x: Horizontal padding as a fraction of the width (0 to <0.5). padding_y: Vertical padding as a fraction of the height (0 to <0.5). maintain_aspect_ratio: Whether to scale uniformly to fit while preserving the structure's shape, or stretch to fill padding box. center_projection: Whether to center the projected structure within the canvas. view_direction: Optional (3,) numpy array for the view direction (camera looking along -view_direction). Defaults to [0, 0, 1] if None. up_vector: Optional (3,) numpy array for the initial up vector. Defaults to [0, 1, 0] if None. disable_scaling: If True, disables automatic scaling to fit canvas, useful for overlay comparisons where consistent scales are needed across different structures. Returns: A new Structure object where the coordinates represent the projected data: - Column 0: X canvas coordinate (float) - Column 1: Y canvas coordinate (float) - Column 2: Depth value (float, representing scaled Z for visibility/layering) Raises: ProjectionError: If the projection process fails (e.g., mathematical error, invalid parameters). ValueError: If the structure lacks coordinates or if vector inputs are invalid. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to project.\" ) coords_to_project = structure . coordinates if coords_to_project . size == 0 : logger . warning ( \"Structure coordinates are empty. Returning original structure.\" ) # Return original structure if no coordinates to project return structure try : projector = OrthographicProjection () # Construct parameters for the projection param_kwargs = { \"width\" : width , \"height\" : height , \"padding_x\" : padding_x , \"padding_y\" : padding_y , \"maintain_aspect_ratio\" : maintain_aspect_ratio , \"canvas_alignment\" : \"center\" if center_projection else \"top_left\" , \"disable_scaling\" : disable_scaling , } if view_direction is not None : param_kwargs [ \"view_direction\" ] = view_direction if up_vector is not None : param_kwargs [ \"up_vector\" ] = up_vector projection_params = OrthographicProjectionParameters ( ** param_kwargs ) # Define the transformation function that performs the projection def projection_func ( coords : np . ndarray ) -> np . ndarray : logger . info ( \"Performing orthographic projection internally...\" ) projected = projector . project ( coords , projection_params ) logger . info ( \"Internal projection complete.\" ) return projected . astype ( np . float32 ) # Ensure float32 # Use apply_vectorized_transformation to create a new structure # with the projected coordinates logger . info ( \"Applying projection transformation to structure...\" ) projected_structure = structure . apply_vectorized_transformation ( projection_func ) logger . info ( \"Projection transformation applied.\" ) return projected_structure except Exception as e : logger . error ( f \"Error during orthographic projection: { str ( e ) } \" , exc_info = True ) # Re-raise specific errors or wrap in ProjectionError if isinstance ( e , ( ProjectionError , ValueError )): raise raise ProjectionError ( f \"Orthographic projection failed: { str ( e ) } \" ) from e options: show_root_heading: true Domain Transformation Utilities Classes and functions specifically for handling domain-based transformations. Encapsulates a transformation matrix applied to a specific protein domain. Attributes: domain_range ( ResidueRange ) \u2013 The specific residue range defining the domain. transformation_matrix ( TransformationMatrix ) \u2013 The matrix used to transform this domain. domain_id ( Optional [ str ] ) \u2013 An optional identifier for the domain (e.g., 'Domain1', 'N-term'). scop_id ( Optional [ str ] ) \u2013 An optional SCOP family identifier from alignment (e.g., '3000114'). alignment_probability ( Optional [ float ] ) \u2013 The alignment probability/quality score (0.0-1.0). Source code in src/flatprot/utils/domain_utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class DomainTransformation : \"\"\" Encapsulates a transformation matrix applied to a specific protein domain. Attributes: domain_range: The specific residue range defining the domain. transformation_matrix: The matrix used to transform this domain. domain_id: An optional identifier for the domain (e.g., 'Domain1', 'N-term'). scop_id: An optional SCOP family identifier from alignment (e.g., '3000114'). alignment_probability: The alignment probability/quality score (0.0-1.0). \"\"\" domain_range : ResidueRange transformation_matrix : TransformationMatrix domain_id : Optional [ str ] = None scop_id : Optional [ str ] = None alignment_probability : Optional [ float ] = None def __post_init__ ( self ): \"\"\"Validate inputs.\"\"\" if not isinstance ( self . domain_range , ResidueRange ): raise TypeError ( \"domain_range must be a ResidueRange object.\" ) if not isinstance ( self . transformation_matrix , TransformationMatrix ): raise TypeError ( \"transformation_matrix must be a TransformationMatrix object.\" ) if self . domain_id is not None and not isinstance ( self . domain_id , str ): raise TypeError ( \"domain_id must be a string if provided.\" ) if self . scop_id is not None and not isinstance ( self . scop_id , str ): raise TypeError ( \"scop_id must be a string if provided.\" ) def __repr__ ( self ) -> str : \"\"\"Provide a concise representation.\"\"\" name = f \" ' { self . domain_id } '\" if self . domain_id else \"\" return f \"<DomainTransformation { name } range= { self . domain_range } >\" __post_init__ () Validate inputs. Source code in src/flatprot/utils/domain_utils.py 53 54 55 56 57 58 59 60 61 62 63 64 def __post_init__ ( self ): \"\"\"Validate inputs.\"\"\" if not isinstance ( self . domain_range , ResidueRange ): raise TypeError ( \"domain_range must be a ResidueRange object.\" ) if not isinstance ( self . transformation_matrix , TransformationMatrix ): raise TypeError ( \"transformation_matrix must be a TransformationMatrix object.\" ) if self . domain_id is not None and not isinstance ( self . domain_id , str ): raise TypeError ( \"domain_id must be a string if provided.\" ) if self . scop_id is not None and not isinstance ( self . scop_id , str ): raise TypeError ( \"scop_id must be a string if provided.\" ) __repr__ () Provide a concise representation. Source code in src/flatprot/utils/domain_utils.py 66 67 68 69 def __repr__ ( self ) -> str : \"\"\"Provide a concise representation.\"\"\" name = f \" ' { self . domain_id } '\" if self . domain_id else \"\" return f \"<DomainTransformation { name } range= { self . domain_range } >\" options: show_root_heading: true members_order: source Applies specific transformation matrices to defined domains around their centers. Each domain is rotated around its geometric center, preserving its position within the global structure while optimizing its orientation for visualization. Uses boolean masks to identify coordinates for each domain. Creates a new Structure object with transformed 3D coordinates. The original structure remains unchanged. Parameters: structure ( Structure ) \u2013 The original Structure object. domain_transforms ( List [ DomainTransformation ] ) \u2013 An ordered list of DomainTransformation objects. Rotations are applied around each domain's center. Returns: Structure \u2013 A new Structure object with coordinates transformed domain-specifically. Raises: TransformationError \u2013 If matrix application fails. ValueError \u2013 If structure lacks coordinates or if coordinates are not 3D. Source code in src/flatprot/utils/domain_utils.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def apply_domain_transformations_masked ( structure : Structure , domain_transforms : List [ DomainTransformation ], ) -> Structure : \"\"\" Applies specific transformation matrices to defined domains around their centers. Each domain is rotated around its geometric center, preserving its position within the global structure while optimizing its orientation for visualization. Uses boolean masks to identify coordinates for each domain. Creates a new Structure object with transformed 3D coordinates. The original structure remains unchanged. Args: structure: The original Structure object. domain_transforms: An ordered list of DomainTransformation objects. Rotations are applied around each domain's center. Returns: A new Structure object with coordinates transformed domain-specifically. Raises: TransformationError: If matrix application fails. ValueError: If structure lacks coordinates or if coordinates are not 3D. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to transform.\" ) if structure . coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Expected 3D coordinates, but got shape { structure . coordinates . shape } \" ) original_coords = structure . coordinates num_atoms = original_coords . shape [ 0 ] # 1. Create Transformation Masks (one per domain) domain_masks : List [ np . ndarray ] = [ np . zeros ( num_atoms , dtype = bool ) for _ in domain_transforms ] # 2. & 3. Iterate through structure coords and populate masks for chain in structure . values (): for residue in chain : for domain_idx , domain_tf in enumerate ( domain_transforms ): if residue in domain_tf . domain_range : if residue . coordinate_index < domain_masks [ domain_idx ] . shape [ 0 ]: domain_masks [ domain_idx ][ residue . coordinate_index ] = True transformed_coords = original_coords . copy () for mask , domain_tf in zip ( domain_masks , domain_transforms ): if not np . any ( mask ): logger . warning ( f \"No coordinates found for domain { domain_tf . domain_range } . Skipping transformation.\" ) continue domain_id_str = f \" ' { domain_tf . domain_id } '\" if domain_tf . domain_id else \"\" logger . debug ( f \"Applying centered transformation for domain { domain_id_str } { domain_tf . domain_range } (affecting { np . sum ( mask ) } coordinates)...\" ) try : # Calculate domain center domain_center = calculate_domain_center ( structure , domain_tf . domain_range ) # Create centered transformation using only rotation from domain_tf # This rotates the domain around its center, preserving its position rotation = domain_tf . transformation_matrix . rotation centered_matrix = create_centered_transformation ( rotation , domain_center ) # Apply transformation to the *original* coordinates selected by the mask coords_subset = original_coords [ mask , :] transformed_subset = centered_matrix . apply ( coords_subset ) if transformed_subset . shape != coords_subset . shape : raise TransformationError ( f \"Transformation resulted in unexpected shape change for domain { domain_tf . domain_range } . \" f \"Input shape: { coords_subset . shape } , Output shape: { transformed_subset . shape } \" ) transformed_coords [ mask , :] = transformed_subset logger . info ( f \"Applied centered rotation for domain { domain_id_str } { domain_tf . domain_range } \" f \"around center { domain_center } \" ) except Exception as e : raise TransformationError ( f \"Failed to apply centered transformation for domain { domain_tf . domain_range } : { e } \" ) from e # Create a new structure object with the same topology but new coordinates new_structure = structure . with_coordinates ( transformed_coords ) return new_structure options: show_root_heading: true","title":"Transformation & Projection"},{"location":"api/transformation/#transformation-projection-api","text":"This section documents functions and classes related to transforming protein structures (e.g., alignment, inertia-based) and projecting them into 2D coordinates for visualization.","title":"Transformation &amp; Projection API"},{"location":"api/transformation/#transformation-matrix","text":"Defines the core class for handling 3D transformation matrices. Represents a transformation matrix. Source code in src/flatprot/transformation/transformation_matrix.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class TransformationMatrix : \"\"\"Represents a transformation matrix.\"\"\" rotation : np . ndarray translation : np . ndarray def __post_init__ ( self ): \"\"\"Validate matrix shapes.\"\"\" if self . rotation . shape != ( 3 , 3 ): raise ValueError ( \"Rotation matrix must be 3x3\" ) if self . translation . shape != ( 3 ,): raise ValueError ( \"Translation vector must have shape (3,)\" ) def before ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 \"\"\" return TransformationMatrix ( rotation = other . rotation @ self . rotation , translation = other . rotation @ self . translation + other . translation , ) def after ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 \"\"\" return TransformationMatrix ( rotation = self . rotation @ other . rotation , translation = self . rotation @ other . translation + self . translation , ) def to_array ( self ) -> np . ndarray : \"\"\"Convert TransformationMatrix to a single numpy array for storage. Returns: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector \"\"\" return np . vstack ([ self . rotation , self . translation ]) @classmethod def from_array ( cls , arr : np . ndarray ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from stored array format. Args: arr: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix instance \"\"\" if arr . shape != ( 4 , 3 ): raise ValueError ( f \"Input array must be 4x3, but got { arr . shape } \" ) # Original slicing for 4x3 array return cls ( rotation = arr [ 0 : 3 , :], translation = arr [ 3 , :]) @classmethod def from_string ( cls , s : str ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from string representation (assuming 4x3 layout).\"\"\" # Assuming the string represents a flattened 4x3 matrix arr = np . fromstring ( s , sep = \" \" ) # Adjust separator if needed if arr . size != 12 : raise ValueError ( \"String must represent 12 numbers for a 4x3 matrix\" ) arr = arr . reshape ( 4 , 3 ) return cls . from_array ( arr ) def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply the transformation matrix using the standard (R @ X) + T convention. Args: coordinates: Array of shape (N, 3) containing 3D coordinates. Returns: Array of shape (N, 3) containing transformed coordinates. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) if coordinates . size == 0 : return coordinates # Return empty array if input is empty # Standard application: Rotate around origin, then translate rotated = ( self . rotation @ coordinates . T ) . T transformed = rotated + self . translation return transformed def __eq__ ( self , other : \"TransformationMatrix\" ) -> bool : \"\"\"Check if two TransformationMatrix instances are equal.\"\"\" return np . allclose ( self . rotation , other . rotation ) and np . allclose ( self . translation , other . translation )","title":"Transformation Matrix"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.__eq__","text":"Check if two TransformationMatrix instances are equal. Source code in src/flatprot/transformation/transformation_matrix.py 106 107 108 109 110 def __eq__ ( self , other : \"TransformationMatrix\" ) -> bool : \"\"\"Check if two TransformationMatrix instances are equal.\"\"\" return np . allclose ( self . rotation , other . rotation ) and np . allclose ( self . translation , other . translation )","title":"__eq__"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.__post_init__","text":"Validate matrix shapes. Source code in src/flatprot/transformation/transformation_matrix.py 16 17 18 19 20 21 def __post_init__ ( self ): \"\"\"Validate matrix shapes.\"\"\" if self . rotation . shape != ( 3 , 3 ): raise ValueError ( \"Rotation matrix must be 3x3\" ) if self . translation . shape != ( 3 ,): raise ValueError ( \"Translation vector must have shape (3,)\" )","title":"__post_init__"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.after","text":"Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 Source code in src/flatprot/transformation/transformation_matrix.py 35 36 37 38 39 40 41 42 43 44 45 def after ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying other, then self. The combined transformation T = T1 \u2218 T2 is: rotation = R1 @ R2 translation = R1 @ t2 + t1 \"\"\" return TransformationMatrix ( rotation = self . rotation @ other . rotation , translation = self . rotation @ other . translation + self . translation , )","title":"after"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.apply","text":"Apply the transformation matrix using the standard (R @ X) + T convention. Parameters: coordinates ( ndarray ) \u2013 Array of shape (N, 3) containing 3D coordinates. Returns: ndarray \u2013 Array of shape (N, 3) containing transformed coordinates. Source code in src/flatprot/transformation/transformation_matrix.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def apply ( self , coordinates : np . ndarray ) -> np . ndarray : \"\"\" Apply the transformation matrix using the standard (R @ X) + T convention. Args: coordinates: Array of shape (N, 3) containing 3D coordinates. Returns: Array of shape (N, 3) containing transformed coordinates. \"\"\" if not isinstance ( coordinates , np . ndarray ): raise TypeError ( \"Input coordinates must be a numpy array.\" ) if coordinates . ndim != 2 or coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Input coordinates must have shape (N, 3), got { coordinates . shape } \" ) if coordinates . size == 0 : return coordinates # Return empty array if input is empty # Standard application: Rotate around origin, then translate rotated = ( self . rotation @ coordinates . T ) . T transformed = rotated + self . translation return transformed","title":"apply"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.before","text":"Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 Source code in src/flatprot/transformation/transformation_matrix.py 23 24 25 26 27 28 29 30 31 32 33 def before ( self , other : \"TransformationMatrix\" ) -> \"TransformationMatrix\" : \"\"\"Combine two transformation matrices by first applying self, then other. The combined transformation T = T2 \u2218 T1 is: rotation = R2 @ R1 translation = R2 @ t1 + t2 \"\"\" return TransformationMatrix ( rotation = other . rotation @ self . rotation , translation = other . rotation @ self . translation + other . translation , )","title":"before"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.from_array","text":"Create TransformationMatrix from stored array format. Parameters: arr ( ndarray ) \u2013 Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix \u2013 TransformationMatrix instance Source code in src/flatprot/transformation/transformation_matrix.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @classmethod def from_array ( cls , arr : np . ndarray ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from stored array format. Args: arr: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector Returns: TransformationMatrix instance \"\"\" if arr . shape != ( 4 , 3 ): raise ValueError ( f \"Input array must be 4x3, but got { arr . shape } \" ) # Original slicing for 4x3 array return cls ( rotation = arr [ 0 : 3 , :], translation = arr [ 3 , :])","title":"from_array"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.from_string","text":"Create TransformationMatrix from string representation (assuming 4x3 layout). Source code in src/flatprot/transformation/transformation_matrix.py 72 73 74 75 76 77 78 79 80 @classmethod def from_string ( cls , s : str ) -> \"TransformationMatrix\" : \"\"\"Create TransformationMatrix from string representation (assuming 4x3 layout).\"\"\" # Assuming the string represents a flattened 4x3 matrix arr = np . fromstring ( s , sep = \" \" ) # Adjust separator if needed if arr . size != 12 : raise ValueError ( \"String must represent 12 numbers for a 4x3 matrix\" ) arr = arr . reshape ( 4 , 3 ) return cls . from_array ( arr )","title":"from_string"},{"location":"api/transformation/#flatprot.transformation.TransformationMatrix.to_array","text":"Convert TransformationMatrix to a single numpy array for storage. Returns: ndarray \u2013 Array of shape (4, 3) where first 3 rows are rotation matrix ndarray \u2013 and last row is translation vector Source code in src/flatprot/transformation/transformation_matrix.py 47 48 49 50 51 52 53 54 def to_array ( self ) -> np . ndarray : \"\"\"Convert TransformationMatrix to a single numpy array for storage. Returns: Array of shape (4, 3) where first 3 rows are rotation matrix and last row is translation vector \"\"\" return np . vstack ([ self . rotation , self . translation ]) options: show_root_heading: true members_order: source","title":"to_array"},{"location":"api/transformation/#inertia-based-transformation","text":"Classes and functions for calculating and applying transformations based on the principal axes of inertia. These transformations are often used for aligning protein structures in a way that preserves their overall shape and orientation. Commonly these are implemented in orientation features of molecular visualization software. Calculate transformation matrix for optimal molecular orientation, returning components compatible with standard (R @ X) + T application. The transformation aligns the principal axes with the coordinate axes and moves the center of mass/geometry C to the origin. This function calculates R_inertia and C, then returns R_standard = R_inertia and T_standard = -(R_inertia @ C). Parameters: coordinates ( ndarray ) \u2013 Nx3 array of atomic coordinates weights ( ndarray ) \u2013 N-length array of weights for each coordinate Returns: TransformationMatrix \u2013 TransformationMatrix with rotation = R_inertia and translation = -(R_inertia @ C) Source code in src/flatprot/transformation/inertia_transformation.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def calculate_inertia_transformation_matrix ( coordinates : np . ndarray , weights : np . ndarray ) -> TransformationMatrix : \"\"\" Calculate transformation matrix for optimal molecular orientation, returning components compatible with standard (R @ X) + T application. The transformation aligns the principal axes with the coordinate axes and moves the center of mass/geometry C to the origin. This function calculates R_inertia and C, then returns R_standard = R_inertia and T_standard = -(R_inertia @ C). Args: coordinates: Nx3 array of atomic coordinates weights: N-length array of weights for each coordinate Returns: TransformationMatrix with rotation = R_inertia and translation = -(R_inertia @ C) \"\"\" # Calculate center (weighted or geometric) C if np . allclose ( weights , weights [ 0 ]): # All weights equal -> geometric center center_C = np . mean ( coordinates , axis = 0 ) else : # Weighted center of mass total_weight = np . sum ( weights ) if total_weight == 0 : center_C = np . mean ( coordinates , axis = 0 ) # Fallback for zero weights else : center_C = ( np . sum ( coordinates * weights [:, np . newaxis ], axis = 0 ) / total_weight ) # Center coordinates for inertia tensor calculation centered_coords = coordinates - center_C # Principal axis method using inertia tensor inertia_tensor = np . zeros (( 3 , 3 )) for coord , weight in zip ( centered_coords , weights ): r_squared = np . sum ( coord * coord ) inertia_tensor += weight * ( r_squared * np . eye ( 3 ) - np . outer ( coord , coord )) _ , eigenvectors = np . linalg . eigh ( inertia_tensor ) # Rotation matrix (R_inertia) is composed of the eigenvectors rotation_R_inertia = eigenvectors # Ensure a right-handed coordinate system if np . linalg . det ( rotation_R_inertia ) < 0 : rotation_R_inertia [:, 2 ] *= - 1 # Calculate the standard translation T = -(R_inertia @ C) # Ensure C is treated as a column vector for matmul center_C_col = center_C . reshape ( - 1 , 1 ) translation_T_standard_col = - ( rotation_R_inertia @ center_C_col ) translation_T_standard = translation_T_standard_col . flatten () # Back to (3,) # Return the matrix with components for standard application return TransformationMatrix ( rotation = rotation_R_inertia , translation = translation_T_standard ) options: show_root_heading: true Bases: BaseTransformationParameters Parameters for inertia-based projection calculation. Source code in src/flatprot/transformation/inertia_transformation.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @dataclass class InertiaTransformationParameters ( BaseTransformationParameters ): \"\"\"Parameters for inertia-based projection calculation.\"\"\" residue_weights : dict [ ResidueType , float ] # Maps residue type to weight use_weights : bool = False @classmethod def default ( cls ) -> \"InertiaTransformationParameters\" : \"\"\"Creates default parameters using standard amino acid weights.\"\"\" return cls ( residue_weights = { ResidueType . ALA : 89.1 , ResidueType . ARG : 174.2 , ResidueType . ASN : 132.1 , ResidueType . ASP : 133.1 , ResidueType . CYS : 121.2 , ResidueType . GLN : 146.2 , ResidueType . GLU : 147.1 , ResidueType . GLY : 75.1 , ResidueType . HIS : 155.2 , ResidueType . ILE : 131.2 , ResidueType . LEU : 131.2 , ResidueType . LYS : 146.2 , ResidueType . MET : 149.2 , ResidueType . PHE : 165.2 , ResidueType . PRO : 115.1 , ResidueType . SER : 105.1 , ResidueType . THR : 119.1 , ResidueType . TRP : 204.2 , ResidueType . TYR : 181.2 , ResidueType . VAL : 117.1 , } )","title":"Inertia-Based Transformation"},{"location":"api/transformation/#flatprot.transformation.inertia_transformation.InertiaTransformationParameters.default","text":"Creates default parameters using standard amino acid weights. Source code in src/flatprot/transformation/inertia_transformation.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @classmethod def default ( cls ) -> \"InertiaTransformationParameters\" : \"\"\"Creates default parameters using standard amino acid weights.\"\"\" return cls ( residue_weights = { ResidueType . ALA : 89.1 , ResidueType . ARG : 174.2 , ResidueType . ASN : 132.1 , ResidueType . ASP : 133.1 , ResidueType . CYS : 121.2 , ResidueType . GLN : 146.2 , ResidueType . GLU : 147.1 , ResidueType . GLY : 75.1 , ResidueType . HIS : 155.2 , ResidueType . ILE : 131.2 , ResidueType . LEU : 131.2 , ResidueType . LYS : 146.2 , ResidueType . MET : 149.2 , ResidueType . PHE : 165.2 , ResidueType . PRO : 115.1 , ResidueType . SER : 105.1 , ResidueType . THR : 119.1 , ResidueType . TRP : 204.2 , ResidueType . TYR : 181.2 , ResidueType . VAL : 117.1 , } ) options: show_root_heading: true members_order: source Bases: BaseTransformation [ InertiaTransformationParameters , InertiaTransformationArguments ] Transforms using inertia-based calculation with residue weights. Source code in src/flatprot/transformation/inertia_transformation.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class InertiaTransformer ( BaseTransformation [ InertiaTransformationParameters , InertiaTransformationArguments ] ): \"\"\"Transforms using inertia-based calculation with residue weights.\"\"\" def __init__ ( self , parameters : InertiaTransformationParameters ): super () . __init__ ( parameters = parameters ) def _calculate_transformation_matrix ( self , coordinates : np . ndarray , parameters : InertiaTransformationParameters , ) -> TransformationMatrix : \"\"\"Calculate transformation matrix for given coordinates.\"\"\" if not self . parameters . use_weights : weights = np . ones ( len ( coordinates )) else : # Map residue types to weights using parameters.residue_weights weights = np . array ( [ self . parameters . residue_weights . get ( res , 1.0 ) for res in parameters . residues ] ) return calculate_inertia_transformation_matrix ( coordinates , weights ) options: show_root_heading: true members_order: source","title":"default"},{"location":"api/transformation/#matrix-based-transformation","text":"Classes for applying a pre-defined transformation matrix. Bases: BaseTransformationParameters Parameters for matrix-based transformation. Source code in src/flatprot/transformation/matrix_transformation.py 14 15 16 17 18 @dataclass class MatrixTransformParameters ( BaseTransformationParameters ): \"\"\"Parameters for matrix-based transformation.\"\"\" matrix : TransformationMatrix options: show_root_heading: true members_order: source Bases: BaseTransformation [ MatrixTransformParameters , None] Projects coordinates using a provided rotation matrix and translation vector. This projector applies a fixed projection matrix provided at initialization. Source code in src/flatprot/transformation/matrix_transformation.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MatrixTransformer ( BaseTransformation [ MatrixTransformParameters , None ]): \"\"\"Projects coordinates using a provided rotation matrix and translation vector. This projector applies a fixed projection matrix provided at initialization. \"\"\" def __init__ ( self , parameters : MatrixTransformParameters ): \"\"\"Initialize with a fixed transformation matrix. Args: projection_matrix: The ProjectionMatrix to use for all projections \"\"\" super () . __init__ ( parameters ) self . _cached_transformation = parameters . matrix def _calculate_transformation_matrix ( self , coordinates : np . ndarray , ) -> TransformationMatrix : \"\"\"Return the fixed projection matrix. Since this projector uses a fixed projection matrix provided at initialization, this method simply returns the cached transformation. \"\"\" return self . _cached_transformation","title":"Matrix-Based Transformation"},{"location":"api/transformation/#flatprot.transformation.matrix_transformation.MatrixTransformer.__init__","text":"Initialize with a fixed transformation matrix. Parameters: projection_matrix \u2013 The ProjectionMatrix to use for all projections Source code in src/flatprot/transformation/matrix_transformation.py 27 28 29 30 31 32 33 34 def __init__ ( self , parameters : MatrixTransformParameters ): \"\"\"Initialize with a fixed transformation matrix. Args: projection_matrix: The ProjectionMatrix to use for all projections \"\"\" super () . __init__ ( parameters ) self . _cached_transformation = parameters . matrix options: show_root_heading: true members_order: source","title":"__init__"},{"location":"api/transformation/#structure-transformation-utilities","text":"Helper functions (often used internally by CLI commands) for applying transformations to flatprot.core.Structure objects. Transforms a Structure using its principal axes of inertia. Parameters: structure ( Structure ) \u2013 The protein structure to transform. custom_config_params ( Optional [ InertiaTransformationParameters ] , default: None ) \u2013 Optional InertiaTransformationParameters to override defaults (e.g., custom residue weights or disabling weights) passed to the InertiaTransformer's initialization. Returns: Structure \u2013 A new Structure object with transformed coordinates oriented along principal axes. Raises: TransformationError \u2013 If the structure is unsuitable for inertia calculation (e.g., lacks coordinates or residues), or if the transformation process fails mathematically. ValueError \u2013 If the structure lacks coordinates or residues required for the process. Source code in src/flatprot/utils/structure_utils.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def transform_structure_with_inertia ( structure : Structure , custom_config_params : Optional [ InertiaTransformationParameters ] = None , ) -> Structure : \"\"\"Transforms a Structure using its principal axes of inertia. Args: structure: The protein structure to transform. custom_config_params: Optional InertiaTransformationParameters to override defaults (e.g., custom residue weights or disabling weights) passed to the InertiaTransformer's initialization. Returns: A new Structure object with transformed coordinates oriented along principal axes. Raises: TransformationError: If the structure is unsuitable for inertia calculation (e.g., lacks coordinates or residues), or if the transformation process fails mathematically. ValueError: If the structure lacks coordinates or residues required for the process. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates for inertia transformation.\" ) if not hasattr ( structure , \"residues\" ) or not structure . residues : raise ValueError ( \"Structure has no residues for inertia transformation.\" ) if structure . coordinates . size == 0 : logger . warning ( \"Structure coordinates are empty, returning original structure.\" ) return structure # Return unchanged structure try : # Use provided config params or create default ones for the transformer's __init__ # InertiaTransformationParameters likely holds config like residue_weights dict inertia_config_parameters = ( custom_config_params or InertiaTransformationParameters . default () ) # Instantiate the transformer with its configuration parameters transformer = InertiaTransformer ( parameters = inertia_config_parameters ) logger . info ( \"Applying inertia transformation...\" ) # Prepare the runtime arguments needed specifically for the transform call # InertiaTransformArguments (aliased from InertiaTransformationParameters in inertia.py) # likely holds data specific to this call, like the list of residues. transform_arguments = InertiaTransformationArguments ( residues = structure . residues ) # Wrap the transformer's transform method def transform_func ( coords : np . ndarray ) -> np . ndarray : # Pass coordinates and the required runtime arguments object return transformer . transform ( coords , arguments = transform_arguments ) new_structure = structure . apply_vectorized_transformation ( transform_func ) logger . info ( \"Inertia transformation complete.\" ) return new_structure except Exception as e : logger . error ( f \"Error during inertia transformation: { str ( e ) } \" , exc_info = True ) # Re-raise as TransformationError if not already one if isinstance ( e , TransformationError ): raise raise TransformationError ( f \"Inertia transformation failed: { str ( e ) } \" ) from e options: show_root_heading: true Transforms a Structure using a matrix (loaded from path or identity). Parameters: structure ( Structure ) \u2013 The protein structure to transform. matrix_path ( Optional [ Path ] , default: None ) \u2013 Optional path to a numpy matrix file (.npy) for transformation. If None or loading fails gracefully, the identity matrix is used. Returns: Structure \u2013 A new Structure object with transformed coordinates. Raises: TransformationError \u2013 If the transformation process fails unexpectedly (e.g., matrix loading error, issues during transformation math). ValueError \u2013 If the structure lacks coordinates. Source code in src/flatprot/utils/structure_utils.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def transform_structure_with_matrix ( structure : Structure , matrix_path : Optional [ Path ] = None ) -> Structure : \"\"\"Transforms a Structure using a matrix (loaded from path or identity). Args: structure: The protein structure to transform. matrix_path: Optional path to a numpy matrix file (.npy) for transformation. If None or loading fails gracefully, the identity matrix is used. Returns: A new Structure object with transformed coordinates. Raises: TransformationError: If the transformation process fails unexpectedly (e.g., matrix loading error, issues during transformation math). ValueError: If the structure lacks coordinates. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to transform.\" ) if structure . coordinates . size == 0 : logger . warning ( \"Structure coordinates are empty, returning original structure.\" ) return structure # Return unchanged structure if no coords try : transformation_matrix = _load_transformation_matrix ( matrix_path ) # Correctly instantiate MatrixTransformer using its parameters class transformer_params = MatrixTransformParameters ( matrix = transformation_matrix ) transformer = MatrixTransformer ( parameters = transformer_params ) logger . info ( f \"Applying matrix transformation (source: { matrix_path or 'Identity' } )...\" ) new_structure = structure . apply_vectorized_transformation ( lambda coords : transformer . transform ( coords , arguments = None ) ) logger . info ( \"Matrix transformation complete.\" ) return new_structure except Exception as e : # Catch potential errors from apply_vectorized_transformation or transform_func logger . error ( f \"Error during matrix transformation: { str ( e ) } \" , exc_info = True ) # Re-raise as TransformationError if not already (e.g. ValueError from shape mismatch) if isinstance ( e , TransformationError ): raise raise TransformationError ( f \"Matrix transformation failed: { str ( e ) } \" ) from e options: show_root_heading: true","title":"Structure Transformation Utilities"},{"location":"api/transformation/#orthographic-projection","text":"Function for projecting a transformed 3D structure onto a 2D canvas. Projects the coordinates of a Structure orthographically, returning a new Structure. Assumes the input structure's coordinates are already appropriately transformed (e.g., centered and oriented via inertia or matrix transformation). The coordinates of the returned Structure will be the projected (X, Y, Depth) values. Parameters: structure ( Structure ) \u2013 The Structure object whose coordinates are to be projected. Assumes structure.coordinates holds the transformed 3D points. width ( int ) \u2013 The width of the target canvas in pixels. height ( int ) \u2013 The height of the target canvas in pixels. padding_x ( float , default: 0.05 ) \u2013 Horizontal padding as a fraction of the width (0 to <0.5). padding_y ( float , default: 0.05 ) \u2013 Vertical padding as a fraction of the height (0 to <0.5). maintain_aspect_ratio ( bool , default: True ) \u2013 Whether to scale uniformly to fit while preserving the structure's shape, or stretch to fill padding box. center_projection ( bool , default: True ) \u2013 Whether to center the projected structure within the canvas. view_direction ( Optional [ ndarray ] , default: None ) \u2013 Optional (3,) numpy array for the view direction (camera looking along -view_direction). Defaults to [0, 0, 1] if None. up_vector ( Optional [ ndarray ] , default: None ) \u2013 Optional (3,) numpy array for the initial up vector. Defaults to [0, 1, 0] if None. disable_scaling ( bool , default: False ) \u2013 If True, disables automatic scaling to fit canvas, useful for overlay comparisons where consistent scales are needed across different structures. Returns: Structure \u2013 A new Structure object where the coordinates represent the projected data: Structure \u2013 Column 0: X canvas coordinate (float) Structure \u2013 Column 1: Y canvas coordinate (float) Structure \u2013 Column 2: Depth value (float, representing scaled Z for visibility/layering) Raises: ProjectionError \u2013 If the projection process fails (e.g., mathematical error, invalid parameters). ValueError \u2013 If the structure lacks coordinates or if vector inputs are invalid. Source code in src/flatprot/utils/structure_utils.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def project_structure_orthographically ( structure : Structure , width : int , height : int , padding_x : float = 0.05 , padding_y : float = 0.05 , maintain_aspect_ratio : bool = True , center_projection : bool = True , view_direction : Optional [ np . ndarray ] = None , up_vector : Optional [ np . ndarray ] = None , disable_scaling : bool = False , ) -> Structure : \"\"\"Projects the coordinates of a Structure orthographically, returning a new Structure. Assumes the input structure's coordinates are already appropriately transformed (e.g., centered and oriented via inertia or matrix transformation). The coordinates of the returned Structure will be the projected (X, Y, Depth) values. Args: structure: The Structure object whose coordinates are to be projected. Assumes structure.coordinates holds the transformed 3D points. width: The width of the target canvas in pixels. height: The height of the target canvas in pixels. padding_x: Horizontal padding as a fraction of the width (0 to <0.5). padding_y: Vertical padding as a fraction of the height (0 to <0.5). maintain_aspect_ratio: Whether to scale uniformly to fit while preserving the structure's shape, or stretch to fill padding box. center_projection: Whether to center the projected structure within the canvas. view_direction: Optional (3,) numpy array for the view direction (camera looking along -view_direction). Defaults to [0, 0, 1] if None. up_vector: Optional (3,) numpy array for the initial up vector. Defaults to [0, 1, 0] if None. disable_scaling: If True, disables automatic scaling to fit canvas, useful for overlay comparisons where consistent scales are needed across different structures. Returns: A new Structure object where the coordinates represent the projected data: - Column 0: X canvas coordinate (float) - Column 1: Y canvas coordinate (float) - Column 2: Depth value (float, representing scaled Z for visibility/layering) Raises: ProjectionError: If the projection process fails (e.g., mathematical error, invalid parameters). ValueError: If the structure lacks coordinates or if vector inputs are invalid. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to project.\" ) coords_to_project = structure . coordinates if coords_to_project . size == 0 : logger . warning ( \"Structure coordinates are empty. Returning original structure.\" ) # Return original structure if no coordinates to project return structure try : projector = OrthographicProjection () # Construct parameters for the projection param_kwargs = { \"width\" : width , \"height\" : height , \"padding_x\" : padding_x , \"padding_y\" : padding_y , \"maintain_aspect_ratio\" : maintain_aspect_ratio , \"canvas_alignment\" : \"center\" if center_projection else \"top_left\" , \"disable_scaling\" : disable_scaling , } if view_direction is not None : param_kwargs [ \"view_direction\" ] = view_direction if up_vector is not None : param_kwargs [ \"up_vector\" ] = up_vector projection_params = OrthographicProjectionParameters ( ** param_kwargs ) # Define the transformation function that performs the projection def projection_func ( coords : np . ndarray ) -> np . ndarray : logger . info ( \"Performing orthographic projection internally...\" ) projected = projector . project ( coords , projection_params ) logger . info ( \"Internal projection complete.\" ) return projected . astype ( np . float32 ) # Ensure float32 # Use apply_vectorized_transformation to create a new structure # with the projected coordinates logger . info ( \"Applying projection transformation to structure...\" ) projected_structure = structure . apply_vectorized_transformation ( projection_func ) logger . info ( \"Projection transformation applied.\" ) return projected_structure except Exception as e : logger . error ( f \"Error during orthographic projection: { str ( e ) } \" , exc_info = True ) # Re-raise specific errors or wrap in ProjectionError if isinstance ( e , ( ProjectionError , ValueError )): raise raise ProjectionError ( f \"Orthographic projection failed: { str ( e ) } \" ) from e options: show_root_heading: true","title":"Orthographic Projection"},{"location":"api/transformation/#domain-transformation-utilities","text":"Classes and functions specifically for handling domain-based transformations. Encapsulates a transformation matrix applied to a specific protein domain. Attributes: domain_range ( ResidueRange ) \u2013 The specific residue range defining the domain. transformation_matrix ( TransformationMatrix ) \u2013 The matrix used to transform this domain. domain_id ( Optional [ str ] ) \u2013 An optional identifier for the domain (e.g., 'Domain1', 'N-term'). scop_id ( Optional [ str ] ) \u2013 An optional SCOP family identifier from alignment (e.g., '3000114'). alignment_probability ( Optional [ float ] ) \u2013 The alignment probability/quality score (0.0-1.0). Source code in src/flatprot/utils/domain_utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class DomainTransformation : \"\"\" Encapsulates a transformation matrix applied to a specific protein domain. Attributes: domain_range: The specific residue range defining the domain. transformation_matrix: The matrix used to transform this domain. domain_id: An optional identifier for the domain (e.g., 'Domain1', 'N-term'). scop_id: An optional SCOP family identifier from alignment (e.g., '3000114'). alignment_probability: The alignment probability/quality score (0.0-1.0). \"\"\" domain_range : ResidueRange transformation_matrix : TransformationMatrix domain_id : Optional [ str ] = None scop_id : Optional [ str ] = None alignment_probability : Optional [ float ] = None def __post_init__ ( self ): \"\"\"Validate inputs.\"\"\" if not isinstance ( self . domain_range , ResidueRange ): raise TypeError ( \"domain_range must be a ResidueRange object.\" ) if not isinstance ( self . transformation_matrix , TransformationMatrix ): raise TypeError ( \"transformation_matrix must be a TransformationMatrix object.\" ) if self . domain_id is not None and not isinstance ( self . domain_id , str ): raise TypeError ( \"domain_id must be a string if provided.\" ) if self . scop_id is not None and not isinstance ( self . scop_id , str ): raise TypeError ( \"scop_id must be a string if provided.\" ) def __repr__ ( self ) -> str : \"\"\"Provide a concise representation.\"\"\" name = f \" ' { self . domain_id } '\" if self . domain_id else \"\" return f \"<DomainTransformation { name } range= { self . domain_range } >\"","title":"Domain Transformation Utilities"},{"location":"api/transformation/#flatprot.utils.domain_utils.DomainTransformation.__post_init__","text":"Validate inputs. Source code in src/flatprot/utils/domain_utils.py 53 54 55 56 57 58 59 60 61 62 63 64 def __post_init__ ( self ): \"\"\"Validate inputs.\"\"\" if not isinstance ( self . domain_range , ResidueRange ): raise TypeError ( \"domain_range must be a ResidueRange object.\" ) if not isinstance ( self . transformation_matrix , TransformationMatrix ): raise TypeError ( \"transformation_matrix must be a TransformationMatrix object.\" ) if self . domain_id is not None and not isinstance ( self . domain_id , str ): raise TypeError ( \"domain_id must be a string if provided.\" ) if self . scop_id is not None and not isinstance ( self . scop_id , str ): raise TypeError ( \"scop_id must be a string if provided.\" )","title":"__post_init__"},{"location":"api/transformation/#flatprot.utils.domain_utils.DomainTransformation.__repr__","text":"Provide a concise representation. Source code in src/flatprot/utils/domain_utils.py 66 67 68 69 def __repr__ ( self ) -> str : \"\"\"Provide a concise representation.\"\"\" name = f \" ' { self . domain_id } '\" if self . domain_id else \"\" return f \"<DomainTransformation { name } range= { self . domain_range } >\" options: show_root_heading: true members_order: source Applies specific transformation matrices to defined domains around their centers. Each domain is rotated around its geometric center, preserving its position within the global structure while optimizing its orientation for visualization. Uses boolean masks to identify coordinates for each domain. Creates a new Structure object with transformed 3D coordinates. The original structure remains unchanged. Parameters: structure ( Structure ) \u2013 The original Structure object. domain_transforms ( List [ DomainTransformation ] ) \u2013 An ordered list of DomainTransformation objects. Rotations are applied around each domain's center. Returns: Structure \u2013 A new Structure object with coordinates transformed domain-specifically. Raises: TransformationError \u2013 If matrix application fails. ValueError \u2013 If structure lacks coordinates or if coordinates are not 3D. Source code in src/flatprot/utils/domain_utils.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def apply_domain_transformations_masked ( structure : Structure , domain_transforms : List [ DomainTransformation ], ) -> Structure : \"\"\" Applies specific transformation matrices to defined domains around their centers. Each domain is rotated around its geometric center, preserving its position within the global structure while optimizing its orientation for visualization. Uses boolean masks to identify coordinates for each domain. Creates a new Structure object with transformed 3D coordinates. The original structure remains unchanged. Args: structure: The original Structure object. domain_transforms: An ordered list of DomainTransformation objects. Rotations are applied around each domain's center. Returns: A new Structure object with coordinates transformed domain-specifically. Raises: TransformationError: If matrix application fails. ValueError: If structure lacks coordinates or if coordinates are not 3D. \"\"\" if not hasattr ( structure , \"coordinates\" ) or structure . coordinates is None : raise ValueError ( \"Structure has no coordinates to transform.\" ) if structure . coordinates . shape [ 1 ] != 3 : raise ValueError ( f \"Expected 3D coordinates, but got shape { structure . coordinates . shape } \" ) original_coords = structure . coordinates num_atoms = original_coords . shape [ 0 ] # 1. Create Transformation Masks (one per domain) domain_masks : List [ np . ndarray ] = [ np . zeros ( num_atoms , dtype = bool ) for _ in domain_transforms ] # 2. & 3. Iterate through structure coords and populate masks for chain in structure . values (): for residue in chain : for domain_idx , domain_tf in enumerate ( domain_transforms ): if residue in domain_tf . domain_range : if residue . coordinate_index < domain_masks [ domain_idx ] . shape [ 0 ]: domain_masks [ domain_idx ][ residue . coordinate_index ] = True transformed_coords = original_coords . copy () for mask , domain_tf in zip ( domain_masks , domain_transforms ): if not np . any ( mask ): logger . warning ( f \"No coordinates found for domain { domain_tf . domain_range } . Skipping transformation.\" ) continue domain_id_str = f \" ' { domain_tf . domain_id } '\" if domain_tf . domain_id else \"\" logger . debug ( f \"Applying centered transformation for domain { domain_id_str } { domain_tf . domain_range } (affecting { np . sum ( mask ) } coordinates)...\" ) try : # Calculate domain center domain_center = calculate_domain_center ( structure , domain_tf . domain_range ) # Create centered transformation using only rotation from domain_tf # This rotates the domain around its center, preserving its position rotation = domain_tf . transformation_matrix . rotation centered_matrix = create_centered_transformation ( rotation , domain_center ) # Apply transformation to the *original* coordinates selected by the mask coords_subset = original_coords [ mask , :] transformed_subset = centered_matrix . apply ( coords_subset ) if transformed_subset . shape != coords_subset . shape : raise TransformationError ( f \"Transformation resulted in unexpected shape change for domain { domain_tf . domain_range } . \" f \"Input shape: { coords_subset . shape } , Output shape: { transformed_subset . shape } \" ) transformed_coords [ mask , :] = transformed_subset logger . info ( f \"Applied centered rotation for domain { domain_id_str } { domain_tf . domain_range } \" f \"around center { domain_center } \" ) except Exception as e : raise TransformationError ( f \"Failed to apply centered transformation for domain { domain_tf . domain_range } : { e } \" ) from e # Create a new structure object with the same topology but new coordinates new_structure = structure . with_coordinates ( transformed_coords ) return new_structure options: show_root_heading: true","title":"__repr__"},{"location":"commands/align/","text":"Align Command Find the best matching protein superfamily for a structure using FoldSeek and retrieve the corresponding transformation matrix for standardized visualization. Usage flatprot align STRUCTURE_FILE [OPTIONS] Parameters Required STRUCTURE_FILE - Path to the input protein structure file (PDB or mmCIF format) Output Options --matrix / -m - Path to save the output transformation matrix (NumPy format) [default: alignment_matrix.npy] --info / -i - Path to save detailed alignment information as JSON. If omitted, info is printed to stdout Database Options --foldseek / -f - Path to the FoldSeek executable [default: foldseek] --foldseek-db / -b - Path to a custom FoldSeek database --database / -d - Path to the directory containing the custom FlatProt alignment database (HDF5 file) --database-file-name / -n - Name of the alignment database file [default: alignments.h5] --download-db - Force download/update of the default database Alignment Options --min-probability / -p - Minimum FoldSeek alignment probability threshold (0.0-1.0) [default: 0.5] --target-db-id - Force alignment against a specific target ID, bypassing probability checks --alignment-mode / -a - Alignment mode [default: family-identity] family-identity : Uses direct alignment matrix family-inertia : Uses database reference matrix combined with alignment General Options --quiet - Suppress all informational output except errors --verbose - Print additional debug information during execution Alignment Modes Family-Identity (Default) Uses the direct alignment matrix resulting from FoldSeek alignment between input and best-matching database entry. Family-Inertia Uses the pre-calculated reference matrix for the matched superfamily, combined with the FoldSeek alignment matrix. This spreads out structure elements while keeping basic family rotation but sacrifices consistent structure element placement. Examples Basic Usage # Basic alignment (saves to alignment_matrix.npy) flatprot align protein.pdb # Specify output paths flatprot align protein.cif -m rotation.npy -i alignment_info.json Alignment Modes # Family identity alignment (default) flatprot align protein.pdb --alignment-mode family-identity # Family inertia alignment flatprot align protein.pdb --alignment-mode family-inertia Custom Database and Thresholds # Use custom FoldSeek executable and database flatprot align protein.pdb -f /path/to/foldseek -b /path/to/foldseek_db # Adjust probability threshold flatprot align protein.pdb --min-probability 0.7 # Force alignment to specific target flatprot align protein.pdb --target-db-id \"3000114\" Database Management # Force database download/update flatprot align protein.pdb --download-db Output Files Transformation Matrix A 4x4 NumPy array ( .npy file) representing the rotation matrix that aligns the input structure. The specific matrix depends on the alignment mode: - Family-identity: Direct FoldSeek alignment matrix - Family-inertia: Pre-calculated reference matrix combined with alignment This matrix is intended for use with the flatprot project command. Alignment Information (JSON) Contains detailed alignment results including: { \"structure_file\": \"path/to/protein.pdb\", \"foldseek_db_path\": \"/path/to/foldseek_db\", \"min_probability\": 0.5, \"target_db_id\": null, \"alignment_mode\": \"family-identity\", \"best_hit\": { \"query_id\": \"protein\", \"target_id\": \"T1084-D1\", \"probability\": 0.995, \"e_value\": 8.74e-15, \"tm_score\": 0.789 }, \"matrix_file\": \"rotation.npy\" } Troubleshooting Common Issues Invalid or non-existent structure files: - Verify the structure file path is correct - Ensure file is in valid PDB or mmCIF format FoldSeek executable not found: - Check FoldSeek installation: which foldseek - Specify custom path with --foldseek /path/to/foldseek No significant alignment found: - Lower the probability threshold: --min-probability 0.3 - Check if the protein family is represented in the database Database corruption or access issues: - Try re-downloading: --download-db - Verify database file permissions and accessibility Network connectivity issues: - Check internet connection for database download - Consider using a local database with --foldseek-db","title":"Align"},{"location":"commands/align/#align-command","text":"Find the best matching protein superfamily for a structure using FoldSeek and retrieve the corresponding transformation matrix for standardized visualization.","title":"Align Command"},{"location":"commands/align/#usage","text":"flatprot align STRUCTURE_FILE [OPTIONS]","title":"Usage"},{"location":"commands/align/#parameters","text":"","title":"Parameters"},{"location":"commands/align/#required","text":"STRUCTURE_FILE - Path to the input protein structure file (PDB or mmCIF format)","title":"Required"},{"location":"commands/align/#output-options","text":"--matrix / -m - Path to save the output transformation matrix (NumPy format) [default: alignment_matrix.npy] --info / -i - Path to save detailed alignment information as JSON. If omitted, info is printed to stdout","title":"Output Options"},{"location":"commands/align/#database-options","text":"--foldseek / -f - Path to the FoldSeek executable [default: foldseek] --foldseek-db / -b - Path to a custom FoldSeek database --database / -d - Path to the directory containing the custom FlatProt alignment database (HDF5 file) --database-file-name / -n - Name of the alignment database file [default: alignments.h5] --download-db - Force download/update of the default database","title":"Database Options"},{"location":"commands/align/#alignment-options","text":"--min-probability / -p - Minimum FoldSeek alignment probability threshold (0.0-1.0) [default: 0.5] --target-db-id - Force alignment against a specific target ID, bypassing probability checks --alignment-mode / -a - Alignment mode [default: family-identity] family-identity : Uses direct alignment matrix family-inertia : Uses database reference matrix combined with alignment","title":"Alignment Options"},{"location":"commands/align/#general-options","text":"--quiet - Suppress all informational output except errors --verbose - Print additional debug information during execution","title":"General Options"},{"location":"commands/align/#alignment-modes","text":"","title":"Alignment Modes"},{"location":"commands/align/#family-identity-default","text":"Uses the direct alignment matrix resulting from FoldSeek alignment between input and best-matching database entry.","title":"Family-Identity (Default)"},{"location":"commands/align/#family-inertia","text":"Uses the pre-calculated reference matrix for the matched superfamily, combined with the FoldSeek alignment matrix. This spreads out structure elements while keeping basic family rotation but sacrifices consistent structure element placement.","title":"Family-Inertia"},{"location":"commands/align/#examples","text":"","title":"Examples"},{"location":"commands/align/#basic-usage","text":"# Basic alignment (saves to alignment_matrix.npy) flatprot align protein.pdb # Specify output paths flatprot align protein.cif -m rotation.npy -i alignment_info.json","title":"Basic Usage"},{"location":"commands/align/#alignment-modes_1","text":"# Family identity alignment (default) flatprot align protein.pdb --alignment-mode family-identity # Family inertia alignment flatprot align protein.pdb --alignment-mode family-inertia","title":"Alignment Modes"},{"location":"commands/align/#custom-database-and-thresholds","text":"# Use custom FoldSeek executable and database flatprot align protein.pdb -f /path/to/foldseek -b /path/to/foldseek_db # Adjust probability threshold flatprot align protein.pdb --min-probability 0.7 # Force alignment to specific target flatprot align protein.pdb --target-db-id \"3000114\"","title":"Custom Database and Thresholds"},{"location":"commands/align/#database-management","text":"# Force database download/update flatprot align protein.pdb --download-db","title":"Database Management"},{"location":"commands/align/#output-files","text":"","title":"Output Files"},{"location":"commands/align/#transformation-matrix","text":"A 4x4 NumPy array ( .npy file) representing the rotation matrix that aligns the input structure. The specific matrix depends on the alignment mode: - Family-identity: Direct FoldSeek alignment matrix - Family-inertia: Pre-calculated reference matrix combined with alignment This matrix is intended for use with the flatprot project command.","title":"Transformation Matrix"},{"location":"commands/align/#alignment-information-json","text":"Contains detailed alignment results including: { \"structure_file\": \"path/to/protein.pdb\", \"foldseek_db_path\": \"/path/to/foldseek_db\", \"min_probability\": 0.5, \"target_db_id\": null, \"alignment_mode\": \"family-identity\", \"best_hit\": { \"query_id\": \"protein\", \"target_id\": \"T1084-D1\", \"probability\": 0.995, \"e_value\": 8.74e-15, \"tm_score\": 0.789 }, \"matrix_file\": \"rotation.npy\" }","title":"Alignment Information (JSON)"},{"location":"commands/align/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"commands/align/#common-issues","text":"Invalid or non-existent structure files: - Verify the structure file path is correct - Ensure file is in valid PDB or mmCIF format FoldSeek executable not found: - Check FoldSeek installation: which foldseek - Specify custom path with --foldseek /path/to/foldseek No significant alignment found: - Lower the probability threshold: --min-probability 0.3 - Check if the protein family is represented in the database Database corruption or access issues: - Try re-downloading: --download-db - Verify database file permissions and accessibility Network connectivity issues: - Check internet connection for database download - Consider using a local database with --foldseek-db","title":"Common Issues"},{"location":"commands/overlay/","text":"Overlay Command Create combined visualizations from multiple protein structures with automatic clustering, family-based alignment, and opacity scaling. Usage flatprot overlay FILE_PATTERNS [OPTIONS] Parameters Required FILE_PATTERNS - Glob pattern(s) or space-separated file paths for input structures Examples: \"structures/*.cif\" , file1.cif file2.cif , \"data/*.cif\" Output Options --output - Output file path (format determined by extension: .svg, .png, .pdf) [default: overlay.png] --dpi - DPI for raster output formats [default: 300] Alignment Options --family - SCOP family ID for fixed family alignment (e.g., \"3000114\") --alignment-mode - Alignment strategy [default: family-identity] family-identity : Align structures using family database matching inertia : Use principal component analysis alignment --min-probability - Minimum alignment probability threshold [default: 0.5] Clustering Options --clustering / --no-clustering - Enable/disable clustering (auto-enabled at 100+ structures) --clustering-auto-threshold - Number of structures to auto-enable clustering [default: 100] --clustering-min-seq-id - Minimum sequence identity for clustering (0.0-1.0) [default: 0.5] --clustering-coverage - Coverage threshold for clustering (0.0-1.0) [default: 0.9] Visualization Options --style - Custom style TOML file path --canvas-width - Canvas width in pixels [default: 1000] --canvas-height - Canvas height in pixels [default: 1000] --disable-scaling - Disable automatic scaling for consistent size comparisons General Options --quiet - Suppress verbose output --verbose - Print additional information Alignment Modes Family-Identity Alignment (Recommended) Uses FoldSeek to align structures against a curated database of protein families with automatic database download and batch processing. For optimal conservation , it is recommended to align all structures to the same common core structure using a fixed family ID. This ensures consistent alignment across all structures in the overlay. # Align to best matching family (may vary per structure) flatprot overlay \"structures/*.cif\" --alignment-mode family-identity # Align to specific family for optimal conservation (recommended) flatprot overlay \"toxins/*.cif\" --family 3000114 --alignment-mode family-identity Note: Using automatic family detection or other alignment modes does not guarantee optimal conservation across structures, as each structure may align to different reference families. Inertia Alignment Uses principal component analysis for structure alignment. Fast processing with no external database dependencies. flatprot overlay \"structures/*.cif\" --alignment-mode inertia Clustering Automatic clustering reduces visual complexity by grouping similar structures: Auto-enabled for datasets with 100+ structures Uses FoldSeek to identify structural similarity Scales opacity based on cluster size (larger clusters = higher opacity) # Manual control flatprot overlay \"structures/*.cif\" --clustering # Force enable flatprot overlay \"structures/*.cif\" --no-clustering # Force disable # Custom thresholds flatprot overlay \"structures/*.cif\" --clustering-min-seq-id 0.8 --clustering-coverage 0.95 Output Formats SVG (Vector) Scalable, no Cairo required, small file size Best for web display and publications PNG (Raster) Universal compatibility, requires Cairo graphics library Adjustable DPI (150-600 recommended) PDF (Vector) Publication quality, requires Cairo graphics library # High-quality publication PDF flatprot overlay \"structures/*.cif\" -o publication.pdf --dpi 600 # Web-optimized SVG flatprot overlay \"structures/*.cif\" -o web_display.svg Requirements For PNG and PDF output, install Cairo graphics library: macOS: brew install cairo Ubuntu: sudo apt-get install libcairo2-dev pkg-config Windows: conda install cairo Verify installation: python -c \"import drawsvg; print('Cairo available:', hasattr(drawsvg, '_cairo_available') and drawsvg._cairo_available)\" Examples Basic Usage Simple overlay from glob pattern: flatprot overlay \"structures/*.cif\" -o overlay.png Multiple file patterns: flatprot overlay file1.cif file2.cif \"folder/*.cif\" -o combined.svg Family-Based Alignment Automatic family detection: flatprot overlay \"3ftx_family/*.cif\" --alignment-mode family-identity -o family_aligned.png Specific family alignment: flatprot overlay \"toxins/*.cif\" --family 3000114 --alignment-mode family-identity -o toxin_family.pdf Size Comparison Studies Compare structures at true relative sizes: flatprot overlay \"different_sizes/*.cif\" --disable-scaling --alignment-mode family-identity -o size_comparison.png Custom Styling Apply custom colors and styles: flatprot overlay \"structures/*.cif\" --style custom_theme.toml -o styled_overlay.png Publication-ready with high DPI: flatprot overlay \"family/*.cif\" --style publication.toml --dpi 600 -o figure.pdf Troubleshooting Common Issues \"Cairo library not available\" error: # Install Cairo brew install cairo # macOS sudo apt-get install libcairo2-dev # Ubuntu # Fallback to SVG flatprot overlay \"*.cif\" -o output.svg \"No files found matching pattern\" error: # Quote patterns properly flatprot overlay \"structures/*.cif\" # Correct Family alignment fails: # Force fallback to inertia mode flatprot overlay \"*.cif\" --alignment-mode inertia Memory issues with large datasets: # Use clustering to reduce structures flatprot overlay \"large_set/*.cif\" --clustering # Reduce canvas size flatprot overlay \"*.cif\" --canvas-width 500 --canvas-height 500 Performance Tips Use SVG output for fastest processing (no rasterization) Enable clustering for large datasets (>10 structures) Lower DPI for quick previews (150-200) Higher DPI for publications (300-600)","title":"Overlay"},{"location":"commands/overlay/#overlay-command","text":"Create combined visualizations from multiple protein structures with automatic clustering, family-based alignment, and opacity scaling.","title":"Overlay Command"},{"location":"commands/overlay/#usage","text":"flatprot overlay FILE_PATTERNS [OPTIONS]","title":"Usage"},{"location":"commands/overlay/#parameters","text":"","title":"Parameters"},{"location":"commands/overlay/#required","text":"FILE_PATTERNS - Glob pattern(s) or space-separated file paths for input structures Examples: \"structures/*.cif\" , file1.cif file2.cif , \"data/*.cif\"","title":"Required"},{"location":"commands/overlay/#output-options","text":"--output - Output file path (format determined by extension: .svg, .png, .pdf) [default: overlay.png] --dpi - DPI for raster output formats [default: 300]","title":"Output Options"},{"location":"commands/overlay/#alignment-options","text":"--family - SCOP family ID for fixed family alignment (e.g., \"3000114\") --alignment-mode - Alignment strategy [default: family-identity] family-identity : Align structures using family database matching inertia : Use principal component analysis alignment --min-probability - Minimum alignment probability threshold [default: 0.5]","title":"Alignment Options"},{"location":"commands/overlay/#clustering-options","text":"--clustering / --no-clustering - Enable/disable clustering (auto-enabled at 100+ structures) --clustering-auto-threshold - Number of structures to auto-enable clustering [default: 100] --clustering-min-seq-id - Minimum sequence identity for clustering (0.0-1.0) [default: 0.5] --clustering-coverage - Coverage threshold for clustering (0.0-1.0) [default: 0.9]","title":"Clustering Options"},{"location":"commands/overlay/#visualization-options","text":"--style - Custom style TOML file path --canvas-width - Canvas width in pixels [default: 1000] --canvas-height - Canvas height in pixels [default: 1000] --disable-scaling - Disable automatic scaling for consistent size comparisons","title":"Visualization Options"},{"location":"commands/overlay/#general-options","text":"--quiet - Suppress verbose output --verbose - Print additional information","title":"General Options"},{"location":"commands/overlay/#alignment-modes","text":"","title":"Alignment Modes"},{"location":"commands/overlay/#family-identity-alignment-recommended","text":"Uses FoldSeek to align structures against a curated database of protein families with automatic database download and batch processing. For optimal conservation , it is recommended to align all structures to the same common core structure using a fixed family ID. This ensures consistent alignment across all structures in the overlay. # Align to best matching family (may vary per structure) flatprot overlay \"structures/*.cif\" --alignment-mode family-identity # Align to specific family for optimal conservation (recommended) flatprot overlay \"toxins/*.cif\" --family 3000114 --alignment-mode family-identity Note: Using automatic family detection or other alignment modes does not guarantee optimal conservation across structures, as each structure may align to different reference families.","title":"Family-Identity Alignment (Recommended)"},{"location":"commands/overlay/#inertia-alignment","text":"Uses principal component analysis for structure alignment. Fast processing with no external database dependencies. flatprot overlay \"structures/*.cif\" --alignment-mode inertia","title":"Inertia Alignment"},{"location":"commands/overlay/#clustering","text":"Automatic clustering reduces visual complexity by grouping similar structures: Auto-enabled for datasets with 100+ structures Uses FoldSeek to identify structural similarity Scales opacity based on cluster size (larger clusters = higher opacity) # Manual control flatprot overlay \"structures/*.cif\" --clustering # Force enable flatprot overlay \"structures/*.cif\" --no-clustering # Force disable # Custom thresholds flatprot overlay \"structures/*.cif\" --clustering-min-seq-id 0.8 --clustering-coverage 0.95","title":"Clustering"},{"location":"commands/overlay/#output-formats","text":"","title":"Output Formats"},{"location":"commands/overlay/#svg-vector","text":"Scalable, no Cairo required, small file size Best for web display and publications","title":"SVG (Vector)"},{"location":"commands/overlay/#png-raster","text":"Universal compatibility, requires Cairo graphics library Adjustable DPI (150-600 recommended)","title":"PNG (Raster)"},{"location":"commands/overlay/#pdf-vector","text":"Publication quality, requires Cairo graphics library # High-quality publication PDF flatprot overlay \"structures/*.cif\" -o publication.pdf --dpi 600 # Web-optimized SVG flatprot overlay \"structures/*.cif\" -o web_display.svg","title":"PDF (Vector)"},{"location":"commands/overlay/#requirements","text":"For PNG and PDF output, install Cairo graphics library: macOS: brew install cairo Ubuntu: sudo apt-get install libcairo2-dev pkg-config Windows: conda install cairo Verify installation: python -c \"import drawsvg; print('Cairo available:', hasattr(drawsvg, '_cairo_available') and drawsvg._cairo_available)\"","title":"Requirements"},{"location":"commands/overlay/#examples","text":"","title":"Examples"},{"location":"commands/overlay/#basic-usage","text":"Simple overlay from glob pattern: flatprot overlay \"structures/*.cif\" -o overlay.png Multiple file patterns: flatprot overlay file1.cif file2.cif \"folder/*.cif\" -o combined.svg","title":"Basic Usage"},{"location":"commands/overlay/#family-based-alignment","text":"Automatic family detection: flatprot overlay \"3ftx_family/*.cif\" --alignment-mode family-identity -o family_aligned.png Specific family alignment: flatprot overlay \"toxins/*.cif\" --family 3000114 --alignment-mode family-identity -o toxin_family.pdf","title":"Family-Based Alignment"},{"location":"commands/overlay/#size-comparison-studies","text":"Compare structures at true relative sizes: flatprot overlay \"different_sizes/*.cif\" --disable-scaling --alignment-mode family-identity -o size_comparison.png","title":"Size Comparison Studies"},{"location":"commands/overlay/#custom-styling","text":"Apply custom colors and styles: flatprot overlay \"structures/*.cif\" --style custom_theme.toml -o styled_overlay.png Publication-ready with high DPI: flatprot overlay \"family/*.cif\" --style publication.toml --dpi 600 -o figure.pdf","title":"Custom Styling"},{"location":"commands/overlay/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"commands/overlay/#common-issues","text":"\"Cairo library not available\" error: # Install Cairo brew install cairo # macOS sudo apt-get install libcairo2-dev # Ubuntu # Fallback to SVG flatprot overlay \"*.cif\" -o output.svg \"No files found matching pattern\" error: # Quote patterns properly flatprot overlay \"structures/*.cif\" # Correct Family alignment fails: # Force fallback to inertia mode flatprot overlay \"*.cif\" --alignment-mode inertia Memory issues with large datasets: # Use clustering to reduce structures flatprot overlay \"large_set/*.cif\" --clustering # Reduce canvas size flatprot overlay \"*.cif\" --canvas-width 500 --canvas-height 500","title":"Common Issues"},{"location":"commands/overlay/#performance-tips","text":"Use SVG output for fastest processing (no rasterization) Enable clustering for large datasets (>10 structures) Lower DPI for quick previews (150-200) Higher DPI for publications (300-600)","title":"Performance Tips"},{"location":"commands/project/","text":"Project Command Transform a 3D protein structure into a standardized 2D SVG representation with optional custom transformations, styles, and annotations. Usage flatprot project STRUCTURE_FILE [OPTIONS] Parameters Required STRUCTURE_FILE - Path to the input protein structure file (PDB or mmCIF format) Output Options --output / -o - Path to save the output SVG file [default: stdout] --canvas-width - Width of the output SVG canvas in pixels [default: 1000] --canvas-height - Height of the output SVG canvas in pixels [default: 1000] Note: Canvas dimensions are controlled via CLI parameters only. Style files do not currently support canvas settings. Transformation Options --matrix - Path to a custom transformation matrix (NumPy .npy format). If omitted, inertia-based transformation is applied Styling Options --style - Path to a custom style file (TOML format). See Style File Format --annotations - Path to a custom annotation file (TOML format). See Annotation File Format --show-positions - Position annotation level: none , minimal , major , full [default: minimal] Input Options --dssp - Path to a DSSP file for secondary structure assignment. Required for PDB format files General Options --quiet - Suppress all informational output except errors --verbose - Print additional debug information during execution Input File Formats Structure Files PDB Format ( .pdb ): Requires DSSP file for secondary structure assignment mmCIF Format ( .cif , .mmcif ): Usually contains secondary structure information Matrix Files NumPy files ( .npy ) specifying custom 3D transformations. Supported formats: - 4x3 matrix: 3x3 rotation + 1x3 translation - 3x4 matrix: Transposed version (auto-corrected) - 3x3 matrix: Pure rotation (zero translation) If omitted, inertia-based transformation is applied. Position Annotations Controls residue numbering and terminus labels in the SVG output: none : No position annotations minimal (default): Only N and C terminus labels major : Terminus labels + residue numbers for major secondary structures (\u22653 residues) full : All position annotations including single-residue elements Examples Basic Usage # Basic projection (mmCIF to SVG) flatprot project structure.cif -o output.svg # Projection with DSSP (PDB to SVG) flatprot project structure.pdb -o output.svg --dssp structure.dssp # Output to stdout flatprot project structure.cif > output.svg Custom Styling and Annotations # Apply custom styling flatprot project structure.cif -o output.svg --style custom_styles.toml # Add annotations flatprot project structure.cif -o output.svg --annotations features.toml # Combine multiple options flatprot project structure.cif -o styled_annotated.svg \\ --matrix alignment_matrix.npy \\ --style custom_styles.toml \\ --annotations features.toml Matrix Transformations # Use pre-calculated alignment matrix flatprot project structure.cif -o aligned_output.svg --matrix alignment_matrix.npy # Extract matrix from PyMOL orientation uv run scripts/get_matrix.py structure.cif flatprot project structure.cif -o pymol_oriented.svg --matrix rotation_matrix.npy See the PyMOL Matrix Extraction documentation for details. Position Annotations # No position annotations flatprot project structure.cif -o clean.svg --show-positions none # Only terminus labels (default) flatprot project structure.cif -o terminus.svg --show-positions minimal # Major secondary structures flatprot project structure.cif -o major.svg --show-positions major # All position annotations flatprot project structure.cif -o detailed.svg --show-positions full Canvas Size Adjustment # Large canvas for detailed output flatprot project structure.cif -o large_output.svg --canvas-width 1500 --canvas-height 1200 Troubleshooting Common Issues Missing DSSP file for PDB input: # Generate DSSP file first mkdssp structure.pdb structure.dssp flatprot project structure.pdb --dssp structure.dssp -o output.svg Invalid matrix format: - Ensure matrix file is in NumPy .npy format - Supported shapes: 3x3, 3x4, or 4x3 - Use --verbose for detailed error information File format errors: - Verify structure file is valid PDB or mmCIF format - Check that style/annotation files are valid TOML format - Ensure all file paths are correct and accessible","title":"Project"},{"location":"commands/project/#project-command","text":"Transform a 3D protein structure into a standardized 2D SVG representation with optional custom transformations, styles, and annotations.","title":"Project Command"},{"location":"commands/project/#usage","text":"flatprot project STRUCTURE_FILE [OPTIONS]","title":"Usage"},{"location":"commands/project/#parameters","text":"","title":"Parameters"},{"location":"commands/project/#required","text":"STRUCTURE_FILE - Path to the input protein structure file (PDB or mmCIF format)","title":"Required"},{"location":"commands/project/#output-options","text":"--output / -o - Path to save the output SVG file [default: stdout] --canvas-width - Width of the output SVG canvas in pixels [default: 1000] --canvas-height - Height of the output SVG canvas in pixels [default: 1000] Note: Canvas dimensions are controlled via CLI parameters only. Style files do not currently support canvas settings.","title":"Output Options"},{"location":"commands/project/#transformation-options","text":"--matrix - Path to a custom transformation matrix (NumPy .npy format). If omitted, inertia-based transformation is applied","title":"Transformation Options"},{"location":"commands/project/#styling-options","text":"--style - Path to a custom style file (TOML format). See Style File Format --annotations - Path to a custom annotation file (TOML format). See Annotation File Format --show-positions - Position annotation level: none , minimal , major , full [default: minimal]","title":"Styling Options"},{"location":"commands/project/#input-options","text":"--dssp - Path to a DSSP file for secondary structure assignment. Required for PDB format files","title":"Input Options"},{"location":"commands/project/#general-options","text":"--quiet - Suppress all informational output except errors --verbose - Print additional debug information during execution","title":"General Options"},{"location":"commands/project/#input-file-formats","text":"","title":"Input File Formats"},{"location":"commands/project/#structure-files","text":"PDB Format ( .pdb ): Requires DSSP file for secondary structure assignment mmCIF Format ( .cif , .mmcif ): Usually contains secondary structure information","title":"Structure Files"},{"location":"commands/project/#matrix-files","text":"NumPy files ( .npy ) specifying custom 3D transformations. Supported formats: - 4x3 matrix: 3x3 rotation + 1x3 translation - 3x4 matrix: Transposed version (auto-corrected) - 3x3 matrix: Pure rotation (zero translation) If omitted, inertia-based transformation is applied.","title":"Matrix Files"},{"location":"commands/project/#position-annotations","text":"Controls residue numbering and terminus labels in the SVG output: none : No position annotations minimal (default): Only N and C terminus labels major : Terminus labels + residue numbers for major secondary structures (\u22653 residues) full : All position annotations including single-residue elements","title":"Position Annotations"},{"location":"commands/project/#examples","text":"","title":"Examples"},{"location":"commands/project/#basic-usage","text":"# Basic projection (mmCIF to SVG) flatprot project structure.cif -o output.svg # Projection with DSSP (PDB to SVG) flatprot project structure.pdb -o output.svg --dssp structure.dssp # Output to stdout flatprot project structure.cif > output.svg","title":"Basic Usage"},{"location":"commands/project/#custom-styling-and-annotations","text":"# Apply custom styling flatprot project structure.cif -o output.svg --style custom_styles.toml # Add annotations flatprot project structure.cif -o output.svg --annotations features.toml # Combine multiple options flatprot project structure.cif -o styled_annotated.svg \\ --matrix alignment_matrix.npy \\ --style custom_styles.toml \\ --annotations features.toml","title":"Custom Styling and Annotations"},{"location":"commands/project/#matrix-transformations","text":"# Use pre-calculated alignment matrix flatprot project structure.cif -o aligned_output.svg --matrix alignment_matrix.npy # Extract matrix from PyMOL orientation uv run scripts/get_matrix.py structure.cif flatprot project structure.cif -o pymol_oriented.svg --matrix rotation_matrix.npy See the PyMOL Matrix Extraction documentation for details.","title":"Matrix Transformations"},{"location":"commands/project/#position-annotations_1","text":"# No position annotations flatprot project structure.cif -o clean.svg --show-positions none # Only terminus labels (default) flatprot project structure.cif -o terminus.svg --show-positions minimal # Major secondary structures flatprot project structure.cif -o major.svg --show-positions major # All position annotations flatprot project structure.cif -o detailed.svg --show-positions full","title":"Position Annotations"},{"location":"commands/project/#canvas-size-adjustment","text":"# Large canvas for detailed output flatprot project structure.cif -o large_output.svg --canvas-width 1500 --canvas-height 1200","title":"Canvas Size Adjustment"},{"location":"commands/project/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"commands/project/#common-issues","text":"Missing DSSP file for PDB input: # Generate DSSP file first mkdssp structure.pdb structure.dssp flatprot project structure.pdb --dssp structure.dssp -o output.svg Invalid matrix format: - Ensure matrix file is in NumPy .npy format - Supported shapes: 3x3, 3x4, or 4x3 - Use --verbose for detailed error information File format errors: - Verify structure file is valid PDB or mmCIF format - Check that style/annotation files are valid TOML format - Ensure all file paths are correct and accessible","title":"Common Issues"},{"location":"commands/split/","text":"Split Command Extract and visualize specific structural regions from protein structures with automatic alignment and progressive gap layout. Usage flatprot split STRUCTURE_FILE --regions \"REGIONS\" [OPTIONS] Parameters Required STRUCTURE_FILE - Path to input structure file (PDB/CIF format) --regions / -r - Comma-separated residue regions in format \"CHAIN:START-END\" Examples: \"A:1-100,A:150-250\" , \"A:1-100,B:50-150,A:200-300\" Output Options --output / -o - Output SVG file path [default: split_output.svg] --canvas-width - Canvas width in pixels [default: 1000] --canvas-height - Canvas height in pixels [default: 1000] Gap Options --gap-x - Progressive horizontal gap between domains in pixels [default: 0.0] --gap-y - Progressive vertical gap between domains in pixels [default: 0.0] Alignment Options --alignment-mode - Alignment strategy [default: family-identity] family-identity : Align each region using FoldSeek database search inertia : Use principal component analysis alignment --min-probability - Minimum alignment probability threshold [default: 0.5] --foldseek / -f - FoldSeek executable path [default: foldseek] --show-database-alignment - Enable database alignment and show family area annotations Styling Options --style - Custom style TOML file path --show-positions - Position annotation level: none , minimal , major , full [default: minimal] Input Options --dssp - DSSP file for PDB input (required for PDB files) Requirements FoldSeek : Required for database alignment functionality DSSP (mkdssp v4.4.0+) : Required for PDB input files Install via conda: conda install bioconda::foldseek conda-forge::dssp Alignment Modes Family-Identity Alignment (Recommended) Uses FoldSeek to align each region against a curated database of protein families: - Automatic database download on first use - Region-specific alignment with rotation-only transformations - Family annotations show SCOP family IDs and alignment probabilities # Basic family-identity alignment with annotations flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_regions.svg # High-confidence alignments only flatprot split protein.cif --regions \"A:1-100,A:150-250\" --min-probability 0.8 --show-database-alignment Inertia Alignment Uses principal component analysis for structure alignment. Fast processing with no external database dependencies. flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode inertia Position Annotations Controls residue numbering and terminus labels for each domain: none : No position annotations minimal (default): Only N and C terminus labels for each domain major : Terminus labels + residue numbers for major secondary structures (\u22653 residues) full : All position annotations including single-residue elements Progressive Gap Positioning Each domain is offset from the previous one using progressive gaps: - Last domain remains at origin (0,0) - Previous domains offset by gap amount \u00d7 position - Flexible arrangements combine gap_x and gap_y for custom layouts # Horizontal arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-x 150 # Vertical arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-y 200 # Diagonal arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-x 100 --gap-y 150 Region Specification Format Pattern : \"CHAIN:START-END\" Multiple regions : Comma-separated list Chain IDs : Single letters (A, B, C, etc.) Residue numbers : 1-based indexing Examples # Single chain, multiple domains flatprot split protein.cif --regions \"A:1-100,A:150-250,A:300-400\" # Multiple chains flatprot split structure.cif --regions \"A:1-100,B:50-150,C:20-120\" # Overlapping regions flatprot split protein.cif --regions \"A:1-120,A:80-200\" # 40 residue overlap Examples Basic Usage # Simple domain splitting flatprot split protein.cif --regions \"A:1-100,A:150-250\" -o domains.svg # Multiple chains with progressive gaps flatprot split structure.cif --regions \"A:1-100,B:50-150,A:200-300\" --gap-x 150 --gap-y 100 -o multi_chain.svg Database Alignment and Annotations # Enable family alignment with annotations flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_annotated.svg # High-confidence alignments with custom threshold flatprot split protein.cif --regions \"A:1-80,A:100-180,A:200-280\" --show-database-alignment --min-probability 0.7 -o high_confidence.svg Custom Styling and Visualization # Clean domains without annotations flatprot split protein.cif --regions \"A:10-110,A:130-230\" --style custom.toml --show-positions none -o clean.svg # Major structures with residue numbers flatprot split protein.cif --regions \"A:10-110,A:130-230\" --style custom.toml --show-positions major -o detailed.svg # Large canvas with progressive gaps flatprot split protein.cif --regions \"A:1-100,A:150-250,A:300-400\" --canvas-width 1500 --gap-x 200 --gap-y 100 -o large_canvas.svg PDB Input Workflow # 1. Generate secondary structure mkdssp -i protein.pdb -o protein.dssp # 2. Split with database alignment flatprot split protein.pdb --regions \"A:1-100,A:150-200\" --dssp protein.dssp --show-database-alignment -o output.svg Comparison Studies # Compare alignment modes flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode family-identity --show-database-alignment -o family_aligned.svg flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode inertia -o inertia_aligned.svg Troubleshooting Common Issues \"DSSP file required for PDB input\" error: # Generate DSSP file first mkdssp -i structure.pdb -o structure.dssp flatprot split structure.pdb --regions \"A:1-100\" --dssp structure.dssp \"Invalid region format\" error: # Check region format flatprot split protein.cif --regions \"A:1-100,B:50-150\" # Correct flatprot split protein.cif --regions \"A:1:100,B:50-150\" # Incorrect (colon instead of dash) \"No successful alignments found\" error: # Lower probability threshold flatprot split protein.cif --regions \"A:1-100\" --min-probability 0.3 --show-database-alignment # Or disable database alignment flatprot split protein.cif --regions \"A:1-100\" --alignment-mode inertia \"Chain not found in structure\" error: # Check available chains in PDB grep \"^ATOM\" structure.pdb | awk '{print $5}' | sort -u # Or examine CIF structure to verify chain IDs Database download issues: # Check network connectivity and FoldSeek installation which foldseek # Use inertia mode as fallback flatprot split protein.cif --regions \"A:1-100\" --alignment-mode inertia Performance Tips Speed Optimization Use CIF input (no DSSP file generation required) Disable database alignment for quick gap-based positioning only Smaller canvas sizes for faster processing Fewer regions reduce extraction and alignment time Quality Optimization Enable database alignment for biologically meaningful orientations Higher alignment probability thresholds for confident annotations Custom styling for publication-ready output Larger canvas sizes for detailed visualization Memory Optimization Limit number of regions for memory-constrained systems Smaller region sizes reduce memory usage Use minimal/none position annotations for simpler scenes Integration with Other Commands Workflow with Align Command # 1. Explore protein family alignment flatprot align protein.cif -i alignment_info.json # 2. Extract domains with family-specific alignment flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_domains.svg Workflow with Project Command # 1. Create full structure projection flatprot project protein.cif -o full_structure.svg # 2. Create domain-specific split view flatprot split protein.cif --regions \"A:1-100,A:150-250\" --gap-x 150 -o domain_split.svg","title":"Split"},{"location":"commands/split/#split-command","text":"Extract and visualize specific structural regions from protein structures with automatic alignment and progressive gap layout.","title":"Split Command"},{"location":"commands/split/#usage","text":"flatprot split STRUCTURE_FILE --regions \"REGIONS\" [OPTIONS]","title":"Usage"},{"location":"commands/split/#parameters","text":"","title":"Parameters"},{"location":"commands/split/#required","text":"STRUCTURE_FILE - Path to input structure file (PDB/CIF format) --regions / -r - Comma-separated residue regions in format \"CHAIN:START-END\" Examples: \"A:1-100,A:150-250\" , \"A:1-100,B:50-150,A:200-300\"","title":"Required"},{"location":"commands/split/#output-options","text":"--output / -o - Output SVG file path [default: split_output.svg] --canvas-width - Canvas width in pixels [default: 1000] --canvas-height - Canvas height in pixels [default: 1000]","title":"Output Options"},{"location":"commands/split/#gap-options","text":"--gap-x - Progressive horizontal gap between domains in pixels [default: 0.0] --gap-y - Progressive vertical gap between domains in pixels [default: 0.0]","title":"Gap Options"},{"location":"commands/split/#alignment-options","text":"--alignment-mode - Alignment strategy [default: family-identity] family-identity : Align each region using FoldSeek database search inertia : Use principal component analysis alignment --min-probability - Minimum alignment probability threshold [default: 0.5] --foldseek / -f - FoldSeek executable path [default: foldseek] --show-database-alignment - Enable database alignment and show family area annotations","title":"Alignment Options"},{"location":"commands/split/#styling-options","text":"--style - Custom style TOML file path --show-positions - Position annotation level: none , minimal , major , full [default: minimal]","title":"Styling Options"},{"location":"commands/split/#input-options","text":"--dssp - DSSP file for PDB input (required for PDB files)","title":"Input Options"},{"location":"commands/split/#requirements","text":"FoldSeek : Required for database alignment functionality DSSP (mkdssp v4.4.0+) : Required for PDB input files Install via conda: conda install bioconda::foldseek conda-forge::dssp","title":"Requirements"},{"location":"commands/split/#alignment-modes","text":"","title":"Alignment Modes"},{"location":"commands/split/#family-identity-alignment-recommended","text":"Uses FoldSeek to align each region against a curated database of protein families: - Automatic database download on first use - Region-specific alignment with rotation-only transformations - Family annotations show SCOP family IDs and alignment probabilities # Basic family-identity alignment with annotations flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_regions.svg # High-confidence alignments only flatprot split protein.cif --regions \"A:1-100,A:150-250\" --min-probability 0.8 --show-database-alignment","title":"Family-Identity Alignment (Recommended)"},{"location":"commands/split/#inertia-alignment","text":"Uses principal component analysis for structure alignment. Fast processing with no external database dependencies. flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode inertia","title":"Inertia Alignment"},{"location":"commands/split/#position-annotations","text":"Controls residue numbering and terminus labels for each domain: none : No position annotations minimal (default): Only N and C terminus labels for each domain major : Terminus labels + residue numbers for major secondary structures (\u22653 residues) full : All position annotations including single-residue elements","title":"Position Annotations"},{"location":"commands/split/#progressive-gap-positioning","text":"Each domain is offset from the previous one using progressive gaps: - Last domain remains at origin (0,0) - Previous domains offset by gap amount \u00d7 position - Flexible arrangements combine gap_x and gap_y for custom layouts # Horizontal arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-x 150 # Vertical arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-y 200 # Diagonal arrangement flatprot split protein.cif --regions \"A:1-100,A:150-250,B:1-80\" --gap-x 100 --gap-y 150","title":"Progressive Gap Positioning"},{"location":"commands/split/#region-specification","text":"","title":"Region Specification"},{"location":"commands/split/#format","text":"Pattern : \"CHAIN:START-END\" Multiple regions : Comma-separated list Chain IDs : Single letters (A, B, C, etc.) Residue numbers : 1-based indexing","title":"Format"},{"location":"commands/split/#examples","text":"# Single chain, multiple domains flatprot split protein.cif --regions \"A:1-100,A:150-250,A:300-400\" # Multiple chains flatprot split structure.cif --regions \"A:1-100,B:50-150,C:20-120\" # Overlapping regions flatprot split protein.cif --regions \"A:1-120,A:80-200\" # 40 residue overlap","title":"Examples"},{"location":"commands/split/#examples_1","text":"","title":"Examples"},{"location":"commands/split/#basic-usage","text":"# Simple domain splitting flatprot split protein.cif --regions \"A:1-100,A:150-250\" -o domains.svg # Multiple chains with progressive gaps flatprot split structure.cif --regions \"A:1-100,B:50-150,A:200-300\" --gap-x 150 --gap-y 100 -o multi_chain.svg","title":"Basic Usage"},{"location":"commands/split/#database-alignment-and-annotations","text":"# Enable family alignment with annotations flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_annotated.svg # High-confidence alignments with custom threshold flatprot split protein.cif --regions \"A:1-80,A:100-180,A:200-280\" --show-database-alignment --min-probability 0.7 -o high_confidence.svg","title":"Database Alignment and Annotations"},{"location":"commands/split/#custom-styling-and-visualization","text":"# Clean domains without annotations flatprot split protein.cif --regions \"A:10-110,A:130-230\" --style custom.toml --show-positions none -o clean.svg # Major structures with residue numbers flatprot split protein.cif --regions \"A:10-110,A:130-230\" --style custom.toml --show-positions major -o detailed.svg # Large canvas with progressive gaps flatprot split protein.cif --regions \"A:1-100,A:150-250,A:300-400\" --canvas-width 1500 --gap-x 200 --gap-y 100 -o large_canvas.svg","title":"Custom Styling and Visualization"},{"location":"commands/split/#pdb-input-workflow","text":"# 1. Generate secondary structure mkdssp -i protein.pdb -o protein.dssp # 2. Split with database alignment flatprot split protein.pdb --regions \"A:1-100,A:150-200\" --dssp protein.dssp --show-database-alignment -o output.svg","title":"PDB Input Workflow"},{"location":"commands/split/#comparison-studies","text":"# Compare alignment modes flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode family-identity --show-database-alignment -o family_aligned.svg flatprot split protein.cif --regions \"A:1-100,A:150-250\" --alignment-mode inertia -o inertia_aligned.svg","title":"Comparison Studies"},{"location":"commands/split/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"commands/split/#common-issues","text":"\"DSSP file required for PDB input\" error: # Generate DSSP file first mkdssp -i structure.pdb -o structure.dssp flatprot split structure.pdb --regions \"A:1-100\" --dssp structure.dssp \"Invalid region format\" error: # Check region format flatprot split protein.cif --regions \"A:1-100,B:50-150\" # Correct flatprot split protein.cif --regions \"A:1:100,B:50-150\" # Incorrect (colon instead of dash) \"No successful alignments found\" error: # Lower probability threshold flatprot split protein.cif --regions \"A:1-100\" --min-probability 0.3 --show-database-alignment # Or disable database alignment flatprot split protein.cif --regions \"A:1-100\" --alignment-mode inertia \"Chain not found in structure\" error: # Check available chains in PDB grep \"^ATOM\" structure.pdb | awk '{print $5}' | sort -u # Or examine CIF structure to verify chain IDs Database download issues: # Check network connectivity and FoldSeek installation which foldseek # Use inertia mode as fallback flatprot split protein.cif --regions \"A:1-100\" --alignment-mode inertia","title":"Common Issues"},{"location":"commands/split/#performance-tips","text":"","title":"Performance Tips"},{"location":"commands/split/#speed-optimization","text":"Use CIF input (no DSSP file generation required) Disable database alignment for quick gap-based positioning only Smaller canvas sizes for faster processing Fewer regions reduce extraction and alignment time","title":"Speed Optimization"},{"location":"commands/split/#quality-optimization","text":"Enable database alignment for biologically meaningful orientations Higher alignment probability thresholds for confident annotations Custom styling for publication-ready output Larger canvas sizes for detailed visualization","title":"Quality Optimization"},{"location":"commands/split/#memory-optimization","text":"Limit number of regions for memory-constrained systems Smaller region sizes reduce memory usage Use minimal/none position annotations for simpler scenes","title":"Memory Optimization"},{"location":"commands/split/#integration-with-other-commands","text":"","title":"Integration with Other Commands"},{"location":"commands/split/#workflow-with-align-command","text":"# 1. Explore protein family alignment flatprot align protein.cif -i alignment_info.json # 2. Extract domains with family-specific alignment flatprot split protein.cif --regions \"A:1-100,A:150-250\" --show-database-alignment -o aligned_domains.svg","title":"Workflow with Align Command"},{"location":"commands/split/#workflow-with-project-command","text":"# 1. Create full structure projection flatprot project protein.cif -o full_structure.svg # 2. Create domain-specific split view flatprot split protein.cif --regions \"A:1-100,A:150-250\" --gap-x 150 -o domain_split.svg","title":"Workflow with Project Command"},{"location":"file_formats/annotations/","text":"Annotation File Format FlatProt uses TOML files for defining annotations to highlight specific features in protein structures. This document explains the format and options available for creating different types of annotations. Overview The annotation file must be a valid TOML document. The primary structure consists of a top-level key named annotations which holds an array of tables. Each table in this array represents a single annotation. Annotations allow you to highlight specific features in your protein structure, including: Individual residues (point annotations) Connections between residues (line annotations) Regions of the structure (area annotations) You can define multiple annotations in a single file by adding more tables to the annotations array. File Format # This entire file is in TOML format. # The top-level key must be 'annotations', containing an array of tables. [[annotations]] type = \"point\", # Required: type of annotation label = \"Active Site His\", # Optional: displayed label index = \"A:41\", # Required: target residue (ChainID:ResidueIndex) id = \"point-his41\", # Optional: unique identifier # Optional inline 'style' table for overrides: [annotations.style] marker_radius = 8.0, color = \"#FF0000\", label_offset = [5.0, -5.0] # TOML array for tuple # --- Second Annotation Table --- # [[annotations]] type = \"line\", label = \"Disulfide Bond\", indices = [\"A:23\", \"A:76\"], # Required: target start/end residues [annotations.style] line_color = \"#FFA500\", # Orange stroke_width = 2.0, line_style = [4.0, 2.0], # Dashed line pattern (TOML array) connector_radius = 3.0 # --- Third Annotation Table --- # [[annotations]] type = \"area\", label = \"Binding Domain\", range = \"A:100-150\", # Required: target residue range (ChainID:Start-End) [annotations.style] fill_color = \"#00FF00\", # Green fill_opacity = 0.25, stroke_color = \"#808080\", # Grey outline padding = 15.0 Annotation Table Fields Each table within the annotations list defines a single annotation and must contain the following fields: Field Type Description Required Default type String Type of annotation. Must be one of: \"point\" , \"line\" , \"area\" . Yes N/A label String Optional descriptive text label displayed with the annotation. No None id String Optional unique identifier for the annotation. If omitted, one is generated. No Generated style Table Optional inline table defining style overrides for this specific annotation. See below. No Default annotation styles Additionally, exactly one of the following targeting fields must be provided: Field Type Description Required by Type Format Example index String Target residue for point annotations. Format: \"ChainID:ResidueIndex\" . point only \"A:41\" indices Array of Strings Target start and end residues for line annotations. Format as index . line only [\"A:23\", \"A:76\"] range String Target residue range for area annotations. Format: \"ChainID:Start-End\" . area only \"A:100-150\" Inline Style ( style Table) Each annotation can optionally include a style table (a TOML table) to override default appearance settings. If a style table is present, its fields override the corresponding defaults for that specific annotation type. If the style table or individual fields within it are omitted, the default values are used. Common Style Attributes (Applicable to all types within the style table) Attribute Type Default Description color Color \"#FF0000\" Default color (e.g., for marker fill, line stroke). Red. offset Array[Float, Float] [0.0, 0.0] 2D offset (x, y) applied to the annotation's anchor point. label_color Color \"#000000\" Color for the annotation label (default black). label_font_size Float 12.0 Font size for the label. label_font_weight String \"normal\" Font weight for the label (e.g., \"normal\", \"bold\"). label_font_family String \"Arial\" Font family for the label. label_offset Array[Float, Float] [0.0, 0.0] 2D offset (x, y) applied specifically to the label's position. Point Annotation Style ( style table when type = \"point\" ) Attribute Type Default Description marker_radius Float 5.0 Radius (size) of the point marker (must be >= 0). Note: Point markers are always rendered as circles. Line Annotation Style ( style table when type = \"line\" ) Attribute Type Default Description stroke_width Float 1.0 Width of the annotation line (must be >= 0). line_style Array[Float, ...] [5.0, 5.0] Dash pattern (e.g., [5.0, 5.0] for dashed). Empty [] means solid. connector_color Color \"#000000\" Color of the small circles at the start/end points (default black). line_color Color \"#000000\" Color of the line itself (default black). arrowhead_start Boolean false Draw an arrowhead at the start of the line? arrowhead_end Boolean false Draw an arrowhead at the end of the line? connector_radius Float 2.0 Radius of the connector circles (must be >= 0). Area Annotation Style ( style table when type = \"area\" ) Attribute Type Default Description fill_color Color None Fill color. If None , uses color with fill_opacity . fill_opacity Float 0.3 Opacity for the fill (0.0 to 1.0). stroke_width Float 1.0 Width of the area outline (must be >= 0). linestyle Array[Float, ...] [] Dash pattern for the outline. Empty [] means solid. padding Float 20.0 Padding pixels added outside the convex hull of the area points (must be >= 0). interpolation_points Integer 3 (Internal detail related to rendering, might not be useful to expose widely) smoothing_window Integer 1 (Internal detail related to rendering, might not be useful to expose widely) Color Formats Colors can be specified in any of the following formats recognized by Pydantic's Color type: Hex codes: \"#FF5733\" , \"FF5733\" , \"#F53\" , \"F53\" RGB format: \"rgb(255, 87, 51)\" RGBA format: \"rgba(255, 87, 51, 0.5)\" (Alpha is usually handled by opacity or fill_opacity style fields) Named colors: \"red\" , \"blue\" , \"green\" , etc. (Standard web color names) Validation FlatProt validates annotation files when parsing: Checks for valid TOML syntax. Ensures the top-level annotations list exists and contains tables (dictionaries). Verifies that each annotation table has a valid type . Checks for the presence and correct format of the required targeting field ( index , indices , or range ). Validates the format of coordinate and range strings ( ChainID:Index , ChainID:Start-End ). If an inline style table is present, validates its fields against the corresponding style model (e.g., checks types, ranges, allowed values). If an annotation file is invalid, an error message will be displayed explaining the specific issue and location (e.g., Annotation #3: Invalid value for 'marker_radius' ).","title":"Annotation Files"},{"location":"file_formats/annotations/#annotation-file-format","text":"FlatProt uses TOML files for defining annotations to highlight specific features in protein structures. This document explains the format and options available for creating different types of annotations.","title":"Annotation File Format"},{"location":"file_formats/annotations/#overview","text":"The annotation file must be a valid TOML document. The primary structure consists of a top-level key named annotations which holds an array of tables. Each table in this array represents a single annotation. Annotations allow you to highlight specific features in your protein structure, including: Individual residues (point annotations) Connections between residues (line annotations) Regions of the structure (area annotations) You can define multiple annotations in a single file by adding more tables to the annotations array.","title":"Overview"},{"location":"file_formats/annotations/#file-format","text":"# This entire file is in TOML format. # The top-level key must be 'annotations', containing an array of tables. [[annotations]] type = \"point\", # Required: type of annotation label = \"Active Site His\", # Optional: displayed label index = \"A:41\", # Required: target residue (ChainID:ResidueIndex) id = \"point-his41\", # Optional: unique identifier # Optional inline 'style' table for overrides: [annotations.style] marker_radius = 8.0, color = \"#FF0000\", label_offset = [5.0, -5.0] # TOML array for tuple # --- Second Annotation Table --- # [[annotations]] type = \"line\", label = \"Disulfide Bond\", indices = [\"A:23\", \"A:76\"], # Required: target start/end residues [annotations.style] line_color = \"#FFA500\", # Orange stroke_width = 2.0, line_style = [4.0, 2.0], # Dashed line pattern (TOML array) connector_radius = 3.0 # --- Third Annotation Table --- # [[annotations]] type = \"area\", label = \"Binding Domain\", range = \"A:100-150\", # Required: target residue range (ChainID:Start-End) [annotations.style] fill_color = \"#00FF00\", # Green fill_opacity = 0.25, stroke_color = \"#808080\", # Grey outline padding = 15.0","title":"File Format"},{"location":"file_formats/annotations/#annotation-table-fields","text":"Each table within the annotations list defines a single annotation and must contain the following fields: Field Type Description Required Default type String Type of annotation. Must be one of: \"point\" , \"line\" , \"area\" . Yes N/A label String Optional descriptive text label displayed with the annotation. No None id String Optional unique identifier for the annotation. If omitted, one is generated. No Generated style Table Optional inline table defining style overrides for this specific annotation. See below. No Default annotation styles Additionally, exactly one of the following targeting fields must be provided: Field Type Description Required by Type Format Example index String Target residue for point annotations. Format: \"ChainID:ResidueIndex\" . point only \"A:41\" indices Array of Strings Target start and end residues for line annotations. Format as index . line only [\"A:23\", \"A:76\"] range String Target residue range for area annotations. Format: \"ChainID:Start-End\" . area only \"A:100-150\"","title":"Annotation Table Fields"},{"location":"file_formats/annotations/#inline-style-style-table","text":"Each annotation can optionally include a style table (a TOML table) to override default appearance settings. If a style table is present, its fields override the corresponding defaults for that specific annotation type. If the style table or individual fields within it are omitted, the default values are used.","title":"Inline Style (style Table)"},{"location":"file_formats/annotations/#common-style-attributes-applicable-to-all-types-within-the-style-table","text":"Attribute Type Default Description color Color \"#FF0000\" Default color (e.g., for marker fill, line stroke). Red. offset Array[Float, Float] [0.0, 0.0] 2D offset (x, y) applied to the annotation's anchor point. label_color Color \"#000000\" Color for the annotation label (default black). label_font_size Float 12.0 Font size for the label. label_font_weight String \"normal\" Font weight for the label (e.g., \"normal\", \"bold\"). label_font_family String \"Arial\" Font family for the label. label_offset Array[Float, Float] [0.0, 0.0] 2D offset (x, y) applied specifically to the label's position.","title":"Common Style Attributes (Applicable to all types within the style table)"},{"location":"file_formats/annotations/#point-annotation-style-style-table-when-type-point","text":"Attribute Type Default Description marker_radius Float 5.0 Radius (size) of the point marker (must be >= 0). Note: Point markers are always rendered as circles.","title":"Point Annotation Style (style table when type = \"point\")"},{"location":"file_formats/annotations/#line-annotation-style-style-table-when-type-line","text":"Attribute Type Default Description stroke_width Float 1.0 Width of the annotation line (must be >= 0). line_style Array[Float, ...] [5.0, 5.0] Dash pattern (e.g., [5.0, 5.0] for dashed). Empty [] means solid. connector_color Color \"#000000\" Color of the small circles at the start/end points (default black). line_color Color \"#000000\" Color of the line itself (default black). arrowhead_start Boolean false Draw an arrowhead at the start of the line? arrowhead_end Boolean false Draw an arrowhead at the end of the line? connector_radius Float 2.0 Radius of the connector circles (must be >= 0).","title":"Line Annotation Style (style table when type = \"line\")"},{"location":"file_formats/annotations/#area-annotation-style-style-table-when-type-area","text":"Attribute Type Default Description fill_color Color None Fill color. If None , uses color with fill_opacity . fill_opacity Float 0.3 Opacity for the fill (0.0 to 1.0). stroke_width Float 1.0 Width of the area outline (must be >= 0). linestyle Array[Float, ...] [] Dash pattern for the outline. Empty [] means solid. padding Float 20.0 Padding pixels added outside the convex hull of the area points (must be >= 0). interpolation_points Integer 3 (Internal detail related to rendering, might not be useful to expose widely) smoothing_window Integer 1 (Internal detail related to rendering, might not be useful to expose widely)","title":"Area Annotation Style (style table when type = \"area\")"},{"location":"file_formats/annotations/#color-formats","text":"Colors can be specified in any of the following formats recognized by Pydantic's Color type: Hex codes: \"#FF5733\" , \"FF5733\" , \"#F53\" , \"F53\" RGB format: \"rgb(255, 87, 51)\" RGBA format: \"rgba(255, 87, 51, 0.5)\" (Alpha is usually handled by opacity or fill_opacity style fields) Named colors: \"red\" , \"blue\" , \"green\" , etc. (Standard web color names)","title":"Color Formats"},{"location":"file_formats/annotations/#validation","text":"FlatProt validates annotation files when parsing: Checks for valid TOML syntax. Ensures the top-level annotations list exists and contains tables (dictionaries). Verifies that each annotation table has a valid type . Checks for the presence and correct format of the required targeting field ( index , indices , or range ). Validates the format of coordinate and range strings ( ChainID:Index , ChainID:Start-End ). If an inline style table is present, validates its fields against the corresponding style model (e.g., checks types, ranges, allowed values). If an annotation file is invalid, an error message will be displayed explaining the specific issue and location (e.g., Annotation #3: Invalid value for 'marker_radius' ).","title":"Validation"},{"location":"file_formats/dssp/","text":"DSSP File Format DSSP (Define Secondary Structure of Proteins) files contain secondary structure assignments for protein structures. These files are required when using PDB format files with FlatProt. Overview DSSP files provide: Secondary structure assignments Solvent accessibility calculations Hydrogen bond information Geometric features File Format DSSP files follow a specific format with both header and data sections. Header Section The header contains information about: The source PDB file DSSP version Processing date Total number of residues Author information Warning DSSP files are not well specified and can contain errors. We recomend using mmCIF files containing secondary structure information. FlatProt assumes DSSP files are generated using the dssp >= 4.4 command line tool. Note If you supply a dssp file, it will take precedence over the secondary structure information in the mmCIF file. Example header: ==== Secondary Structure Definition by the program DSSP, CMBI version by M.L. Hekkelman/2010-10-21 ==== DATE=2024-03-15 . REFERENCE W. KABSCH AND C.SANDER, BIOPOLYMERS 22 (1983) 2577-2637 . HEADER PROTEIN 01-JAN-20 1ABC . COMPND MOL_ID: 1; MOLECULE: PROTEIN; CHAIN: A; . SOURCE MOL_ID: 1; ORGANISM_SCIENTIFIC: EXAMPLE ORGANISM; ORGANISM_TAXID: 9999; . AUTHOR JOHN DOE . Data Section The data section contains per-residue information in a fixed-width format: # RESIDUE AA STRUCTURE BP1 BP2 ACC N-H-->O O-->H-N N-H-->O O-->H-N TCO KAPPA ALPHA PHI PSI X-CA Y-CA Z-CA 1 1 A M 0 0 223 0, 0.0 2,-0.3 0, 0.0 0, 0.0 0.000 360.0 360.0 360.0 -34.6 10.3 12.8 13.5 2 2 A S > - 0 0 85 1,-0.1 3,-1.3 0, 0.0 4,-0.3 -0.805 360.0-154.1 -90.5 143.8 9.7 16.5 13.4 Fields in order: Residue number Chain identifier Amino acid (one letter code) Secondary structure assignment Beta bridge partner residues Solvent accessibility Hydrogen bond information Geometric parameters (phi, psi angles) CA atom coordinates Secondary Structure Codes DSSP uses the following codes for secondary structure: Code Structure Type Description H \u03b1-helix Regular \u03b1-helix G 3\u2081\u2080-helix Tighter helix with 3 residues per turn I \u03c0-helix Wider helix with 5 residues per turn E \u03b2-strand Extended strand in parallel/antiparallel \u03b2-sheet B \u03b2-bridge Isolated \u03b2-bridge residue T Turn Hydrogen bonded turn S Bend High curvature region ' ' Coil Unstructured region (space character) Usage with FlatProt When using PDB format files, a DSSP file must be provided using the --dssp option: flatprot structure.pdb output.svg --dssp structure.dssp Validation FlatProt validates DSSP files for: Format Compliance Checks header format Validates data section format Verifies field alignments Content Validation Matches residue numbers with structure Validates chain identifiers Checks secondary structure codes Consistency Verifies consistency with structure file Checks residue matching Validates chain correspondence Error Handling Common DSSP-related errors: Missing DSSP File Error when using PDB without DSSP Solution: Generate DSSP file or use mmCIF Format Errors Invalid DSSP format Misaligned columns Invalid secondary structure codes Consistency Errors Mismatched residue numbers Inconsistent chain identifiers Structure/DSSP mismatch Generating DSSP Files DSSP files can be generated using the mkdssp program: mkdssp -i structure.pdb -o structure.dssp For more information about DSSP: DSSP redo GitHub Manual Page DSSP redo Website","title":"DSSP File Format"},{"location":"file_formats/dssp/#dssp-file-format","text":"DSSP (Define Secondary Structure of Proteins) files contain secondary structure assignments for protein structures. These files are required when using PDB format files with FlatProt.","title":"DSSP File Format"},{"location":"file_formats/dssp/#overview","text":"DSSP files provide: Secondary structure assignments Solvent accessibility calculations Hydrogen bond information Geometric features","title":"Overview"},{"location":"file_formats/dssp/#file-format","text":"DSSP files follow a specific format with both header and data sections.","title":"File Format"},{"location":"file_formats/dssp/#header-section","text":"The header contains information about: The source PDB file DSSP version Processing date Total number of residues Author information Warning DSSP files are not well specified and can contain errors. We recomend using mmCIF files containing secondary structure information. FlatProt assumes DSSP files are generated using the dssp >= 4.4 command line tool. Note If you supply a dssp file, it will take precedence over the secondary structure information in the mmCIF file. Example header: ==== Secondary Structure Definition by the program DSSP, CMBI version by M.L. Hekkelman/2010-10-21 ==== DATE=2024-03-15 . REFERENCE W. KABSCH AND C.SANDER, BIOPOLYMERS 22 (1983) 2577-2637 . HEADER PROTEIN 01-JAN-20 1ABC . COMPND MOL_ID: 1; MOLECULE: PROTEIN; CHAIN: A; . SOURCE MOL_ID: 1; ORGANISM_SCIENTIFIC: EXAMPLE ORGANISM; ORGANISM_TAXID: 9999; . AUTHOR JOHN DOE .","title":"Header Section"},{"location":"file_formats/dssp/#data-section","text":"The data section contains per-residue information in a fixed-width format: # RESIDUE AA STRUCTURE BP1 BP2 ACC N-H-->O O-->H-N N-H-->O O-->H-N TCO KAPPA ALPHA PHI PSI X-CA Y-CA Z-CA 1 1 A M 0 0 223 0, 0.0 2,-0.3 0, 0.0 0, 0.0 0.000 360.0 360.0 360.0 -34.6 10.3 12.8 13.5 2 2 A S > - 0 0 85 1,-0.1 3,-1.3 0, 0.0 4,-0.3 -0.805 360.0-154.1 -90.5 143.8 9.7 16.5 13.4 Fields in order: Residue number Chain identifier Amino acid (one letter code) Secondary structure assignment Beta bridge partner residues Solvent accessibility Hydrogen bond information Geometric parameters (phi, psi angles) CA atom coordinates","title":"Data Section"},{"location":"file_formats/dssp/#secondary-structure-codes","text":"DSSP uses the following codes for secondary structure: Code Structure Type Description H \u03b1-helix Regular \u03b1-helix G 3\u2081\u2080-helix Tighter helix with 3 residues per turn I \u03c0-helix Wider helix with 5 residues per turn E \u03b2-strand Extended strand in parallel/antiparallel \u03b2-sheet B \u03b2-bridge Isolated \u03b2-bridge residue T Turn Hydrogen bonded turn S Bend High curvature region ' ' Coil Unstructured region (space character)","title":"Secondary Structure Codes"},{"location":"file_formats/dssp/#usage-with-flatprot","text":"When using PDB format files, a DSSP file must be provided using the --dssp option: flatprot structure.pdb output.svg --dssp structure.dssp","title":"Usage with FlatProt"},{"location":"file_formats/dssp/#validation","text":"FlatProt validates DSSP files for: Format Compliance Checks header format Validates data section format Verifies field alignments Content Validation Matches residue numbers with structure Validates chain identifiers Checks secondary structure codes Consistency Verifies consistency with structure file Checks residue matching Validates chain correspondence","title":"Validation"},{"location":"file_formats/dssp/#error-handling","text":"Common DSSP-related errors: Missing DSSP File Error when using PDB without DSSP Solution: Generate DSSP file or use mmCIF Format Errors Invalid DSSP format Misaligned columns Invalid secondary structure codes Consistency Errors Mismatched residue numbers Inconsistent chain identifiers Structure/DSSP mismatch","title":"Error Handling"},{"location":"file_formats/dssp/#generating-dssp-files","text":"DSSP files can be generated using the mkdssp program: mkdssp -i structure.pdb -o structure.dssp For more information about DSSP: DSSP redo GitHub Manual Page DSSP redo Website","title":"Generating DSSP Files"},{"location":"file_formats/matrix/","text":"Matrix File Format FlatProt uses transformation matrices to control how protein structures are oriented in the 2D visualization. This document explains the format of these matrix files. Overview A transformation matrix in FlatProt consists of: A 3\u00d73 rotation matrix A 3-element translation vector Together, these define how the protein structure is positioned and oriented in 3D space before projection to 2D. File Format Matrix files should be saved as NumPy .npy files containing a 2D array with one of the following shapes: 4\u00d73 matrix (preferred format): First 3 rows: 3\u00d73 rotation matrix Last row: 1\u00d73 translation vector 3\u00d74 matrix (will be automatically transposed): First 3 columns: 3\u00d73 rotation matrix Last column: 3\u00d71 translation vector 3\u00d73 matrix (rotation only): The entire matrix is treated as a rotation matrix Translation is assumed to be zero Creating Matrix Files You can create a matrix file using NumPy: import numpy as np # Create a rotation matrix (identity rotation) rotation = np.eye(3) # Create a translation vector (move 5 units along x-axis) translation = np.array([5.0, 0.0, 0.0]) # Combine into a 4\u00d73 matrix matrix = np.vstack([rotation, translation]) # Save to a file np.save(\"my_transformation.npy\", matrix) Validation FlatProt validates matrix files to ensure they have the correct dimensions and format. If a matrix file is invalid, an error message will be displayed explaining the issue.","title":"Matrix Files"},{"location":"file_formats/matrix/#matrix-file-format","text":"FlatProt uses transformation matrices to control how protein structures are oriented in the 2D visualization. This document explains the format of these matrix files.","title":"Matrix File Format"},{"location":"file_formats/matrix/#overview","text":"A transformation matrix in FlatProt consists of: A 3\u00d73 rotation matrix A 3-element translation vector Together, these define how the protein structure is positioned and oriented in 3D space before projection to 2D.","title":"Overview"},{"location":"file_formats/matrix/#file-format","text":"Matrix files should be saved as NumPy .npy files containing a 2D array with one of the following shapes: 4\u00d73 matrix (preferred format): First 3 rows: 3\u00d73 rotation matrix Last row: 1\u00d73 translation vector 3\u00d74 matrix (will be automatically transposed): First 3 columns: 3\u00d73 rotation matrix Last column: 3\u00d71 translation vector 3\u00d73 matrix (rotation only): The entire matrix is treated as a rotation matrix Translation is assumed to be zero","title":"File Format"},{"location":"file_formats/matrix/#creating-matrix-files","text":"You can create a matrix file using NumPy: import numpy as np # Create a rotation matrix (identity rotation) rotation = np.eye(3) # Create a translation vector (move 5 units along x-axis) translation = np.array([5.0, 0.0, 0.0]) # Combine into a 4\u00d73 matrix matrix = np.vstack([rotation, translation]) # Save to a file np.save(\"my_transformation.npy\", matrix)","title":"Creating Matrix Files"},{"location":"file_formats/matrix/#validation","text":"FlatProt validates matrix files to ensure they have the correct dimensions and format. If a matrix file is invalid, an error message will be displayed explaining the issue.","title":"Validation"},{"location":"file_formats/structure/","text":"Structure File Format FlatProt accepts protein structure files in standard formats used in structural biology. This document explains the supported formats and requirements for structure files. We recomend supplying a mmCIF file containing secondary structure information. You can produce a valid mmCIF file containing secondary structure information using dssp >= 4.4 command line tool. Supported Formats FlatProt supports the following structure file formats: mmCIF Format (recommended) File extensions: .cif , .mmcif Can contain both structure and secondary structure information Preferred format for new structures PDB Format File extension: .pdb Requires additional DSSP file for secondary structure information Legacy format, still widely used File Requirements mmCIF Files Must be valid mmCIF format Must contain atomic coordinates Should include secondary structure information Must include chain identifiers Must include residue numbers You can produce a valid mmCIF file containing secondary structure information using dssp >= 4.4 command line tool. Example header of a valid mmCIF file: data_ # _entry.id \"1ABC\" # loop_ _atom_site.group_PDB _atom_site.id _atom_site.type_symbol _atom_site.label_atom_id _atom_site.label_alt_id _atom_site.label_comp_id _atom_site.label_asym_id _atom_site.label_entity_id _atom_site.label_seq_id _atom_site.pdbx_PDB_ins_code _atom_site.Cartn_x _atom_site.Cartn_y _atom_site.Cartn_z _atom_site.occupancy _atom_site.B_iso_or_equiv _atom_site.pdbx_formal_charge _atom_site.auth_seq_id _atom_site.auth_comp_id _atom_site.auth_asym_id _atom_site.auth_atom_id _atom_site.pdbx_PDB_model_num PDB Files Must be valid PDB format Must contain atomic coordinates Must include chain identifiers Must include residue numbers Must have a valid header section Requires a companion DSSP file for secondary structure information Example header of a valid PDB file: HEADER PROTEIN 01-JAN-20 1ABC TITLE EXAMPLE PROTEIN STRUCTURE COMPND MOL_ID: 1; COMPND MOLECULE: PROTEIN; COMPND CHAIN: A; SOURCE MOL_ID: 1; SOURCE ORGANISM_SCIENTIFIC: EXAMPLE ORGANISM; SOURCE ORGANISM_TAXID: 9999; KEYWDS PROTEIN, STRUCTURE EXPDTA X-RAY DIFFRACTION AUTHOR JOHN DOE REVDAT 1 01-JAN-20 1ABC 0 JRNL AUTH J.DOE REMARK 2 REMARK 2 RESOLUTION. 2.00 ANGSTROMS Validation FlatProt performs several validation checks on structure files: File Existence Verifies that the specified file exists Checks file permissions Format Validation Validates file format based on extension Checks for required sections and headers Verifies coordinate data format Content Validation Checks for presence of atomic coordinates Verifies chain identifiers Validates residue numbering Checks for secondary structure information (mmCIF only) Error Handling Common errors and their solutions: File Not Found Error: StructureFileNotFoundError Solution: Verify file path and permissions Invalid Format Error: InvalidStructureError Solution: Check file format and content Missing Secondary Structure Error: SecondaryStructureError Solution: Provide DSSP file for PDB format or use mmCIF Best Practices Use mmCIF Format More robust and complete than PDB format Includes secondary structure information Better handling of large structures Include Headers Provide complete header information Include experimental details Document structure source Chain Identifiers Use unique chain identifiers Document chain contents Maintain consistent numbering Quality Control Validate coordinates Check for missing atoms Verify secondary structure assignments","title":"Structure File Format"},{"location":"file_formats/structure/#structure-file-format","text":"FlatProt accepts protein structure files in standard formats used in structural biology. This document explains the supported formats and requirements for structure files. We recomend supplying a mmCIF file containing secondary structure information. You can produce a valid mmCIF file containing secondary structure information using dssp >= 4.4 command line tool.","title":"Structure File Format"},{"location":"file_formats/structure/#supported-formats","text":"FlatProt supports the following structure file formats: mmCIF Format (recommended) File extensions: .cif , .mmcif Can contain both structure and secondary structure information Preferred format for new structures PDB Format File extension: .pdb Requires additional DSSP file for secondary structure information Legacy format, still widely used","title":"Supported Formats"},{"location":"file_formats/structure/#file-requirements","text":"","title":"File Requirements"},{"location":"file_formats/structure/#mmcif-files","text":"Must be valid mmCIF format Must contain atomic coordinates Should include secondary structure information Must include chain identifiers Must include residue numbers You can produce a valid mmCIF file containing secondary structure information using dssp >= 4.4 command line tool. Example header of a valid mmCIF file: data_ # _entry.id \"1ABC\" # loop_ _atom_site.group_PDB _atom_site.id _atom_site.type_symbol _atom_site.label_atom_id _atom_site.label_alt_id _atom_site.label_comp_id _atom_site.label_asym_id _atom_site.label_entity_id _atom_site.label_seq_id _atom_site.pdbx_PDB_ins_code _atom_site.Cartn_x _atom_site.Cartn_y _atom_site.Cartn_z _atom_site.occupancy _atom_site.B_iso_or_equiv _atom_site.pdbx_formal_charge _atom_site.auth_seq_id _atom_site.auth_comp_id _atom_site.auth_asym_id _atom_site.auth_atom_id _atom_site.pdbx_PDB_model_num","title":"mmCIF Files"},{"location":"file_formats/structure/#pdb-files","text":"Must be valid PDB format Must contain atomic coordinates Must include chain identifiers Must include residue numbers Must have a valid header section Requires a companion DSSP file for secondary structure information Example header of a valid PDB file: HEADER PROTEIN 01-JAN-20 1ABC TITLE EXAMPLE PROTEIN STRUCTURE COMPND MOL_ID: 1; COMPND MOLECULE: PROTEIN; COMPND CHAIN: A; SOURCE MOL_ID: 1; SOURCE ORGANISM_SCIENTIFIC: EXAMPLE ORGANISM; SOURCE ORGANISM_TAXID: 9999; KEYWDS PROTEIN, STRUCTURE EXPDTA X-RAY DIFFRACTION AUTHOR JOHN DOE REVDAT 1 01-JAN-20 1ABC 0 JRNL AUTH J.DOE REMARK 2 REMARK 2 RESOLUTION. 2.00 ANGSTROMS","title":"PDB Files"},{"location":"file_formats/structure/#validation","text":"FlatProt performs several validation checks on structure files: File Existence Verifies that the specified file exists Checks file permissions Format Validation Validates file format based on extension Checks for required sections and headers Verifies coordinate data format Content Validation Checks for presence of atomic coordinates Verifies chain identifiers Validates residue numbering Checks for secondary structure information (mmCIF only)","title":"Validation"},{"location":"file_formats/structure/#error-handling","text":"Common errors and their solutions: File Not Found Error: StructureFileNotFoundError Solution: Verify file path and permissions Invalid Format Error: InvalidStructureError Solution: Check file format and content Missing Secondary Structure Error: SecondaryStructureError Solution: Provide DSSP file for PDB format or use mmCIF","title":"Error Handling"},{"location":"file_formats/structure/#best-practices","text":"Use mmCIF Format More robust and complete than PDB format Includes secondary structure information Better handling of large structures Include Headers Provide complete header information Include experimental details Document structure source Chain Identifiers Use unique chain identifiers Document chain contents Maintain consistent numbering Quality Control Validate coordinates Check for missing atoms Verify secondary structure assignments","title":"Best Practices"},{"location":"file_formats/style/","text":"Style File Format FlatProt uses TOML files for defining custom styles for protein visualizations. This document explains the format and options available for styling different elements of the visualization. Overview Style files allow you to customize the appearance of various elements in the FlatProt visualization, including: Secondary structure elements (helices, sheets, coils) Annotations (points, lines, areas) File Format Style files use the TOML format, with each section defining styles for a specific element type. Example Style File # Secondary structure styles [helix] fill_color = \"#FF5733\" stroke_color = \"#000000\" stroke_width = 1.5 amplitude = 0.5 [sheet] fill_color = \"#33FF57\" stroke_color = \"#000000\" stroke_width = 1.0 min_sheet_length = 3 [coil] stroke_color = \"#888888\" stroke_width = 1.0 # Annotation styles [point_annotation] fill_color = \"#3357FF\" stroke_color = \"#000000\" radius = 5.0 [line_annotation] stroke_color = \"#FF33A8\" stroke_width = 2.0 [area_annotation] fill_color = \"#FFFF33\" fill_opacity = 0.5 stroke_color = \"#000000\" stroke_width = 1.0 padding = 2.0 smoothing_window = 3 interpolation_points = 10 Style Sections Secondary Structure Styles These sections define the appearance of secondary structure elements rendered in the visualization. Common properties like color , stroke_color , stroke_width , and opacity are inherited but can be overridden. Helix Style ( [helix] ) Defines the appearance of alpha helices, typically rendered as zigzag ribbons. Property Type Default Description color Color \"#ff0000\" Fill color for the helix ribbon (default red). stroke_color Color \"#000000\" Color for the outline/stroke (default black). stroke_width Float 1.0 Reference width; used as a base for other dimensions. opacity Float 1.0 Opacity of the helix element (0.0 to 1.0). ribbon_thickness Float 8.0 Thickness of the zigzag ribbon. wavelength Float 10.0 Length of one full zigzag cycle along the helix axis. amplitude Float 3.0 Height of the zigzag peaks/valleys from the center line. min_helix_length Integer 4 Minimum number of residues required to draw a zigzag shape instead of a simple line. simplified_width Float 2.0 Line width used when the helix is rendered as a simple line (below min_helix_length). Sheet Style ( [sheet] ) Defines the appearance of beta sheets, typically rendered as arrows. Property Type Default Description color Color \"#0000ff\" Fill color for the sheet arrow (default blue). stroke_color Color \"#000000\" Color for the outline/stroke (default black). stroke_width Float 1.0 Reference width; primarily defines the base width of the arrow body. opacity Float 1.0 Opacity of the sheet element (0.0 to 1.0). arrow_width Float 8.0 Width of the arrowhead base relative to the start point. min_sheet_length Integer 3 Minimum number of residues required to draw an arrow shape instead of a line. simplified_width Float 2.0 Line width used when the sheet is rendered as a simple line (below min_sheet_length). Coil Style ( [coil] ) Defines the appearance of coil regions, typically rendered as smoothed lines. Property Type Default Description color Color \"#5b5859\" Color used for the coil line (default light grey). This often isn't visible as coils usually only have a stroke. stroke_color Color \"#000000\" Color for the coil line (default black). stroke_width Float 1.0 Width of the coil line. opacity Float 1.0 Opacity of the coil line (0.0 to 1.0). smoothing_factor Float 0.1 Fraction of points to keep during smoothing (0.0=max smoothing, 1.0=no smoothing). Annotation Styles Point Annotation Style The [point_annotation] section defines the appearance of point annotations. Property Type Description fill_color Color Fill color for point markers stroke_color Color Outline color for point markers radius Float Radius of point markers Line Annotation Style The [line_annotation] section defines the appearance of line annotations. Property Type Description stroke_color Color Color for line annotations stroke_width Float Width of line annotations Area Annotation Style The [area_annotation] section defines the appearance of area annotations. Property Type Description fill_color Color Fill color for area annotations fill_opacity Float Opacity for area fills (0.0-1.0) stroke_color Color Outline color for areas stroke_width Float Width of the area outline padding Float Padding around the area smoothing_window Integer Window size for smoothing the area outline interpolation_points Integer Number of points to use for interpolation Color Formats Colors can be specified in any of the following formats: Hex codes: \"#FF5733\" (with or without the # prefix) RGB format: \"rgb(255, 87, 51)\" RGBA format: \"rgba(255, 87, 51, 0.5)\" Named colors: \"red\" , \"blue\" , \"green\" , etc. Default Styles If a style file is not provided, or if certain properties are omitted, FlatProt will use default styles. You only need to specify the properties you want to customize. Validation FlatProt validates style files to ensure they have the correct format and property types. If a style file is invalid, an error message will be displayed explaining the issue.","title":"Style Files"},{"location":"file_formats/style/#style-file-format","text":"FlatProt uses TOML files for defining custom styles for protein visualizations. This document explains the format and options available for styling different elements of the visualization.","title":"Style File Format"},{"location":"file_formats/style/#overview","text":"Style files allow you to customize the appearance of various elements in the FlatProt visualization, including: Secondary structure elements (helices, sheets, coils) Annotations (points, lines, areas)","title":"Overview"},{"location":"file_formats/style/#file-format","text":"Style files use the TOML format, with each section defining styles for a specific element type.","title":"File Format"},{"location":"file_formats/style/#example-style-file","text":"# Secondary structure styles [helix] fill_color = \"#FF5733\" stroke_color = \"#000000\" stroke_width = 1.5 amplitude = 0.5 [sheet] fill_color = \"#33FF57\" stroke_color = \"#000000\" stroke_width = 1.0 min_sheet_length = 3 [coil] stroke_color = \"#888888\" stroke_width = 1.0 # Annotation styles [point_annotation] fill_color = \"#3357FF\" stroke_color = \"#000000\" radius = 5.0 [line_annotation] stroke_color = \"#FF33A8\" stroke_width = 2.0 [area_annotation] fill_color = \"#FFFF33\" fill_opacity = 0.5 stroke_color = \"#000000\" stroke_width = 1.0 padding = 2.0 smoothing_window = 3 interpolation_points = 10","title":"Example Style File"},{"location":"file_formats/style/#style-sections","text":"","title":"Style Sections"},{"location":"file_formats/style/#secondary-structure-styles","text":"These sections define the appearance of secondary structure elements rendered in the visualization. Common properties like color , stroke_color , stroke_width , and opacity are inherited but can be overridden.","title":"Secondary Structure Styles"},{"location":"file_formats/style/#helix-style-helix","text":"Defines the appearance of alpha helices, typically rendered as zigzag ribbons. Property Type Default Description color Color \"#ff0000\" Fill color for the helix ribbon (default red). stroke_color Color \"#000000\" Color for the outline/stroke (default black). stroke_width Float 1.0 Reference width; used as a base for other dimensions. opacity Float 1.0 Opacity of the helix element (0.0 to 1.0). ribbon_thickness Float 8.0 Thickness of the zigzag ribbon. wavelength Float 10.0 Length of one full zigzag cycle along the helix axis. amplitude Float 3.0 Height of the zigzag peaks/valleys from the center line. min_helix_length Integer 4 Minimum number of residues required to draw a zigzag shape instead of a simple line. simplified_width Float 2.0 Line width used when the helix is rendered as a simple line (below min_helix_length).","title":"Helix Style ([helix])"},{"location":"file_formats/style/#sheet-style-sheet","text":"Defines the appearance of beta sheets, typically rendered as arrows. Property Type Default Description color Color \"#0000ff\" Fill color for the sheet arrow (default blue). stroke_color Color \"#000000\" Color for the outline/stroke (default black). stroke_width Float 1.0 Reference width; primarily defines the base width of the arrow body. opacity Float 1.0 Opacity of the sheet element (0.0 to 1.0). arrow_width Float 8.0 Width of the arrowhead base relative to the start point. min_sheet_length Integer 3 Minimum number of residues required to draw an arrow shape instead of a line. simplified_width Float 2.0 Line width used when the sheet is rendered as a simple line (below min_sheet_length).","title":"Sheet Style ([sheet])"},{"location":"file_formats/style/#coil-style-coil","text":"Defines the appearance of coil regions, typically rendered as smoothed lines. Property Type Default Description color Color \"#5b5859\" Color used for the coil line (default light grey). This often isn't visible as coils usually only have a stroke. stroke_color Color \"#000000\" Color for the coil line (default black). stroke_width Float 1.0 Width of the coil line. opacity Float 1.0 Opacity of the coil line (0.0 to 1.0). smoothing_factor Float 0.1 Fraction of points to keep during smoothing (0.0=max smoothing, 1.0=no smoothing).","title":"Coil Style ([coil])"},{"location":"file_formats/style/#annotation-styles","text":"","title":"Annotation Styles"},{"location":"file_formats/style/#point-annotation-style","text":"The [point_annotation] section defines the appearance of point annotations. Property Type Description fill_color Color Fill color for point markers stroke_color Color Outline color for point markers radius Float Radius of point markers","title":"Point Annotation Style"},{"location":"file_formats/style/#line-annotation-style","text":"The [line_annotation] section defines the appearance of line annotations. Property Type Description stroke_color Color Color for line annotations stroke_width Float Width of line annotations","title":"Line Annotation Style"},{"location":"file_formats/style/#area-annotation-style","text":"The [area_annotation] section defines the appearance of area annotations. Property Type Description fill_color Color Fill color for area annotations fill_opacity Float Opacity for area fills (0.0-1.0) stroke_color Color Outline color for areas stroke_width Float Width of the area outline padding Float Padding around the area smoothing_window Integer Window size for smoothing the area outline interpolation_points Integer Number of points to use for interpolation","title":"Area Annotation Style"},{"location":"file_formats/style/#color-formats","text":"Colors can be specified in any of the following formats: Hex codes: \"#FF5733\" (with or without the # prefix) RGB format: \"rgb(255, 87, 51)\" RGBA format: \"rgba(255, 87, 51, 0.5)\" Named colors: \"red\" , \"blue\" , \"green\" , etc.","title":"Color Formats"},{"location":"file_formats/style/#default-styles","text":"If a style file is not provided, or if certain properties are omitted, FlatProt will use default styles. You only need to specify the properties you want to customize.","title":"Default Styles"},{"location":"file_formats/style/#validation","text":"FlatProt validates style files to ensure they have the correct format and property types. If a style file is invalid, an error message will be displayed explaining the issue.","title":"Validation"},{"location":"tools/custom_database/","text":"Creating Custom Databases FlatProt allows you to create custom alignment databases from your own collection of protein structures. This is useful when you want to work with specific protein families, custom datasets, or structures not included in the default database. \u26a0\ufe0f Important Updates The custom database script now creates a complete database directory containing: - HDF5 alignment database ( alignments.h5 ) - Foldseek database ( foldseek/db* ) - NEW! - Database info file ( database_info.json ) - NEW! Updated Usage: - Output is now a directory (not a single .h5 file) - Requires Foldseek to be installed - Use --database ./my_database_dir (not ./my_database.h5 ) Overview A custom database contains: Transformation matrices : Inertia-based transformations for each structure Structure metadata : Names, source files, and optional metadata HDF5 alignment database : Compatible with FlatProt's alignment system Foldseek database : For fast structural searching and alignment Database validation : Info file for FlatProt compatibility checks Data Format Requirements Input Structure Files FlatProt supports the following structure file formats: PDB format ( .pdb , .ent ) CIF format ( .cif ) - Recommended Compressed files ( .pdb.gz , .cif.gz ) Directory Structure Organize your structure files in a directory: my_structures/ \u251c\u2500\u2500 protein1.cif \u251c\u2500\u2500 protein2.cif \u251c\u2500\u2500 family_a/ \u2502 \u251c\u2500\u2500 member1.cif \u2502 \u2514\u2500\u2500 member2.cif \u2514\u2500\u2500 family_b/ \u251c\u2500\u2500 member3.pdb \u2514\u2500\u2500 member4.pdb.gz Structure Requirements Each structure file must contain: C-alpha atoms : Required for transformation calculations Standard residues : Non-standard residues are handled gracefully Single or multiple chains : All chains are processed Complete structures : Missing C-alpha atoms are skipped with warnings Database Creation Script Use the provided script to create custom databases: python scripts/create_custom_database.py <input_folder> <output_database_dir> [options] Basic Usage # Create basic database python scripts/create_custom_database.py ./my_structures ./my_custom_db # With verbose output python scripts/create_custom_database.py ./my_structures ./my_custom_db --verbose # Save creation info python scripts/create_custom_database.py ./my_structures ./my_custom_db --info-file db_info.json # Specify Foldseek executable if not in PATH python scripts/create_custom_database.py ./my_structures ./my_custom_db --foldseek-executable /path/to/foldseek Recommended Workflow: Manual Structure Rotation The preferred approach is to manually rotate structures before database creation: Step 1: Transform Structures in PyMOL/ChimeraX Important : Use transform_selection or transform_object to actually modify coordinates, not just the view: # PyMOL example - Transform coordinates, not just view load protein1.pdb load protein2.pdb # Align structures (this DOES change coordinates) align protein1, protein2 # Transform coordinates (NOT just rotate view) # Create transformation matrix for 45\u00b0 rotation around X-axis transform_selection protein1, [1,0,0,0, 0,0.707,-0.707,0, 0,0.707,0.707,0, 0,0,0,1] # Or use transform_object for the entire object transform_object protein1, [1,0,0,0, 0,0.707,-0.707,0, 0,0.707,0.707,0, 0,0,0,1] # Save with modified coordinates save protein1_rotated.pdb, protein1 save protein2_rotated.pdb, protein2 Alternative: Use matrix_copy after visual alignment : # Visual alignment approach load protein1.pdb load protein2.pdb # Visually align/rotate protein1 as desired using mouse/rotate commands rotate x, 45, protein1 # This only changes view rotate y, -30, protein1 # This only changes view # Apply the view transformation to coordinates matrix_copy protein1, protein1 # Copies view matrix to object matrix save protein1_rotated.pdb, protein1 Step 2: Create Database (No Additional Rotation) # Use structures as-is (recommended) python scripts/create_custom_database.py ./rotated_structures ./my_database This approach ensures: Foldseek alignment accuracy : Structures are oriented exactly as intended Consistent alignment : Manual control over structure orientation Optimal visualization : Structures positioned for best comparative viewing Alternative Rotation Methods For special cases, programmatic rotation is available: No Rotation (Default - Recommended) python scripts/create_custom_database.py ./structures ./my_database --rotate-method none Uses structures in their saved orientation. Recommended for manually rotated structures . Random Rotation python scripts/create_custom_database.py ./structures ./my_database --rotate-method random Applies random rotations before transformation. Mainly useful for testing robustness. Naming Patterns Control how structure names are generated: Filename-based (Default) python scripts/create_custom_database.py ./structures ./my_database --name-pattern filename Uses the filename without extension as the structure name. Parent Folder + Filename python scripts/create_custom_database.py ./structures ./my_database --name-pattern parent_folder Combines parent folder name with filename, useful for organizing families. Complete Example Manual Rotation Workflow # Step 1: Manually rotate structures in PyMOL pymol -c rotate_structures.py # Your rotation script # Step 2: Create database from pre-rotated structures python scripts/create_custom_database.py \\ ./manually_rotated_structures \\ ./databases/my_custom_db \\ --name-pattern parent_folder \\ --info-file my_db_info.json \\ --log-file creation.log \\ --verbose This workflow: Uses manually rotated structures (optimal for Foldseek alignment) Names entries using folder + filename pattern Saves detailed creation info and logs Provides verbose progress output Creates both HDF5 alignment database and Foldseek database Generates required database validation files PyMOL Batch Transformation Script # transform_structures.py - Example batch coordinate transformation script import pymol from pymol import cmd import os import math def create_rotation_matrix(axis, angle_deg): \"\"\"Create rotation matrix for given axis and angle.\"\"\" angle = math.radians(angle_deg) cos_a, sin_a = math.cos(angle), math.sin(angle) if axis == 'x': return [1,0,0,0, 0,cos_a,-sin_a,0, 0,sin_a,cos_a,0, 0,0,0,1] elif axis == 'y': return [cos_a,0,sin_a,0, 0,1,0,0, -sin_a,0,cos_a,0, 0,0,0,1] elif axis == 'z': return [cos_a,-sin_a,0,0, sin_a,cos_a,0,0, 0,0,1,0, 0,0,0,1] # Load structures structure_dir = \"./original_structures\" output_dir = \"./transformed_structures\" for filename in os.listdir(structure_dir): if filename.endswith(('.pdb', '.cif')): name = filename.split('.')[0] # Load structure cmd.load(f\"{structure_dir}/{filename}\", name) # Apply coordinate transformations (customize as needed) x_rotation_matrix = create_rotation_matrix('x', 45) y_rotation_matrix = create_rotation_matrix('y', -30) cmd.transform_object(name, x_rotation_matrix) cmd.transform_object(name, y_rotation_matrix) # Save transformed structure cmd.save(f\"{output_dir}/{filename}\", name) cmd.delete(name) cmd.quit() Alternative: Interactive Transformation # interactive_transform.py - Transform after visual positioning import pymol from pymol import cmd # Load structure cmd.load(\"protein.pdb\", \"prot\") # Rotate visually to desired orientation using PyMOL GUI # Then run this to apply the transformation to coordinates: cmd.matrix_copy(\"prot\", \"prot\") cmd.save(\"protein_transformed.pdb\", \"prot\") Using Custom Databases Once created, use your custom database with FlatProt commands. The custom database creates a directory containing both the HDF5 alignment database and the Foldseek database. Database Structure The script creates this directory structure: my_custom_db/ \u251c\u2500\u2500 alignments.h5 # HDF5 alignment database \u251c\u2500\u2500 database_info.json # Database metadata and validation \u2514\u2500\u2500 foldseek/ \u251c\u2500\u2500 db # Foldseek database files \u251c\u2500\u2500 db.index # (created by Foldseek) \u251c\u2500\u2500 db.dbtype # (created by Foldseek) \u2514\u2500\u2500 ... # (other Foldseek files) Using with FlatProt Commands Option 1: Command line argument (Recommended) # Specify the database directory path flatprot align structure.cif --database ./databases/my_custom_db # For other commands flatprot project structure.cif output.svg --database ./databases/my_custom_db flatprot overlay struct1.cif struct2.cif --database ./databases/my_custom_db Option 2: Environment variable # Set environment variable to database directory (not the .h5 file) export FLATPROT_ALIGNMENT_DB_PATH=\"./databases/my_custom_db\" flatprot align structure.cif # Or use it with other commands flatprot project structure.cif output.svg Verify Database Check your database contents: from flatprot.alignment.db import AlignmentDatabase # Path to the HDF5 file within the database directory with AlignmentDatabase(\"./databases/my_custom_db/alignments.h5\") as db: entries = db.list_entries() print(f\"Database contains {len(entries)} entries:\") for entry_id in entries[:5]: # Show first 5 entry = db.get_entry(entry_id) print(f\" {entry_id}: {entry.structure_name}\") Validate Database Check if your database is valid and has all required files: from flatprot.utils.database import validate_database from pathlib import Path db_path = Path(\"./databases/my_custom_db\") if validate_database(db_path): print(\"\u2713 Database is valid and ready to use\") else: print(\"\u2717 Database validation failed - check required files\") Database Format Details Complete Database Structure The custom database consists of three components: 1. HDF5 Alignment Database ( alignments.h5 ) alignments.h5 \u251c\u2500\u2500 /entries/ # Group containing all entries \u2502 \u251c\u2500\u2500 entry_id_1/ # Group for each structure \u2502 \u2502 \u251c\u2500\u2500 rotation_matrix # 4x4 transformation matrix \u2502 \u2502 \u2514\u2500\u2500 metadata # Optional metadata attributes \u2502 \u2514\u2500\u2500 entry_id_2/ \u2502 \u251c\u2500\u2500 rotation_matrix \u2502 \u2514\u2500\u2500 metadata \u2514\u2500\u2500 /index/ # Group for fast lookups \u2514\u2500\u2500 structure_names # Mapping structure names to entry IDs 2. Foldseek Database ( foldseek/db* ) Created by foldseek createdb , includes: - db - Main database file - db.index - Index for fast searching - db.dbtype - Database type information - Additional Foldseek-specific files 3. Database Info ( database_info.json ) Contains metadata and validation information: { \"database_type\": \"custom_alignment\", \"version\": \"1.0.0\", \"creation_date\": \"2025-01-XX...\", \"description\": \"Custom FlatProt alignment database\", \"statistics\": { ... }, \"files\": { \"alignment_database\": \"alignments.h5\", \"foldseek_database\": \"foldseek/db\" } } Transformation Matrices Each entry contains a 4x4 transformation matrix that: Centers the structure at the origin Aligns it to principal inertia axes Can be applied to transform coordinates Metadata Storage The script stores metadata for each entry: source_file : Original structure file path rotation_method : Rotation method used file_size : Original file size in bytes Advanced Configuration Manual Rotation Benefits Why manual rotation is preferred: Foldseek Accuracy : Structures are oriented exactly as intended for alignment Visual Control : You can see exactly how structures will be positioned Domain-Specific : Rotate to highlight specific structural features Consistent Orientation : Ensure all family members have the same orientation Quality Control : Inspect each structure during the rotation process PyMOL Transformation Examples # Example 1: Align all structures to a reference (coordinates changed) cmd.load(\"reference.pdb\", \"ref\") for structure in [\"protein1.pdb\", \"protein2.pdb\"]: name = structure.split('.')[0] cmd.load(structure, name) cmd.align(name, \"ref\") # This DOES change coordinates cmd.save(f\"aligned_{structure}\", name) # Example 2: Transform to show active site face-on cmd.load(\"enzyme.pdb\", \"enz\") # Create 90\u00b0 Y-rotation matrix y_90_matrix = [0,0,1,0, 0,1,0,0, -1,0,0,0, 0,0,0,1] cmd.transform_object(\"enz\", y_90_matrix) cmd.save(\"enzyme_transformed.pdb\", \"enz\") # Example 3: Interactive approach - visual then coordinate transformation cmd.load(\"membrane_protein.pdb\", \"mem\") # Manually rotate in GUI to desired orientation, then: cmd.matrix_copy(\"mem\", \"mem\") # Apply view to coordinates cmd.save(\"membrane_protein_oriented.pdb\", \"mem\") ChimeraX Alternative ChimeraX also provides coordinate transformation commands: # ChimeraX command line open protein.pdb turn x 45 # Rotate coordinates, not just view save protein_rotated.pdb Batch Processing For large datasets, consider: Processing in chunks if memory is limited Using the log file to monitor progress Running with --verbose to track issues Troubleshooting Common Issues No structures found Check file extensions are supported Verify directory path is correct Files may be corrupted or empty Transformation calculation fails Structure may lack C-alpha atoms File format may be invalid Try with --verbose for detailed error messages Memory issues Process smaller batches Check available system memory Large structures require more memory Performance Tips CIF format is generally faster than PDB Uncompressed files process faster than compressed SSD storage improves I/O performance Multiple small files are faster than few large files Integration with FlatProt Custom databases work seamlessly with all FlatProt commands: # Project structures using custom database flatprot project my_structure.cif output.svg --database ./my_database_dir # Align structures flatprot align structure.cif --database ./my_database_dir # Create overlays flatprot overlay structure1.cif structure2.cif --database ./my_database_dir --output overlay.svg # Using environment variable export FLATPROT_ALIGNMENT_DB_PATH=\"./my_database_dir\" flatprot project my_structure.cif output.svg The custom database provides the same functionality as the default database, optimized for your specific protein collection. Requirements Before creating custom databases, ensure you have: Foldseek installed and accessible (either in PATH or specify with --foldseek-executable ) Python dependencies : gemmi , numpy , flatprot Structure files in supported formats (PDB, CIF) Sufficient disk space for both input structures and database files Troubleshooting Foldseek Not Found # If Foldseek is not in PATH, specify the executable python scripts/create_custom_database.py ./structures ./my_db \\ --foldseek-executable /path/to/foldseek Database Validation Failed Use the validation function to check what's missing: from flatprot.utils.database import validate_database, REQUIRED_DB_FILES db_path = Path(\"./my_database\") if not validate_database(db_path): print(\"Missing files:\") for file in REQUIRED_DB_FILES: file_path = db_path / file if not file_path.exists(): print(f\" - {file}\") Memory Issues For large collections: - Process structures in smaller batches - Use --verbose to monitor progress - Ensure sufficient disk space for temporary files","title":"Custom Database"},{"location":"tools/custom_database/#creating-custom-databases","text":"FlatProt allows you to create custom alignment databases from your own collection of protein structures. This is useful when you want to work with specific protein families, custom datasets, or structures not included in the default database. \u26a0\ufe0f Important Updates The custom database script now creates a complete database directory containing: - HDF5 alignment database ( alignments.h5 ) - Foldseek database ( foldseek/db* ) - NEW! - Database info file ( database_info.json ) - NEW! Updated Usage: - Output is now a directory (not a single .h5 file) - Requires Foldseek to be installed - Use --database ./my_database_dir (not ./my_database.h5 )","title":"Creating Custom Databases"},{"location":"tools/custom_database/#overview","text":"A custom database contains: Transformation matrices : Inertia-based transformations for each structure Structure metadata : Names, source files, and optional metadata HDF5 alignment database : Compatible with FlatProt's alignment system Foldseek database : For fast structural searching and alignment Database validation : Info file for FlatProt compatibility checks","title":"Overview"},{"location":"tools/custom_database/#data-format-requirements","text":"","title":"Data Format Requirements"},{"location":"tools/custom_database/#input-structure-files","text":"FlatProt supports the following structure file formats: PDB format ( .pdb , .ent ) CIF format ( .cif ) - Recommended Compressed files ( .pdb.gz , .cif.gz )","title":"Input Structure Files"},{"location":"tools/custom_database/#directory-structure","text":"Organize your structure files in a directory: my_structures/ \u251c\u2500\u2500 protein1.cif \u251c\u2500\u2500 protein2.cif \u251c\u2500\u2500 family_a/ \u2502 \u251c\u2500\u2500 member1.cif \u2502 \u2514\u2500\u2500 member2.cif \u2514\u2500\u2500 family_b/ \u251c\u2500\u2500 member3.pdb \u2514\u2500\u2500 member4.pdb.gz","title":"Directory Structure"},{"location":"tools/custom_database/#structure-requirements","text":"Each structure file must contain: C-alpha atoms : Required for transformation calculations Standard residues : Non-standard residues are handled gracefully Single or multiple chains : All chains are processed Complete structures : Missing C-alpha atoms are skipped with warnings","title":"Structure Requirements"},{"location":"tools/custom_database/#database-creation-script","text":"Use the provided script to create custom databases: python scripts/create_custom_database.py <input_folder> <output_database_dir> [options]","title":"Database Creation Script"},{"location":"tools/custom_database/#basic-usage","text":"# Create basic database python scripts/create_custom_database.py ./my_structures ./my_custom_db # With verbose output python scripts/create_custom_database.py ./my_structures ./my_custom_db --verbose # Save creation info python scripts/create_custom_database.py ./my_structures ./my_custom_db --info-file db_info.json # Specify Foldseek executable if not in PATH python scripts/create_custom_database.py ./my_structures ./my_custom_db --foldseek-executable /path/to/foldseek","title":"Basic Usage"},{"location":"tools/custom_database/#recommended-workflow-manual-structure-rotation","text":"The preferred approach is to manually rotate structures before database creation:","title":"Recommended Workflow: Manual Structure Rotation"},{"location":"tools/custom_database/#step-1-transform-structures-in-pymolchimerax","text":"Important : Use transform_selection or transform_object to actually modify coordinates, not just the view: # PyMOL example - Transform coordinates, not just view load protein1.pdb load protein2.pdb # Align structures (this DOES change coordinates) align protein1, protein2 # Transform coordinates (NOT just rotate view) # Create transformation matrix for 45\u00b0 rotation around X-axis transform_selection protein1, [1,0,0,0, 0,0.707,-0.707,0, 0,0.707,0.707,0, 0,0,0,1] # Or use transform_object for the entire object transform_object protein1, [1,0,0,0, 0,0.707,-0.707,0, 0,0.707,0.707,0, 0,0,0,1] # Save with modified coordinates save protein1_rotated.pdb, protein1 save protein2_rotated.pdb, protein2 Alternative: Use matrix_copy after visual alignment : # Visual alignment approach load protein1.pdb load protein2.pdb # Visually align/rotate protein1 as desired using mouse/rotate commands rotate x, 45, protein1 # This only changes view rotate y, -30, protein1 # This only changes view # Apply the view transformation to coordinates matrix_copy protein1, protein1 # Copies view matrix to object matrix save protein1_rotated.pdb, protein1","title":"Step 1: Transform Structures in PyMOL/ChimeraX"},{"location":"tools/custom_database/#step-2-create-database-no-additional-rotation","text":"# Use structures as-is (recommended) python scripts/create_custom_database.py ./rotated_structures ./my_database This approach ensures: Foldseek alignment accuracy : Structures are oriented exactly as intended Consistent alignment : Manual control over structure orientation Optimal visualization : Structures positioned for best comparative viewing","title":"Step 2: Create Database (No Additional Rotation)"},{"location":"tools/custom_database/#alternative-rotation-methods","text":"For special cases, programmatic rotation is available:","title":"Alternative Rotation Methods"},{"location":"tools/custom_database/#no-rotation-default-recommended","text":"python scripts/create_custom_database.py ./structures ./my_database --rotate-method none Uses structures in their saved orientation. Recommended for manually rotated structures .","title":"No Rotation (Default - Recommended)"},{"location":"tools/custom_database/#random-rotation","text":"python scripts/create_custom_database.py ./structures ./my_database --rotate-method random Applies random rotations before transformation. Mainly useful for testing robustness.","title":"Random Rotation"},{"location":"tools/custom_database/#naming-patterns","text":"Control how structure names are generated:","title":"Naming Patterns"},{"location":"tools/custom_database/#filename-based-default","text":"python scripts/create_custom_database.py ./structures ./my_database --name-pattern filename Uses the filename without extension as the structure name.","title":"Filename-based (Default)"},{"location":"tools/custom_database/#parent-folder-filename","text":"python scripts/create_custom_database.py ./structures ./my_database --name-pattern parent_folder Combines parent folder name with filename, useful for organizing families.","title":"Parent Folder + Filename"},{"location":"tools/custom_database/#complete-example","text":"","title":"Complete Example"},{"location":"tools/custom_database/#manual-rotation-workflow","text":"# Step 1: Manually rotate structures in PyMOL pymol -c rotate_structures.py # Your rotation script # Step 2: Create database from pre-rotated structures python scripts/create_custom_database.py \\ ./manually_rotated_structures \\ ./databases/my_custom_db \\ --name-pattern parent_folder \\ --info-file my_db_info.json \\ --log-file creation.log \\ --verbose This workflow: Uses manually rotated structures (optimal for Foldseek alignment) Names entries using folder + filename pattern Saves detailed creation info and logs Provides verbose progress output Creates both HDF5 alignment database and Foldseek database Generates required database validation files","title":"Manual Rotation Workflow"},{"location":"tools/custom_database/#pymol-batch-transformation-script","text":"# transform_structures.py - Example batch coordinate transformation script import pymol from pymol import cmd import os import math def create_rotation_matrix(axis, angle_deg): \"\"\"Create rotation matrix for given axis and angle.\"\"\" angle = math.radians(angle_deg) cos_a, sin_a = math.cos(angle), math.sin(angle) if axis == 'x': return [1,0,0,0, 0,cos_a,-sin_a,0, 0,sin_a,cos_a,0, 0,0,0,1] elif axis == 'y': return [cos_a,0,sin_a,0, 0,1,0,0, -sin_a,0,cos_a,0, 0,0,0,1] elif axis == 'z': return [cos_a,-sin_a,0,0, sin_a,cos_a,0,0, 0,0,1,0, 0,0,0,1] # Load structures structure_dir = \"./original_structures\" output_dir = \"./transformed_structures\" for filename in os.listdir(structure_dir): if filename.endswith(('.pdb', '.cif')): name = filename.split('.')[0] # Load structure cmd.load(f\"{structure_dir}/{filename}\", name) # Apply coordinate transformations (customize as needed) x_rotation_matrix = create_rotation_matrix('x', 45) y_rotation_matrix = create_rotation_matrix('y', -30) cmd.transform_object(name, x_rotation_matrix) cmd.transform_object(name, y_rotation_matrix) # Save transformed structure cmd.save(f\"{output_dir}/{filename}\", name) cmd.delete(name) cmd.quit()","title":"PyMOL Batch Transformation Script"},{"location":"tools/custom_database/#alternative-interactive-transformation","text":"# interactive_transform.py - Transform after visual positioning import pymol from pymol import cmd # Load structure cmd.load(\"protein.pdb\", \"prot\") # Rotate visually to desired orientation using PyMOL GUI # Then run this to apply the transformation to coordinates: cmd.matrix_copy(\"prot\", \"prot\") cmd.save(\"protein_transformed.pdb\", \"prot\")","title":"Alternative: Interactive Transformation"},{"location":"tools/custom_database/#using-custom-databases","text":"Once created, use your custom database with FlatProt commands. The custom database creates a directory containing both the HDF5 alignment database and the Foldseek database.","title":"Using Custom Databases"},{"location":"tools/custom_database/#database-structure","text":"The script creates this directory structure: my_custom_db/ \u251c\u2500\u2500 alignments.h5 # HDF5 alignment database \u251c\u2500\u2500 database_info.json # Database metadata and validation \u2514\u2500\u2500 foldseek/ \u251c\u2500\u2500 db # Foldseek database files \u251c\u2500\u2500 db.index # (created by Foldseek) \u251c\u2500\u2500 db.dbtype # (created by Foldseek) \u2514\u2500\u2500 ... # (other Foldseek files)","title":"Database Structure"},{"location":"tools/custom_database/#using-with-flatprot-commands","text":"Option 1: Command line argument (Recommended) # Specify the database directory path flatprot align structure.cif --database ./databases/my_custom_db # For other commands flatprot project structure.cif output.svg --database ./databases/my_custom_db flatprot overlay struct1.cif struct2.cif --database ./databases/my_custom_db Option 2: Environment variable # Set environment variable to database directory (not the .h5 file) export FLATPROT_ALIGNMENT_DB_PATH=\"./databases/my_custom_db\" flatprot align structure.cif # Or use it with other commands flatprot project structure.cif output.svg","title":"Using with FlatProt Commands"},{"location":"tools/custom_database/#verify-database","text":"Check your database contents: from flatprot.alignment.db import AlignmentDatabase # Path to the HDF5 file within the database directory with AlignmentDatabase(\"./databases/my_custom_db/alignments.h5\") as db: entries = db.list_entries() print(f\"Database contains {len(entries)} entries:\") for entry_id in entries[:5]: # Show first 5 entry = db.get_entry(entry_id) print(f\" {entry_id}: {entry.structure_name}\")","title":"Verify Database"},{"location":"tools/custom_database/#validate-database","text":"Check if your database is valid and has all required files: from flatprot.utils.database import validate_database from pathlib import Path db_path = Path(\"./databases/my_custom_db\") if validate_database(db_path): print(\"\u2713 Database is valid and ready to use\") else: print(\"\u2717 Database validation failed - check required files\")","title":"Validate Database"},{"location":"tools/custom_database/#database-format-details","text":"","title":"Database Format Details"},{"location":"tools/custom_database/#complete-database-structure","text":"The custom database consists of three components:","title":"Complete Database Structure"},{"location":"tools/custom_database/#1-hdf5-alignment-database-alignmentsh5","text":"alignments.h5 \u251c\u2500\u2500 /entries/ # Group containing all entries \u2502 \u251c\u2500\u2500 entry_id_1/ # Group for each structure \u2502 \u2502 \u251c\u2500\u2500 rotation_matrix # 4x4 transformation matrix \u2502 \u2502 \u2514\u2500\u2500 metadata # Optional metadata attributes \u2502 \u2514\u2500\u2500 entry_id_2/ \u2502 \u251c\u2500\u2500 rotation_matrix \u2502 \u2514\u2500\u2500 metadata \u2514\u2500\u2500 /index/ # Group for fast lookups \u2514\u2500\u2500 structure_names # Mapping structure names to entry IDs","title":"1. HDF5 Alignment Database (alignments.h5)"},{"location":"tools/custom_database/#2-foldseek-database-foldseekdb","text":"Created by foldseek createdb , includes: - db - Main database file - db.index - Index for fast searching - db.dbtype - Database type information - Additional Foldseek-specific files","title":"2. Foldseek Database (foldseek/db*)"},{"location":"tools/custom_database/#3-database-info-database_infojson","text":"Contains metadata and validation information: { \"database_type\": \"custom_alignment\", \"version\": \"1.0.0\", \"creation_date\": \"2025-01-XX...\", \"description\": \"Custom FlatProt alignment database\", \"statistics\": { ... }, \"files\": { \"alignment_database\": \"alignments.h5\", \"foldseek_database\": \"foldseek/db\" } }","title":"3. Database Info (database_info.json)"},{"location":"tools/custom_database/#transformation-matrices","text":"Each entry contains a 4x4 transformation matrix that: Centers the structure at the origin Aligns it to principal inertia axes Can be applied to transform coordinates","title":"Transformation Matrices"},{"location":"tools/custom_database/#metadata-storage","text":"The script stores metadata for each entry: source_file : Original structure file path rotation_method : Rotation method used file_size : Original file size in bytes","title":"Metadata Storage"},{"location":"tools/custom_database/#advanced-configuration","text":"","title":"Advanced Configuration"},{"location":"tools/custom_database/#manual-rotation-benefits","text":"Why manual rotation is preferred: Foldseek Accuracy : Structures are oriented exactly as intended for alignment Visual Control : You can see exactly how structures will be positioned Domain-Specific : Rotate to highlight specific structural features Consistent Orientation : Ensure all family members have the same orientation Quality Control : Inspect each structure during the rotation process","title":"Manual Rotation Benefits"},{"location":"tools/custom_database/#pymol-transformation-examples","text":"# Example 1: Align all structures to a reference (coordinates changed) cmd.load(\"reference.pdb\", \"ref\") for structure in [\"protein1.pdb\", \"protein2.pdb\"]: name = structure.split('.')[0] cmd.load(structure, name) cmd.align(name, \"ref\") # This DOES change coordinates cmd.save(f\"aligned_{structure}\", name) # Example 2: Transform to show active site face-on cmd.load(\"enzyme.pdb\", \"enz\") # Create 90\u00b0 Y-rotation matrix y_90_matrix = [0,0,1,0, 0,1,0,0, -1,0,0,0, 0,0,0,1] cmd.transform_object(\"enz\", y_90_matrix) cmd.save(\"enzyme_transformed.pdb\", \"enz\") # Example 3: Interactive approach - visual then coordinate transformation cmd.load(\"membrane_protein.pdb\", \"mem\") # Manually rotate in GUI to desired orientation, then: cmd.matrix_copy(\"mem\", \"mem\") # Apply view to coordinates cmd.save(\"membrane_protein_oriented.pdb\", \"mem\")","title":"PyMOL Transformation Examples"},{"location":"tools/custom_database/#chimerax-alternative","text":"ChimeraX also provides coordinate transformation commands: # ChimeraX command line open protein.pdb turn x 45 # Rotate coordinates, not just view save protein_rotated.pdb","title":"ChimeraX Alternative"},{"location":"tools/custom_database/#batch-processing","text":"For large datasets, consider: Processing in chunks if memory is limited Using the log file to monitor progress Running with --verbose to track issues","title":"Batch Processing"},{"location":"tools/custom_database/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"tools/custom_database/#common-issues","text":"No structures found Check file extensions are supported Verify directory path is correct Files may be corrupted or empty Transformation calculation fails Structure may lack C-alpha atoms File format may be invalid Try with --verbose for detailed error messages Memory issues Process smaller batches Check available system memory Large structures require more memory","title":"Common Issues"},{"location":"tools/custom_database/#performance-tips","text":"CIF format is generally faster than PDB Uncompressed files process faster than compressed SSD storage improves I/O performance Multiple small files are faster than few large files","title":"Performance Tips"},{"location":"tools/custom_database/#integration-with-flatprot","text":"Custom databases work seamlessly with all FlatProt commands: # Project structures using custom database flatprot project my_structure.cif output.svg --database ./my_database_dir # Align structures flatprot align structure.cif --database ./my_database_dir # Create overlays flatprot overlay structure1.cif structure2.cif --database ./my_database_dir --output overlay.svg # Using environment variable export FLATPROT_ALIGNMENT_DB_PATH=\"./my_database_dir\" flatprot project my_structure.cif output.svg The custom database provides the same functionality as the default database, optimized for your specific protein collection.","title":"Integration with FlatProt"},{"location":"tools/custom_database/#requirements","text":"Before creating custom databases, ensure you have: Foldseek installed and accessible (either in PATH or specify with --foldseek-executable ) Python dependencies : gemmi , numpy , flatprot Structure files in supported formats (PDB, CIF) Sufficient disk space for both input structures and database files","title":"Requirements"},{"location":"tools/custom_database/#troubleshooting_1","text":"","title":"Troubleshooting"},{"location":"tools/custom_database/#foldseek-not-found","text":"# If Foldseek is not in PATH, specify the executable python scripts/create_custom_database.py ./structures ./my_db \\ --foldseek-executable /path/to/foldseek","title":"Foldseek Not Found"},{"location":"tools/custom_database/#database-validation-failed","text":"Use the validation function to check what's missing: from flatprot.utils.database import validate_database, REQUIRED_DB_FILES db_path = Path(\"./my_database\") if not validate_database(db_path): print(\"Missing files:\") for file in REQUIRED_DB_FILES: file_path = db_path / file if not file_path.exists(): print(f\" - {file}\")","title":"Database Validation Failed"},{"location":"tools/custom_database/#memory-issues","text":"For large collections: - Process structures in smaller batches - Use --verbose to monitor progress - Ensure sufficient disk space for temporary files","title":"Memory Issues"},{"location":"tools/database_builder/","text":"FlatProt Database Builder The database builder is a collection of tools for creating and managing FlatProt's structural alignment databases. It processes SCOP classifications and representative domain structures to create optimized databases for structural alignment. Overview The database building process consists of several automated steps: SCOP classification downloading and parsing PDB structure downloading with retry mechanism Domain extraction and validation All-vs-all domain alignment using Foldseek Representative domain selection Final database creation (HDF5 and Foldseek formats) Usage The entire database building process is managed through a Snakemake workflow. To build a new database: snakemake -s db_builder/snakefile --cores all Configuration The build process can be customized through the following variables in the snakefile: OUTPUT_DIR : Output path for the database (default: \"out/alignment_db\") WORK_DIR : Working directory for intermediate files (default: \"tmp/alignment_pipeline\") TEST_MODE : Enable test mode with limited superfamilies NUM_FAMILIES : Number of families to process in test mode (default: 401) RETRY_COUNT : Number of download retries (default: 3) CONCURRENT_DOWNLOADS : Maximum parallel downloads (default: 5) FOLDSEEK_PATH : Path to Foldseek executable (default: \"foldseek\") Database Structure The pipeline produces two main outputs: An HDF5 alignment database ( alignments.h5 ) containing: Domain structural information Superfamily classifications Alignment matrices A Foldseek database for rapid structural searching A JSON info file ( database_info.json ) with: Database statistics Creation timestamp Configuration parameters Pipeline Steps The workflow consists of the following main stages: SCOP Processing Downloads latest SCOP classification Parses and validates superfamily information Generates initial reports Structure Processing Downloads PDB structures with retry mechanism Validates downloads Extracts individual domains Generates domain extraction reports Domain Analysis Creates Foldseek databases per superfamily Performs all-vs-all structural alignments Selects representative domains Database Creation Aggregates representative domains Creates final HDF5 database Builds Foldseek search database Running in Docker docker run -it --rm -v $(pwd):/app ghcr.io/astral-sh/uv:python3.13-bookworm-slim apt update && apt install -y git wget git clone https://github.com/t03i/flatprot.git cd flatprot wget https://mmseqs.com/foldseek/foldseek-linux-avx2.tar.gz; tar xvzf foldseek-linux-avx2.tar.gz git checkout staging uv sync --all-groups uv run snakemake -s db_builder/snakefile --cores all --quiet --config foldseek_path=foldseek/foldseek ```","title":"Rebuild Default Database"},{"location":"tools/database_builder/#flatprot-database-builder","text":"The database builder is a collection of tools for creating and managing FlatProt's structural alignment databases. It processes SCOP classifications and representative domain structures to create optimized databases for structural alignment.","title":"FlatProt Database Builder"},{"location":"tools/database_builder/#overview","text":"The database building process consists of several automated steps: SCOP classification downloading and parsing PDB structure downloading with retry mechanism Domain extraction and validation All-vs-all domain alignment using Foldseek Representative domain selection Final database creation (HDF5 and Foldseek formats)","title":"Overview"},{"location":"tools/database_builder/#usage","text":"The entire database building process is managed through a Snakemake workflow. To build a new database: snakemake -s db_builder/snakefile --cores all","title":"Usage"},{"location":"tools/database_builder/#configuration","text":"The build process can be customized through the following variables in the snakefile: OUTPUT_DIR : Output path for the database (default: \"out/alignment_db\") WORK_DIR : Working directory for intermediate files (default: \"tmp/alignment_pipeline\") TEST_MODE : Enable test mode with limited superfamilies NUM_FAMILIES : Number of families to process in test mode (default: 401) RETRY_COUNT : Number of download retries (default: 3) CONCURRENT_DOWNLOADS : Maximum parallel downloads (default: 5) FOLDSEEK_PATH : Path to Foldseek executable (default: \"foldseek\")","title":"Configuration"},{"location":"tools/database_builder/#database-structure","text":"The pipeline produces two main outputs: An HDF5 alignment database ( alignments.h5 ) containing: Domain structural information Superfamily classifications Alignment matrices A Foldseek database for rapid structural searching A JSON info file ( database_info.json ) with: Database statistics Creation timestamp Configuration parameters","title":"Database Structure"},{"location":"tools/database_builder/#pipeline-steps","text":"The workflow consists of the following main stages: SCOP Processing Downloads latest SCOP classification Parses and validates superfamily information Generates initial reports Structure Processing Downloads PDB structures with retry mechanism Validates downloads Extracts individual domains Generates domain extraction reports Domain Analysis Creates Foldseek databases per superfamily Performs all-vs-all structural alignments Selects representative domains Database Creation Aggregates representative domains Creates final HDF5 database Builds Foldseek search database","title":"Pipeline Steps"},{"location":"tools/database_builder/#running-in-docker","text":"docker run -it --rm -v $(pwd):/app ghcr.io/astral-sh/uv:python3.13-bookworm-slim apt update && apt install -y git wget git clone https://github.com/t03i/flatprot.git cd flatprot wget https://mmseqs.com/foldseek/foldseek-linux-avx2.tar.gz; tar xvzf foldseek-linux-avx2.tar.gz git checkout staging uv sync --all-groups uv run snakemake -s db_builder/snakefile --cores all --quiet --config foldseek_path=foldseek/foldseek ```","title":"Running in Docker"},{"location":"tools/matrix_extraction/","text":"PyMOL Matrix Extraction The get_matrix.py script allows you to interactively orient a protein structure in PyMOL and extract the transformation matrix for use with flatprot's project command. Usage uv run scripts/get_matrix.py <structure_file> Example uv run scripts/get_matrix.py data/3Ftx/cobra.cif How it Works Launches PyMOL : Opens PyMOL with the specified structure file Interactive Orientation : Allows you to manually rotate, translate, and zoom the structure to your desired view Matrix Extraction : Captures PyMOL's current view matrix using cmd.get_view() Coordinate System Conversion : Applies proper transformations for PyMOL \u2194 flatprot compatibility File Output : Saves the matrix as rotation_matrix.npy Auto-quit : PyMOL automatically closes after matrix extraction Matrix Format The script extracts PyMOL's view matrix and converts it to flatprot's format: PyMOL format : 18-element tuple (rotation[9], translation[3], origin[3], clipping[2], orthoscopic[1]) flatprot format : 4x3 numpy array where: First 3 rows: 3x3 rotation matrix Last row: 3-element translation vector Coordinate System Transformation The script automatically handles coordinate system differences between PyMOL and flatprot: The Problem PyMOL : Uses a graphics coordinate system (Y-up, right-handed) flatprot : Uses a mathematical coordinate system Result : Direct matrix transfer causes mirrored/flipped rotations Current Status The script now applies a complete coordinate system transformation : 1. Extracts PyMOL view matrix (camera coordinates) 2. Inverts the matrix to convert from camera to object transformation 3. Applies Y-axis flip for final coordinate system alignment 4. PyMOL automatically quits after matrix extraction Complete Transformation Process Step 1: Camera vs Object Transformation - PyMOL : cmd.get_view() returns a camera matrix (camera rotates around stationary object) - flatprot : Expects an object transformation matrix (object rotates while camera stays fixed) - Solution : Invert the camera matrix \u2192 object_matrix = inverse(camera_matrix) Step 2: Y-Axis Flip - Issue : Coordinate system handedness differences - Solution : Apply Y-axis flip \u2192 [x, y, z] \u2192 [x, -y, z] Final Result : PyMOL orientation perfectly matches flatprot projection Using the Extracted Matrix After running the script, you can use the extracted matrix with flatprot: uv run flatprot project <structure_file> output.svg --matrix rotation_matrix.npy Tips for Best Results Orient Carefully : Take time to get the exact orientation you want in PyMOL Use Cartoon Representation : The script automatically sets cartoon representation for better visualization Test the Result : Always test the extracted matrix with flatprot to ensure the orientation matches your expectations Dependencies PyMOL (for interactive structure manipulation) NumPy (for matrix operations) Installation Install PyMOL using homebrew: brew install pymol The script will check for PyMOL availability and provide installation instructions if needed.","title":"PyMOL Matrix Extraction"},{"location":"tools/matrix_extraction/#pymol-matrix-extraction","text":"The get_matrix.py script allows you to interactively orient a protein structure in PyMOL and extract the transformation matrix for use with flatprot's project command.","title":"PyMOL Matrix Extraction"},{"location":"tools/matrix_extraction/#usage","text":"uv run scripts/get_matrix.py <structure_file>","title":"Usage"},{"location":"tools/matrix_extraction/#example","text":"uv run scripts/get_matrix.py data/3Ftx/cobra.cif","title":"Example"},{"location":"tools/matrix_extraction/#how-it-works","text":"Launches PyMOL : Opens PyMOL with the specified structure file Interactive Orientation : Allows you to manually rotate, translate, and zoom the structure to your desired view Matrix Extraction : Captures PyMOL's current view matrix using cmd.get_view() Coordinate System Conversion : Applies proper transformations for PyMOL \u2194 flatprot compatibility File Output : Saves the matrix as rotation_matrix.npy Auto-quit : PyMOL automatically closes after matrix extraction","title":"How it Works"},{"location":"tools/matrix_extraction/#matrix-format","text":"The script extracts PyMOL's view matrix and converts it to flatprot's format: PyMOL format : 18-element tuple (rotation[9], translation[3], origin[3], clipping[2], orthoscopic[1]) flatprot format : 4x3 numpy array where: First 3 rows: 3x3 rotation matrix Last row: 3-element translation vector","title":"Matrix Format"},{"location":"tools/matrix_extraction/#coordinate-system-transformation","text":"The script automatically handles coordinate system differences between PyMOL and flatprot:","title":"Coordinate System Transformation"},{"location":"tools/matrix_extraction/#the-problem","text":"PyMOL : Uses a graphics coordinate system (Y-up, right-handed) flatprot : Uses a mathematical coordinate system Result : Direct matrix transfer causes mirrored/flipped rotations","title":"The Problem"},{"location":"tools/matrix_extraction/#current-status","text":"The script now applies a complete coordinate system transformation : 1. Extracts PyMOL view matrix (camera coordinates) 2. Inverts the matrix to convert from camera to object transformation 3. Applies Y-axis flip for final coordinate system alignment 4. PyMOL automatically quits after matrix extraction","title":"Current Status"},{"location":"tools/matrix_extraction/#complete-transformation-process","text":"Step 1: Camera vs Object Transformation - PyMOL : cmd.get_view() returns a camera matrix (camera rotates around stationary object) - flatprot : Expects an object transformation matrix (object rotates while camera stays fixed) - Solution : Invert the camera matrix \u2192 object_matrix = inverse(camera_matrix) Step 2: Y-Axis Flip - Issue : Coordinate system handedness differences - Solution : Apply Y-axis flip \u2192 [x, y, z] \u2192 [x, -y, z] Final Result : PyMOL orientation perfectly matches flatprot projection","title":"Complete Transformation Process"},{"location":"tools/matrix_extraction/#using-the-extracted-matrix","text":"After running the script, you can use the extracted matrix with flatprot: uv run flatprot project <structure_file> output.svg --matrix rotation_matrix.npy","title":"Using the Extracted Matrix"},{"location":"tools/matrix_extraction/#tips-for-best-results","text":"Orient Carefully : Take time to get the exact orientation you want in PyMOL Use Cartoon Representation : The script automatically sets cartoon representation for better visualization Test the Result : Always test the extracted matrix with flatprot to ensure the orientation matches your expectations","title":"Tips for Best Results"},{"location":"tools/matrix_extraction/#dependencies","text":"PyMOL (for interactive structure manipulation) NumPy (for matrix operations)","title":"Dependencies"},{"location":"tools/matrix_extraction/#installation","text":"Install PyMOL using homebrew: brew install pymol The script will check for PyMOL availability and provide installation instructions if needed.","title":"Installation"}]}